[["@@ -1,6 +1,6 @@\r\n \t\tprivate boolean startsWithArgumentClassName(String message) {\r\n-\t\t\tPredicate<Object> startsWith = (argument) -> argument != null\r\n-\t\t\t\t\t&& message.startsWith(argument.getClass().getName());\r\n+\t\t\tPredicate<Object> startsWith = (argument) -> startsWithArgumentClassName(\r\n+\t\t\t\t\tmessage, argument);\r\n \t\t\treturn startsWith.test(this.argument)\r\n \t\t\t\t\t|| Stream.of(this.additionalArguments).anyMatch(startsWith);\r\n \t\t}", "Buggy", "Attempt to fix lambda error detection on JDK 9\n\nUpdate `LambdaSafe` to also detect `ClassCastException` messages that\nstart with \"module/name\".\n\nSee gh-11584"], ["@@ -1,7 +1,9 @@\r\n     SetBuilderImpl<E> review() {\r\n       int targetTableSize = chooseTableSize(distinct);\r\n       if (targetTableSize * 2 < hashTable.length) {\r\n         hashTable = rebuildHashTable(targetTableSize, dedupedElements, distinct);\r\n+        maxRunBeforeFallback = maxRunBeforeFallback(targetTableSize);\r\n+        expandTableThreshold = (int) (DESIRED_LOAD_FACTOR * targetTableSize);\r\n       }\r\n       return hashFloodingDetected(hashTable) ? new JdkBackedSetBuilderImpl<E>(this) : this;\r\n     }", "Buggy", "Fix #3570 by resetting expandTableThreshold and\nmaxRunBeforeFallback after resizing the hashTable.\n\nFixes #3571\n\n[]\n\nRELNOTES=Fixed a bug in `ImmutableSet.Builder` that could lead to infinite loops when building multiple sets from the same builder.\n\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=264648412"], ["@@ -1,5 +1,5 @@\n \tprivate void extractSignature(String sig) {\n \t\tif (sig != null) {\n-\t\t\tnew SignatureReader(sig).acceptType(sigVisitor);\n+\t\t\tnew SignatureReader(sig).accept(sigVisitor);\n \t\t}\n \t}", "Buggy", "bug fix: acceptType only works for fields and locals\n\n\ngit-svn-id: https://pmd.svn.sourceforge.net/svnroot/pmd/trunk@4822 51baf565-9d33-0410-a72c-fc3788e3496d"], ["@@ -1,3 +1,3 @@\r\n     @Override public int size() {\r\n-      return safeIntFactorial(inputList.size());\r\n+      return IntMath.factorial(inputList.size());\r\n     }", "Buggy", "Nuke 85 lines of code in Collections2 by adopting common.math. Which apparently fixed a size calculation bug that wasn't found due to a bad test that thought C(34,14) > MAX_VALUE.  (?)\n\nAlso snuck a call to IntMath.pow() into cartesianProduct.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=28310475"], ["@@ -1,24 +1,26 @@\r\n   static <T> TypeToken<? extends T> toGenericType(Class<T> cls) {\r\n     if (cls.isArray()) {\r\n       Type arrayOfGenericType =\r\n           Types.newArrayType(\r\n               // If we are passed with int[].class, don't turn it to GenericArrayType\r\n               toGenericType(cls.getComponentType()).runtimeType);\r\n       @SuppressWarnings(\"unchecked\") // array is covariant\r\n       TypeToken<? extends T> result = (TypeToken<? extends T>) of(arrayOfGenericType);\r\n       return result;\r\n     }\r\n     TypeVariable<Class<T>>[] typeParams = cls.getTypeParameters();\r\n     Type ownerType =\r\n-        cls.isMemberClass() ? toGenericType(cls.getEnclosingClass()).runtimeType : null;\r\n+        cls.isMemberClass() && !Modifier.isStatic(cls.getModifiers())\r\n+            ? toGenericType(cls.getEnclosingClass()).runtimeType\r\n+            : null;\r\n \r\n-    if ((typeParams.length > 0) || (ownerType != cls.getEnclosingClass())) {\r\n+    if ((typeParams.length > 0) || ((ownerType != null) && ownerType != cls.getEnclosingClass())) {\r\n       @SuppressWarnings(\"unchecked\") // Like, it's Iterable<T> for Iterable.class\r\n       TypeToken<? extends T> type =\r\n           (TypeToken<? extends T>)\r\n               of(Types.newParameterizedTypeWithOwner(ownerType, cls, typeParams));\r\n       return type;\r\n     } else {\r\n       return of(cls);\r\n     }\r\n   }", "Buggy", "Currently, SomeClass<?>.getSubType(SubClass<?, OtherT>) returns SubClass<?, OtherT>.\nHowever, if we do NotGeneric.getSubtype(SubClass<OtherT>), we get SubClass as a raw type instead of\nSubClass<OtherT>.\n\nIf we fix that bug, then as it turns out we weren't generating proper owners for static classes, so fix that too\n-------------\nCreated by MOE: https://github.com/google/moe\nMOE_MIGRATED_REVID=119755147"], ["@@ -1,3 +1,3 @@\n     public void setIsArrayDereference() {\n-        isArrayDeference = true;\n+        isArrayDereference = true;\n     }", "NotBuggy", "Fixed bug 1242544 - SimplifyConditional no longer flags null checks that precede an instanceof involving an array dereference.\n\n\ngit-svn-id: https://pmd.svn.sourceforge.net/svnroot/pmd/trunk@3728 51baf565-9d33-0410-a72c-fc3788e3496d"], ["@@ -1,25 +1,21 @@\r\n   public String collapseFrom(CharSequence sequence, char replacement) {\r\n-    int first = indexIn(sequence);\r\n-    if (first == -1) {\r\n-      return sequence.toString();\r\n-    }\r\n-\r\n-    // TODO(kevinb): see if this implementation can be made faster\r\n-    StringBuilder builder = new StringBuilder(sequence.length())\r\n-        .append(sequence.subSequence(0, first))\r\n-        .append(replacement);\r\n-    boolean in = true;\r\n-    for (int i = first + 1; i < sequence.length(); i++) {\r\n+    // This implementation avoids unnecessary allocation.\r\n+    int len = sequence.length();\r\n+    for (int i = 0; i < len; i++) {\r\n       char c = sequence.charAt(i);\r\n       if (matches(c)) {\r\n-        if (!in) {\r\n-          builder.append(replacement);\r\n-          in = true;\r\n+        if (c == replacement\r\n+            && (i == len - 1 || !matches(sequence.charAt(i + 1)))) {\r\n+          // a no-op replacement\r\n+          i++;\r\n+        } else {\r\n+          StringBuilder builder = new StringBuilder(len)\r\n+              .append(sequence.subSequence(0, i))\r\n+              .append(replacement);\r\n+          return finishCollapseFrom(sequence, i + 1, len, replacement, builder, true);\r\n         }\r\n-      } else {\r\n-        builder.append(c);\r\n-        in = false;\r\n       }\r\n     }\r\n-    return builder.toString();\r\n+    // no replacement needed\r\n+    return sequence.toString();\r\n   }", "NotBuggy", "Optimize collapseFrom and trimAndCollapseFrom so that they\nonly allocate if necessary.  Add a few tests.  Remove the GWT\nworkarounds for GWT bug 4491 since it appears to be fixed.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=39757514"], ["@@ -1,8 +1,7 @@\r\n   public Stopwatch stop() {\r\n     long tick = ticker.read();\r\n-    checkState(isRunning,\r\n-        \"This stopwatch is already stopped; it cannot be stopped more than once.\");\r\n+    checkState(isRunning, \"This stopwatch is already stopped.\");\r\n     isRunning = false;\r\n     elapsedNanos += tick - startTick;\r\n     return this;\r\n   }", "NotBuggy", "Miscellaneous documentation fixes and internal cleanups.\n- Remove potentially misleading \"it cannot be started/stopped more than once\" from Stopwatch exception messages.\n- Fix TreeTraverser ASCII art.\n- Remove inaccurate @GwtCompatible annotation from FeatureUtil.\n- Fix mistaken duplicate words (\"the the,\" etc.).\n- Strip *all* of benchmark running instructions from CharMatcherBenchmark, and preemptively strip instructions from internal escapers benchmarks.\n- Remove test <echo> from ant section of pom.xml.\n- Add @Nullable to StandardBaseEncoding's other constructor's paddingChar parameter.\n- Remove stale comment from Futures. (UninterruptibleFuture is long dead.)\n- Update name of Truth GWT module.\n-------------\nCreated by MOE: http://code.google.com/p/moe-java\nMOE_MIGRATED_REVID=42036409"], ["@@ -1,12 +1,12 @@\n     public void publish(LogRecord logRecord) {\n-        System.out.println(logRecord.getMessage());\n+        System.out.println(FORMATTER.format(logRecord));\n         if (logRecord.getThrown() != null) {\n             // Use the same channel, to make sure that the stacktrace comes\n             // after the message on the console (using printStackTrace\n             // directly messes things up)\n             StringWriter stringWriter = new StringWriter();\n             PrintWriter printWriter = new PrintWriter(stringWriter, true);\n             logRecord.getThrown().printStackTrace(printWriter);\n             System.out.println(stringWriter.toString());\n         }\n     }", "NotBuggy", "Fixed formatting problems in loggers\n\ngit-svn-id: https://pmd.svn.sourceforge.net/svnroot/pmd/trunk@5905 51baf565-9d33-0410-a72c-fc3788e3496d"], ["@@ -1,3 +1,3 @@\n-    private boolean postFixWithExceptions(SimpleNode primaryExpression) {\n+    private boolean isStandAlonePostfix(SimpleNode primaryExpression) {\n         return primaryExpression instanceof ASTPostfixExpression && primaryExpression.jjtGetParent() instanceof ASTStatementExpression && thirdChildHasDottedName(primaryExpression);\n     }", "NotBuggy", "Fixed a predecrement problem\n\n\ngit-svn-id: https://pmd.svn.sourceforge.net/svnroot/pmd/trunk@3005 51baf565-9d33-0410-a72c-fc3788e3496d"]]