From 792839b464bc3df40f773147b7694b761cf23b5a Mon Sep 17 00:00:00 2001
From: Gilles Sadowski <erans@apache.org>
Date: Wed, 2 Jul 2014 18:09:36 +0000
Subject: [PATCH] MATH-1134 Flag to request initialization of the internal data
 needed to call the partial derivatives methods.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1607434 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |   3 +-
 .../BicubicSplineInterpolatingFunction.java   | 238 ++++++++++++------
 .../BicubicSplineInterpolator.java            |  28 ++-
 .../TricubicSplineInterpolator.java           |   2 +-
 4 files changed, 190 insertions(+), 81 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index d77627220f..d27c56676b 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -75,7 +75,8 @@ Users are encouraged to upgrade to this version as this release not
 ">
       <action dev="erans" type="fix" issue="MATH-1134">
         "BicubicSplineInterpolatingFunction": all fields made final and initialized in
-        the constructor.
+        the constructor. Added flag to request initialization, or not, of the internal
+        data needed for partial derivatives.
       </action>
       <action dev="psteitz" type="fix" issue="MATH-984">
         Constrained EmpiricalDistribution sample/getNextValue methods to return
diff --git a/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.java b/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.java
index db12cdc9d1..6a19ca67ee 100644
--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.java
+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.java
@@ -101,6 +101,44 @@ public BicubicSplineInterpolatingFunction(double[] x,
         throws DimensionMismatchException,
                NoDataException,
                NonMonotonicSequenceException {
+        this(x, y, f, dFdX, dFdY, d2FdXdY, false);
+    }
+
+    /**
+     * @param x Sample values of the x-coordinate, in increasing order.
+     * @param y Sample values of the y-coordinate, in increasing order.
+     * @param f Values of the function on every grid point.
+     * @param dFdX Values of the partial derivative of function with respect
+     * to x on every grid point.
+     * @param dFdY Values of the partial derivative of function with respect
+     * to y on every grid point.
+     * @param d2FdXdY Values of the cross partial derivative of function on
+     * every grid point.
+     * @param initializeDerivatives Whether to initialize the internal data
+     * needed for calling any of the methods that compute the partial derivatives
+     * this function.
+     * @throws DimensionMismatchException if the various arrays do not contain
+     * the expected number of elements.
+     * @throws NonMonotonicSequenceException if {@code x} or {@code y} are
+     * not strictly increasing.
+     * @throws NoDataException if any of the arrays has zero length.
+     *
+     * @see #partialDerivativeX(double,double)
+     * @see #partialDerivativeY(double,double)
+     * @see #partialDerivativeXX(double,double)
+     * @see #partialDerivativeYY(double,double)
+     * @see #partialDerivativeXY(double,double)
+     */
+    public BicubicSplineInterpolatingFunction(double[] x,
+                                              double[] y,
+                                              double[][] f,
+                                              double[][] dFdX,
+                                              double[][] dFdY,
+                                              double[][] d2FdXdY,
+                                              boolean initializeDerivatives)
+        throws DimensionMismatchException,
+               NoDataException,
+               NonMonotonicSequenceException {
         final int xLen = x.length;
         final int yLen = y.length;
 
@@ -153,23 +191,28 @@ public BicubicSplineInterpolatingFunction(double[] x,
                     d2FdXdY[i][j], d2FdXdY[ip1][j], d2FdXdY[i][jp1], d2FdXdY[ip1][jp1]
                 };
 
-                splines[i][j] = new BicubicSplineFunction(computeSplineCoefficients(beta));
+                splines[i][j] = new BicubicSplineFunction(computeSplineCoefficients(beta),
+                                                          initializeDerivatives);
             }
         }
 
-        // Compute all partial derivatives.
-
-        partialDerivatives = new BivariateFunction[5][lastI][lastJ];
-
-        for (int i = 0; i < lastI; i++) {
-            for (int j = 0; j < lastJ; j++) {
-                final BicubicSplineFunction bcs = splines[i][j];
-                partialDerivatives[0][i][j] = bcs.partialDerivativeX();
-                partialDerivatives[1][i][j] = bcs.partialDerivativeY();
-                partialDerivatives[2][i][j] = bcs.partialDerivativeXX();
-                partialDerivatives[3][i][j] = bcs.partialDerivativeYY();
-                partialDerivatives[4][i][j] = bcs.partialDerivativeXY();
+        if (initializeDerivatives) {
+            // Compute all partial derivatives.
+            partialDerivatives = new BivariateFunction[5][lastI][lastJ];
+
+            for (int i = 0; i < lastI; i++) {
+                for (int j = 0; j < lastJ; j++) {
+                    final BicubicSplineFunction bcs = splines[i][j];
+                    partialDerivatives[0][i][j] = bcs.partialDerivativeX();
+                    partialDerivatives[1][i][j] = bcs.partialDerivativeY();
+                    partialDerivatives[2][i][j] = bcs.partialDerivativeXX();
+                    partialDerivatives[3][i][j] = bcs.partialDerivativeYY();
+                    partialDerivatives[4][i][j] = bcs.partialDerivativeXY();
+                }
             }
+        } else {
+            // Partial derivative methods cannot be used.
+            partialDerivatives = null;
         }
     }
 
@@ -214,6 +257,9 @@ public boolean isValidPoint(double x, double y) {
      * @throws OutOfRangeException if {@code x} (resp. {@code y}) is outside
      * the range defined by the boundary values of {@code xval} (resp.
      * {@code yval}).
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
      */
     public double partialDerivativeX(double x, double y)
         throws OutOfRangeException {
@@ -227,6 +273,9 @@ public double partialDerivativeX(double x, double y)
      * @throws OutOfRangeException if {@code x} (resp. {@code y}) is outside
      * the range defined by the boundary values of {@code xval} (resp.
      * {@code yval}).
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
      */
     public double partialDerivativeY(double x, double y)
         throws OutOfRangeException {
@@ -240,6 +289,9 @@ public double partialDerivativeY(double x, double y)
      * @throws OutOfRangeException if {@code x} (resp. {@code y}) is outside
      * the range defined by the boundary values of {@code xval} (resp.
      * {@code yval}).
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
      */
     public double partialDerivativeXX(double x, double y)
         throws OutOfRangeException {
@@ -253,6 +305,9 @@ public double partialDerivativeXX(double x, double y)
      * @throws OutOfRangeException if {@code x} (resp. {@code y}) is outside
      * the range defined by the boundary values of {@code xval} (resp.
      * {@code yval}).
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
      */
     public double partialDerivativeYY(double x, double y)
         throws OutOfRangeException {
@@ -265,6 +320,9 @@ public double partialDerivativeYY(double x, double y)
      * @throws OutOfRangeException if {@code x} (resp. {@code y}) is outside
      * the range defined by the boundary values of {@code xval} (resp.
      * {@code yval}).
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
      */
     public double partialDerivativeXY(double x, double y)
         throws OutOfRangeException {
@@ -279,6 +337,9 @@ public double partialDerivativeXY(double x, double y)
      * @throws OutOfRangeException if {@code x} (resp. {@code y}) is outside
      * the range defined by the boundary values of {@code xval} (resp.
      * {@code yval}).
+     * @throws NullPointerException if the internal data were not initialized
+     * (cf. {@link #BicubicSplineInterpolatingFunction(double[],double[],double[][],
+     *             double[][],double[][],double[][],boolean) constructor}).
      */
     private double partialDerivative(int which, double x, double y)
         throws OutOfRangeException {
@@ -391,9 +452,23 @@ class BicubicSplineFunction implements BivariateFunction {
 
     /**
      * Simple constructor.
-     * @param coeff Spline coefficients
+     *
+     * @param coeff Spline coefficients.
      */
     public BicubicSplineFunction(double[] coeff) {
+        this(coeff, false);
+    }
+
+    /**
+     * Simple constructor.
+     *
+     * @param coeff Spline coefficients.
+     * @param initializeDerivatives Whether to initialize the internal data
+     * needed for calling any of the methods that compute the partial derivatives
+     * this function.
+     */
+    public BicubicSplineFunction(double[] coeff,
+                                 boolean initializeDerivatives) {
         a = new double[N][N];
         for (int i = 0; i < N; i++) {
             for (int j = 0; j < N; j++) {
@@ -401,82 +476,89 @@ public BicubicSplineFunction(double[] coeff) {
             }
         }
 
-        // Compute all partial derivatives functions.
-
-        final double[][] aX = new double[N][N];
-        final double[][] aY = new double[N][N];
-        final double[][] aXX = new double[N][N];
-        final double[][] aYY = new double[N][N];
-        final double[][] aXY = new double[N][N];
-
-        for (int i = 0; i < N; i++) {
-            for (int j = 0; j < N; j++) {
-                final double c = a[i][j];
-                aX[i][j] = i * c;
-                aY[i][j] = j * c;
-                aXX[i][j] = (i - 1) * aX[i][j];
-                aYY[i][j] = (j - 1) * aY[i][j];
-                aXY[i][j] = j * aX[i][j];
+        if (initializeDerivatives) {
+            // Compute all partial derivatives functions.
+            final double[][] aX = new double[N][N];
+            final double[][] aY = new double[N][N];
+            final double[][] aXX = new double[N][N];
+            final double[][] aYY = new double[N][N];
+            final double[][] aXY = new double[N][N];
+
+            for (int i = 0; i < N; i++) {
+                for (int j = 0; j < N; j++) {
+                    final double c = a[i][j];
+                    aX[i][j] = i * c;
+                    aY[i][j] = j * c;
+                    aXX[i][j] = (i - 1) * aX[i][j];
+                    aYY[i][j] = (j - 1) * aY[i][j];
+                    aXY[i][j] = j * aX[i][j];
+                }
             }
-        }
 
-        partialDerivativeX = new BivariateFunction() {
-                public double value(double x, double y)  {
-                    final double x2 = x * x;
-                    final double[] pX = {0, 1, x, x2};
+            partialDerivativeX = new BivariateFunction() {
+                    public double value(double x, double y)  {
+                        final double x2 = x * x;
+                        final double[] pX = {0, 1, x, x2};
 
-                    final double y2 = y * y;
-                    final double y3 = y2 * y;
-                    final double[] pY = {1, y, y2, y3};
+                        final double y2 = y * y;
+                        final double y3 = y2 * y;
+                        final double[] pY = {1, y, y2, y3};
 
-                    return apply(pX, pY, aX);
-                }
-            };
-        partialDerivativeY = new BivariateFunction() {
-                public double value(double x, double y)  {
-                    final double x2 = x * x;
-                    final double x3 = x2 * x;
-                    final double[] pX = {1, x, x2, x3};
+                        return apply(pX, pY, aX);
+                    }
+                };
+            partialDerivativeY = new BivariateFunction() {
+                    public double value(double x, double y)  {
+                        final double x2 = x * x;
+                        final double x3 = x2 * x;
+                        final double[] pX = {1, x, x2, x3};
 
-                    final double y2 = y * y;
-                    final double[] pY = {0, 1, y, y2};
+                        final double y2 = y * y;
+                        final double[] pY = {0, 1, y, y2};
 
-                    return apply(pX, pY, aY);
-                }
-            };
-        partialDerivativeXX = new BivariateFunction() {
-                public double value(double x, double y)  {
-                    final double[] pX = {0, 0, 1, x};
+                        return apply(pX, pY, aY);
+                    }
+                };
+            partialDerivativeXX = new BivariateFunction() {
+                    public double value(double x, double y)  {
+                        final double[] pX = {0, 0, 1, x};
 
-                    final double y2 = y * y;
-                    final double y3 = y2 * y;
-                    final double[] pY = {1, y, y2, y3};
+                        final double y2 = y * y;
+                        final double y3 = y2 * y;
+                        final double[] pY = {1, y, y2, y3};
 
-                    return apply(pX, pY, aXX);
-                }
-            };
-        partialDerivativeYY = new BivariateFunction() {
-                public double value(double x, double y)  {
-                    final double x2 = x * x;
-                    final double x3 = x2 * x;
-                    final double[] pX = {1, x, x2, x3};
+                        return apply(pX, pY, aXX);
+                    }
+                };
+            partialDerivativeYY = new BivariateFunction() {
+                    public double value(double x, double y)  {
+                        final double x2 = x * x;
+                        final double x3 = x2 * x;
+                        final double[] pX = {1, x, x2, x3};
 
-                    final double[] pY = {0, 0, 1, y};
+                        final double[] pY = {0, 0, 1, y};
 
-                    return apply(pX, pY, aYY);
-                }
-            };
-        partialDerivativeXY = new BivariateFunction() {
-                public double value(double x, double y)  {
-                    final double x2 = x * x;
-                    final double[] pX = {0, 1, x, x2};
+                        return apply(pX, pY, aYY);
+                    }
+                };
+            partialDerivativeXY = new BivariateFunction() {
+                    public double value(double x, double y)  {
+                        final double x2 = x * x;
+                        final double[] pX = {0, 1, x, x2};
 
-                    final double y2 = y * y;
-                    final double[] pY = {0, 1, y, y2};
+                        final double y2 = y * y;
+                        final double[] pY = {0, 1, y, y2};
 
-                    return apply(pX, pY, aXY);
-                }
-            };
+                        return apply(pX, pY, aXY);
+                    }
+                };
+        } else {
+            partialDerivativeX = null;
+            partialDerivativeY = null;
+            partialDerivativeXX = null;
+            partialDerivativeYY = null;
+            partialDerivativeXY = null;
+        }
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.java b/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.java
index 9465c2cdca..58bb22ed8b 100644
--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.java
+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.java
@@ -32,6 +32,31 @@
  */
 public class BicubicSplineInterpolator
     implements BivariateGridInterpolator {
+    /** Whether to initialize internal data used to compute the analytical
+        derivatives of the splines. */
+    private final boolean initializeDerivatives;
+
+    /**
+     * Default constructor.
+     * The argument {@link #BicubicSplineInterpolator(boolean) initializeDerivatives}
+     * is set to {@code false}.
+     */
+    public BicubicSplineInterpolator() {
+        this(false);
+    }
+
+    /**
+     * Creates an interpolator.
+     *
+     * @param initializeDerivatives Whether to initialize the internal data
+     * needed for calling any of the methods that compute the partial derivatives
+     * of the {@link BicubicSplineInterpolatingFunction function} returned from
+     * the call to {@link #interpolate(double[],double[],double[][]) interpolate}.
+     */
+    public BicubicSplineInterpolator(boolean initializeDerivatives) {
+        this.initializeDerivatives = initializeDerivatives;
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -118,7 +143,8 @@ public BicubicSplineInterpolatingFunction interpolate(final double[] xval,
 
         // Create the interpolating splines
         return new BicubicSplineInterpolatingFunction(xval, yval, fval,
-                                                      dFdX, dFdY, d2FdXdY);
+                                                      dFdX, dFdY, d2FdXdY,
+                                                      initializeDerivatives);
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.java b/src/main/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.java
index 0fce8577a5..f08d6a9496 100644
--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.java
+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.java
@@ -77,7 +77,7 @@ public TricubicSplineInterpolatingFunction interpolate(final double[] xval,
             }
         }
 
-        final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator();
+        final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator(true);
 
         // For each line x[i] (0 <= i < xLen), construct a 2D spline in y and z
         final BicubicSplineInterpolatingFunction[] xSplineYZ
