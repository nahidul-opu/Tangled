From a1f4d43253ac11abe8cf3ed53876dabc885d7b30 Mon Sep 17 00:00:00 2001
From: Sebastian Bazley <sebb@apache.org>
Date: Mon, 22 Apr 2013 21:30:55 +0000
Subject: [PATCH] IO-379   CharSequenceInputStream - add tests for available() 
         Fix code so it really does reflect a minimum available.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/io/trunk@1470725 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  4 ++
 .../io/input/CharSequenceInputStream.java     | 12 ++++-
 .../io/input/CharSequenceInputStreamTest.java | 46 +++++++++++++++++++
 3 files changed, 61 insertions(+), 1 deletion(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index ae26875e0fb..4a72d142a75 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -47,6 +47,10 @@ The <action> type attribute can be add,update,fix,remove.
   <body>
     <!-- The release date is the date RC is cut -->
     <release version="2.5" date="2013-??-??" description="New features and bug fixes.">    
+      <action issue="IO-379" dev="sebb" type="add">
+         CharSequenceInputStream - add tests for available()
+         Fix code so it really does reflect a minimum available.
+      </action>
       <action issue="IO-328" dev="sebb" type="update">
         getPrefixLength returns null if filename has leading slashes
         Javadoc: add examples to show correct behaviour; add unit tests
diff --git a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
index a8f1cdc8912..006ba0e521f 100644
--- a/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
+++ b/src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java
@@ -187,9 +187,19 @@ public long skip(long n) throws IOException {
         return skipped;
     }
 
+    /**
+     * Return an estimate of the number of bytes remaining in the byte stream.
+     * @return the count of bytes that can be read without blocking (or returning EOF).
+     *
+     * @throws IOException if an error occurs (probably not possible)
+     */
     @Override
     public int available() throws IOException {
-        return this.cbuf.remaining();
+        // The cached entries are in bbuf; since encoding always creates at least one byte
+        // per character, we can add the two to get a better estimate (e.g. if bbuf is empty)
+        // Note that the previous implementation (2.4) could return zero even though there were
+        // encoded bytes still available.
+        return this.bbuf.remaining() + this.cbuf.remaining();
     }
 
     @Override
diff --git a/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java b/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
index e13bda65b8c..c73206128e7 100644
--- a/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
+++ b/src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java
@@ -379,4 +379,50 @@ public void testSkip_USASCII() throws Exception {
     public void testSkip_UTF8() throws Exception {
         testSkip("UTF-8");
     }
+    
+    private int checkAvail(InputStream is, int min) throws Exception {
+        int available = is.available();
+        assertTrue("avail should be >= " + min + ", but was " + available, available >= min);
+        return available;
+    }
+
+    private void testAvailableSkip(final String csName) throws Exception {
+        final String input = "test";
+        final InputStream r = new CharSequenceInputStream(input, csName);
+        try {
+            int available = checkAvail(r, input.length());
+            assertEquals(available - 1, r.skip(available-1)); // skip all but one
+            available = checkAvail(r, 1);
+            assertEquals(1, r.skip(1));
+            available = checkAvail(r, 0);
+        } finally {
+            r.close();
+        }
+    }
+
+    private void testAvailableRead(final String csName) throws Exception {
+        final String input = "test";
+        final InputStream r = new CharSequenceInputStream(input, csName);
+        try {
+            int available = checkAvail(r, input.length());
+            byte buff[] = new byte[available];
+            assertEquals(available - 1, r.skip(available-1)); // skip all but one
+            available = checkAvail(r, 1);
+            buff = new byte[available];
+            assertEquals(available, r.read(buff, 0, available));
+        } finally {
+            r.close();
+        }
+    }
+
+    @Test
+    public void testAvailable() throws Exception {
+        for (final String csName : Charset.availableCharsets().keySet()) {
+            // prevent java.lang.UnsupportedOperationException at sun.nio.cs.ext.ISO2022_CN.newEncoder. 
+            if (Charset.forName(csName).canEncode()) {
+                testAvailableSkip(csName);
+                testAvailableRead(csName);
+            }
+        }
+    }
 }
