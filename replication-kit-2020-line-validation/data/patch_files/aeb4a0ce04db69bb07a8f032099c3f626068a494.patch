From aeb4a0ce04db69bb07a8f032099c3f626068a494 Mon Sep 17 00:00:00 2001
From: Eli Reisman <ereisman@apache.org>
Date: Mon, 1 Oct 2012 21:45:57 +0000
Subject: [PATCH] GIRAPH-353: Received metrics are not thread-safe (aching via
 ereisman)

git-svn-id: https://svn.apache.org/repos/asf/giraph/trunk@1392645 13f79535-47bb-0310-9956-ffa450edef68
---
 CHANGELOG                                     |  1 +
 .../apache/giraph/comm/netty/ByteCounter.java | 31 +++++++++++++------
 2 files changed, 22 insertions(+), 10 deletions(-)

diff --git a/CHANGELOG b/CHANGELOG
index e4036ca7c..15c325c6f 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -1,6 +1,7 @@
 Giraph Change Log
 
 Release 0.2.0 - unreleased
+  GIRAPH-353: Received metrics are not thread-safe (aching via ereisman)
 
   GIRAPH-326: Writing input splits to ZooKeeper in parallel (maja)
 
diff --git a/src/main/java/org/apache/giraph/comm/netty/ByteCounter.java b/src/main/java/org/apache/giraph/comm/netty/ByteCounter.java
index dde21f50b..f228375a7 100644
--- a/src/main/java/org/apache/giraph/comm/netty/ByteCounter.java
+++ b/src/main/java/org/apache/giraph/comm/netty/ByteCounter.java
@@ -21,6 +21,8 @@
 import java.text.DecimalFormat;
 import java.util.concurrent.atomic.AtomicLong;
 import org.apache.log4j.Logger;
+import org.apache.giraph.utils.SystemTime;
+import org.apache.giraph.utils.Time;
 import org.jboss.netty.buffer.ChannelBuffer;
 import org.jboss.netty.channel.ChannelEvent;
 import org.jboss.netty.channel.ChannelHandlerContext;
@@ -40,6 +42,8 @@ public class ByteCounter extends SimpleChannelHandler {
   /** Class logger */
   private static final Logger LOG =
       Logger.getLogger(ByteCounter.class);
+  /** Class timer */
+  private static final Time TIME = SystemTime.getInstance();
   /** All bytes ever sent */
   private final AtomicLong bytesSent = new AtomicLong();
   /** Total sent requests */
@@ -49,8 +53,9 @@ public class ByteCounter extends SimpleChannelHandler {
   /** Total received requests */
   private final AtomicLong receivedRequests = new AtomicLong();
   /** Start time (for bandwidth calculation) */
-  private final AtomicLong startMsecs =
-      new AtomicLong(System.currentTimeMillis());
+  private final AtomicLong startMsecs = new AtomicLong(TIME.getMilliseconds());
+  /** Last updated msecs for getMetricsWindow */
+  private final AtomicLong metricsWindowLastUpdatedMsecs = new AtomicLong();
 
   @Override
   public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e)
@@ -100,7 +105,7 @@ private void resetBytes() {
    * Reset the start msecs.
    */
   private void resetStartMsecs() {
-    startMsecs.set(System.currentTimeMillis());
+    startMsecs.set(TIME.getMilliseconds());
   }
 
   /**
@@ -124,7 +129,7 @@ public long getBytesReceived() {
    */
   public double getMbytesPerSecSent() {
     return bytesSent.get() * 1000f /
-        (1 + System.currentTimeMillis() - startMsecs.get()) / MEGABYTE;
+        (1 + TIME.getMilliseconds() - startMsecs.get()) / MEGABYTE;
   }
 
   /**
@@ -132,7 +137,7 @@ public double getMbytesPerSecSent() {
    */
   public double getMbytesPerSecReceived() {
     return bytesReceived.get() * 1000f /
-        (1 + System.currentTimeMillis() - startMsecs.get()) / MEGABYTE;
+        (1 + TIME.getMilliseconds() - startMsecs.get()) / MEGABYTE;
   }
 
   /**
@@ -158,7 +163,7 @@ public String getMetrics() {
         ", ave received req MBytes = " +
         DOUBLE_FORMAT.format(mBytesReceivedPerReq) +
         ", secs waited = " +
-        ((System.currentTimeMillis() - startMsecs.get()) / 1000f);
+        ((TIME.getMilliseconds() - startMsecs.get()) / 1000f);
   }
 
   /**
@@ -169,10 +174,16 @@ public String getMetrics() {
    * @return Metrics or else null if the window wasn't met
    */
   public String getMetricsWindow(int minMsecsWindow) {
-    if (System.currentTimeMillis() - startMsecs.get() > minMsecsWindow) {
-      String metrics = getMetrics();
-      resetAll();
-      return metrics;
+    long lastUpdatedMsecs =  metricsWindowLastUpdatedMsecs.get();
+    long curMsecs = TIME.getMilliseconds();
+    if (curMsecs - lastUpdatedMsecs > minMsecsWindow) {
+      // Make sure that only one thread does this update
+      if (metricsWindowLastUpdatedMsecs.compareAndSet(lastUpdatedMsecs,
+          curMsecs)) {
+        String metrics = getMetrics();
+        resetAll();
+        return metrics;
+      }
     }
 
     return null;
