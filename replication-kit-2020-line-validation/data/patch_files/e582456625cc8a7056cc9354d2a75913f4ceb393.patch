From e582456625cc8a7056cc9354d2a75913f4ceb393 Mon Sep 17 00:00:00 2001
From: Sebastian Bazley <sebb@apache.org>
Date: Tue, 25 Sep 2012 22:12:14 +0000
Subject: [PATCH] LANG-828 FastDateParser does not handle non-Gregorian
 calendars properly Fix bug in Java 7 (Locale.toString() format has changed)

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1390189 13f79535-47bb-0310-9956-ffa450edef68
---
 .../org/apache/commons/lang3/time/FastDateParser.java  | 10 +++++++---
 .../apache/commons/lang3/time/FastDateParserTest.java  |  4 ++--
 2 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
index 1776164e315..3f8d5c96d4c 100644
--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
@@ -75,7 +75,9 @@ public class FastDateParser implements DateParser, Serializable {
     
     private static final ConcurrentMap<Locale,TimeZoneStrategy> tzsCache= 
         new ConcurrentHashMap<Locale,TimeZoneStrategy>(3);
-    
+
+    static final Locale JAPANESE_IMPERIAL = new Locale("ja","JP","JP");
+
     // defining fields
     private final String pattern;
     private final TimeZone timeZone;
@@ -123,10 +125,12 @@ private void init() {
             throw new IllegalArgumentException("Invalid pattern");
         }
 
-        String localeName = locale.toString();
         // These locales don't use the Gregorian calendar
         // See http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html
-        if (localeName.equals("ja_JP_JP") || localeName.startsWith("th_TH")) {
+        // Also, the getEras() methods don't return the correct era names.
+        // N.B. Not safe to use toString() comparison because that changes between Java versions
+        if (locale.equals(JAPANESE_IMPERIAL)
+        || (locale.getLanguage().equals("th") && locale.getCountry().equals("TH"))) {
             collector.add(new SimpleDateFormatStrategy());
             strategies= collector.toArray(new Strategy[collector.size()]);
             parsePattern= Pattern.compile("(.*+)");
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
index 75240857db9..da2cfc8b324 100644
--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
@@ -200,7 +200,7 @@ public void testParses() throws Exception {
                 Calendar cal = Calendar.getInstance(tz);
                 for(int year : new int[]{2003, 1940, 1868, 1867, 0, -1940}) {
                     // http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html
-                    if (year < 1868 && locale.toString().equals("ja_JP_JP")) {
+                    if (year < 1868 && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {
                         continue; // Japanese imperial calendar does not support eras before 1868
                     }
                     cal.clear();
@@ -363,7 +363,7 @@ private void testLocales(String format, boolean eraBC) throws Exception {
         boolean failed = false;
         for(Locale locale : Locale.getAvailableLocales()) {
             // ja_JP_JP cannot handle dates before 1868 properly
-            if (eraBC && format.equals(SHORT_FORMAT) && locale.toString().equals("ja_JP_JP")) {
+            if (eraBC && format.equals(SHORT_FORMAT) && locale.equals(FastDateParser.JAPANESE_IMPERIAL)) {
                 continue;
             }
             SimpleDateFormat sdf = new SimpleDateFormat(format, locale);
