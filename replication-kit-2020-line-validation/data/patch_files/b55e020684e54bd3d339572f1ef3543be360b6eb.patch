From b55e020684e54bd3d339572f1ef3543be360b6eb Mon Sep 17 00:00:00 2001
From: Gilles Sadowski <erans@apache.org>
Date: Fri, 21 Sep 2012 15:32:18 +0000
Subject: [PATCH] MATH-865 Early detection that overflow will occur in the
 variables normalization procedure ("encode" method). Warning mentioned in the
 documentation.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1388552 13f79535-47bb-0310-9956-ffa450edef68
---
 .../optimization/direct/CMAESOptimizer.java   | 23 ++++++++++++-
 .../direct/CMAESOptimizerTest.java            | 32 ++++++++++++++++++-
 2 files changed, 53 insertions(+), 2 deletions(-)

diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
index b54cb37445..f6a4f2820a 100644
--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
@@ -24,8 +24,8 @@
 import org.apache.commons.math3.analysis.MultivariateFunction;
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.MathUnsupportedOperationException;
-import org.apache.commons.math3.exception.MathIllegalStateException;
 import org.apache.commons.math3.exception.NotPositiveException;
+import org.apache.commons.math3.exception.NumberIsTooLargeException;
 import org.apache.commons.math3.exception.OutOfRangeException;
 import org.apache.commons.math3.exception.TooManyEvaluationsException;
 import org.apache.commons.math3.exception.util.LocalizedFormats;
@@ -78,6 +78,12 @@
  *  <li><a href="http://en.wikipedia.org/wiki/CMA-ES">Wikipedia</a></li>
  * </ul>
  *
+ * When simple constraints (boundaries) are used, care must be taken that the
+ * difference between the upper and lower bounds does not overflow; should it
+ * be the case, a {@link NumberIsTooLargeException} will be thrown by the
+ * {@link BaseAbstractMultivariateSimpleBoundsOptimizer#optimize(int,
+ * MultivariateFunction,GoalType,double[],double[],double[]) optimize} method.
+ *
  * @version $Id$
  * @since 3.0
  */
@@ -529,6 +535,21 @@ private void checkParameters() {
                 boundaries = new double[2][];
                 boundaries[0] = lB;
                 boundaries[1] = uB;
+
+                // Abort early if the normalization will overflow (cf. "encode" method).
+                for (int i = 0; i < lB.length; i++) {
+                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {
+                        final double max = Double.MAX_VALUE + boundaries[0][i];
+                        final NumberIsTooLargeException e
+                            = new NumberIsTooLargeException(boundaries[1][i],
+                                                            max,
+                                                            true);
+                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);
+                        e.getContext().addMessage(LocalizedFormats.INDEX, i);
+
+                        throw e;
+                    }
+                }
             }
         } else {
             // Convert API to internal handling of boundaries.
diff --git a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java
index 38818798ca..c17f72d16e 100644
--- a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java
@@ -26,11 +26,13 @@
 import org.apache.commons.math3.exception.NumberIsTooSmallException;
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.MathUnsupportedOperationException;
+import org.apache.commons.math3.exception.MathIllegalStateException;
 import org.apache.commons.math3.exception.NotPositiveException;
 import org.apache.commons.math3.exception.OutOfRangeException;
 import org.apache.commons.math3.optimization.GoalType;
 import org.apache.commons.math3.optimization.PointValuePair;
 import org.apache.commons.math3.random.MersenneTwister;
+import org.apache.commons.math3.util.FastMath;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -376,7 +378,6 @@ public void testDiagonalRosen() {
     public void testMath864() {
         final CMAESOptimizer optimizer = new CMAESOptimizer();
         final MultivariateFunction fitnessFunction = new MultivariateFunction() {
-                @Override
                 public double value(double[] parameters) {
                     final double target = 1;
                     final double error = target - parameters[0];
@@ -393,6 +394,35 @@ public double value(double[] parameters) {
                           result[0] <= upper[0]);
     }
 
+    /**
+     * Cf. MATH-865
+     */
+    @Test(expected=NumberIsTooLargeException.class)
+    public void testBoundaryRangeTooLarge() {
+        final CMAESOptimizer optimizer = new CMAESOptimizer();
+        final MultivariateFunction fitnessFunction = new MultivariateFunction() {
+                public double value(double[] parameters) {
+                    if (Double.isNaN(parameters[0])) {
+                        throw new MathIllegalStateException();
+                    }
+                    final double target = 1;
+                    final double error = target - parameters[0];
+                    return error * error;
+                }
+            };
+
+        final double[] start = { 0 };
+
+        // The difference between upper and lower bounds is used to used
+        // normalize the variables: In case of overflow, NaN is produced.
+        final double max = Double.MAX_VALUE / 2;
+        final double tooLarge = FastMath.nextUp(max);
+        final double[] lower = { -tooLarge };
+        final double[] upper = { tooLarge };
+        final double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,
+                                                   start, lower, upper).getPoint();
+    }
+
     /**
      * @param func Function to optimize.
      * @param startPoint Starting point.
