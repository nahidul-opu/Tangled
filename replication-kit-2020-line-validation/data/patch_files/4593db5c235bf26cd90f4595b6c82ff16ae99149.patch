From 4593db5c235bf26cd90f4595b6c82ff16ae99149 Mon Sep 17 00:00:00 2001
From: Sebastian Bazley <sebb@apache.org>
Date: Wed, 29 Feb 2012 01:07:22 +0000
Subject: [PATCH] NET-444 FTPTimestampParserImpl fails to parse future dates
 correctly on Feb 28th in a leap year

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/net/trunk@1294922 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  7 ++
 .../ftp/parser/FTPTimestampParserImpl.java    | 77 ++++++++-----------
 .../parser/FTPTimestampParserImplTest.java    | 23 +++++-
 3 files changed, 62 insertions(+), 45 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 70bf38d56..fea42b977 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -62,6 +62,13 @@ The <action> type attribute can be add,update,fix,remove.
      -->
 
     <body>
+        <release version="3.2" date="TBA" description="
+        ">
+TBA
+            <action issue="NET-444" dev="sebb" type="fix">
+            FTPTimestampParserImpl fails to parse future dates correctly on Feb 28th in a leap year.
+            </action>
+        </release>
         <release version="3.1" date="Feb 20, 2012" description="
 This release fixes a few bugs and adds some new functionality (see below).
   It is binary compatible with previous releases
diff --git a/src/main/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java b/src/main/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
index a2fd6c2d6..d9c9d47ed 100644
--- a/src/main/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
+++ b/src/main/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
@@ -90,67 +90,58 @@ public Calendar parseTimestamp(String timestampStr) throws ParseException {
      * @since 1.5
      */
     public Calendar parseTimestamp(String timestampStr, Calendar serverTime) throws ParseException {
-        Calendar now = (Calendar) serverTime.clone();// Copy this, because we may change it
-        now.setTimeZone(this.getServerTimeZone());
-        Calendar working = (Calendar) now.clone();
+        Calendar working = (Calendar) serverTime.clone();
         working.setTimeZone(getServerTimeZone()); // is this needed?
-        ParsePosition pp = new ParsePosition(0);
 
         Date parsed = null;
+
         if (recentDateFormat != null) {
+            Calendar now = (Calendar) serverTime.clone();// Copy this, because we may change it
+            now.setTimeZone(this.getServerTimeZone());
             if (lenientFutureDates) {
                 // add a day to "now" so that "slop" doesn't cause a date
                 // slightly in the future to roll back a full year.  (Bug 35181 => NET-83)
                 now.add(Calendar.DATE, 1);
             }
-            parsed = recentDateFormat.parse(timestampStr, pp);
-        }
-        if (parsed != null && pp.getIndex() == timestampStr.length())
-        {
-            working.setTime(parsed);
-            working.set(Calendar.YEAR, now.get(Calendar.YEAR));
-
-            if (working.after(now)) {
-                working.add(Calendar.YEAR, -1);
-            }
-        } else {
             // Temporarily add the current year to the short date time
             // to cope with short-date leap year strings.
             // e.g. Java's DateFormatter will assume that "Feb 29 12:00" refers to
             // Feb 29 1970 (an invalid date) rather than a potentially valid leap year date.
             // This is pretty bad hack to work around the deficiencies of the JDK date/time classes.
-            if (recentDateFormat != null) {
-                pp = new ParsePosition(0);
-                int year = now.get(Calendar.YEAR);
-                String timeStampStrPlusYear = timestampStr + " " + year;
-                SimpleDateFormat hackFormatter = new SimpleDateFormat(recentDateFormat.toPattern() + " yyyy",
-                        recentDateFormat.getDateFormatSymbols());
-                hackFormatter.setLenient(false);
-                hackFormatter.setTimeZone(recentDateFormat.getTimeZone());
-                parsed = hackFormatter.parse(timeStampStrPlusYear, pp);
-            }
-            if (parsed != null && pp.getIndex() == timestampStr.length() + 5) {
+            String year = Integer.toString(now.get(Calendar.YEAR));
+            String timeStampStrPlusYear = timestampStr + " " + year;
+            SimpleDateFormat hackFormatter = new SimpleDateFormat(recentDateFormat.toPattern() + " yyyy",
+                    recentDateFormat.getDateFormatSymbols());
+            hackFormatter.setLenient(false);
+            hackFormatter.setTimeZone(recentDateFormat.getTimeZone());
+            ParsePosition pp = new ParsePosition(0);
+            parsed = hackFormatter.parse(timeStampStrPlusYear, pp);
+            // Check if we parsed the full string, if so it must have been a short date originally
+            if (parsed != null && pp.getIndex() == timeStampStrPlusYear.length()) {
                 working.setTime(parsed);
-            }
-            else {
-                pp = new ParsePosition(0);
-                parsed = defaultDateFormat.parse(timestampStr, pp);
-                // note, length checks are mandatory for us since
-                // SimpleDateFormat methods will succeed if less than
-                // full string is matched.  They will also accept,
-                // despite "leniency" setting, a two-digit number as
-                // a valid year (e.g. 22:04 will parse as 22 A.D.)
-                // so could mistakenly confuse an hour with a year,
-                // if we don't insist on full length parsing.
-                if (parsed != null && pp.getIndex() == timestampStr.length()) {
-                    working.setTime(parsed);
-                } else {
-                    throw new ParseException(
-                            "Timestamp could not be parsed with older or recent DateFormat",
-                            pp.getErrorIndex());
+                if (working.after(now)) { // must have been last year instead
+                    working.add(Calendar.YEAR, -1);
                 }
+                return working;
             }
         }
+
+        ParsePosition pp = new ParsePosition(0);
+        parsed = defaultDateFormat.parse(timestampStr, pp);
+        // note, length checks are mandatory for us since
+        // SimpleDateFormat methods will succeed if less than
+        // full string is matched.  They will also accept,
+        // despite "leniency" setting, a two-digit number as
+        // a valid year (e.g. 22:04 will parse as 22 A.D.)
+        // so could mistakenly confuse an hour with a year,
+        // if we don't insist on full length parsing.
+        if (parsed != null && pp.getIndex() == timestampStr.length()) {
+            working.setTime(parsed);
+        } else {
+            throw new ParseException(
+                    "Timestamp could not be parsed with older or recent DateFormat",
+                    pp.getErrorIndex());
+        }
         return working;
     }
 
diff --git a/src/test/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImplTest.java b/src/test/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImplTest.java
index 090a3d609..87cf7b52f 100644
--- a/src/test/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImplTest.java
+++ b/src/test/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImplTest.java
@@ -97,6 +97,25 @@ public void testParseTimestampWithSlop() {
         }
     }
 
+    public void testNET444() throws Exception {
+        FTPTimestampParserImpl parser = new FTPTimestampParserImpl();
+        parser.setLenientFutureDates(true);
+        SimpleDateFormat sdf = new SimpleDateFormat(parser.getRecentDateFormatString());
+        GregorianCalendar now = new GregorianCalendar(2012, Calendar.FEBRUARY, 28, 12, 0);
+
+        GregorianCalendar nowplus1 = new GregorianCalendar(2012, Calendar.FEBRUARY, 28, 13, 0);
+        // Create a suitable short date
+        String future1 = sdf.format(nowplus1.getTime());
+        Calendar parsed1 = parser.parseTimestamp(future1, now);
+        assertEquals(nowplus1.get(Calendar.YEAR), parsed1.get(Calendar.YEAR));
+
+        GregorianCalendar nowplus25 = new GregorianCalendar(2012, Calendar.FEBRUARY, 29, 13, 0);
+        // Create a suitable short date
+        String future25 = sdf.format(nowplus25.getTime());
+        Calendar parsed25 = parser.parseTimestamp(future25, now);
+        assertEquals(nowplus25.get(Calendar.YEAR) - 1, parsed25.get(Calendar.YEAR));
+    }
+
     public void testParseTimestampAcrossTimeZones() {
 
 
@@ -174,8 +193,8 @@ public void testParser() {
                 fail("failed.to.parse.default");
             }
             try {
-                parser.parseTimestamp("f\u00e9v 22 2002");
-                fail("should.have.failed.to.parse.default");
+                Calendar c = parser.parseTimestamp("f\u00e9v 22 2002");
+                fail("should.have.failed.to.parse.default, but was: "+c.getTime().toString());
             } catch (ParseException e) {
                 // this is the success case
             }
