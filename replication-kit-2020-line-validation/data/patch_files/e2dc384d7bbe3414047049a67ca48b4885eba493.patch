From e2dc384d7bbe3414047049a67ca48b4885eba493 Mon Sep 17 00:00:00 2001
From: Luc Maisonobe <luc@apache.org>
Date: Sun, 2 Mar 2014 14:02:50 +0000
Subject: [PATCH] Fix switched iterations and evaluations

In LevenbergMarquardtOptimizer the number of iterations and evaluations
was switched in two of the return statements.

Patch provided by Evan Ward.

JIRA: MATH-1106

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1573308 13f79535-47bb-0310-9956-ffa450edef68
---
 .../LevenbergMarquardtOptimizer.java          |  4 +--
 .../LevenbergMarquardtOptimizerTest.java      | 25 +++++++++++++++++++
 2 files changed, 27 insertions(+), 2 deletions(-)

diff --git a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java
index 5f0527c33e..864faae3eb 100644
--- a/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizer.java
@@ -506,7 +506,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {
 
                     // tests for convergence.
                     if (checker != null && checker.converged(iterationCounter.getCount(), previous, current)) {
-                        return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
+                        return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());
                     }
                 } else {
                     // failed iteration, reset the previous values
@@ -527,7 +527,7 @@ public Optimum optimize(final LeastSquaresProblem problem) {
                      preRed <= costRelativeTolerance &&
                      ratio <= 2.0) ||
                     delta <= parRelativeTolerance * xNorm) {
-                    return new OptimumImpl(current, iterationCounter.getCount(), evaluationCounter.getCount());
+                    return new OptimumImpl(current, evaluationCounter.getCount(), iterationCounter.getCount());
                 }
 
                 // tests for termination and stringent tolerances
diff --git a/src/test/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java b/src/test/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java
index 055d720cc2..e0d7629445 100644
--- a/src/test/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/fitting/leastsquares/LevenbergMarquardtOptimizerTest.java
@@ -22,11 +22,13 @@
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.TooManyEvaluationsException;
 import org.apache.commons.math3.fitting.leastsquares.LeastSquaresOptimizer.Optimum;
+import org.apache.commons.math3.fitting.leastsquares.LeastSquaresProblem.Evaluation;
 import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
 import org.apache.commons.math3.linear.DiagonalMatrix;
 import org.apache.commons.math3.linear.RealMatrix;
 import org.apache.commons.math3.linear.RealVector;
 import org.apache.commons.math3.linear.SingularMatrixException;
+import org.apache.commons.math3.optim.ConvergenceChecker;
 import org.apache.commons.math3.util.FastMath;
 import org.apache.commons.math3.util.Precision;
 import org.junit.Assert;
@@ -35,6 +37,8 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import static org.hamcrest.CoreMatchers.is;
+
 /**
  * <p>Some of the unit tests are re-implementations of the MINPACK <a
  * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a
@@ -264,6 +268,27 @@ public void testCircleFitting2() {
         Assert.assertEquals(radius, paramFound[2], asymptoticStandardErrorFound[2]);
     }
 
+    @Test
+    public void testEvaluationCount() {
+        //setup
+        LeastSquaresProblem lsp = new LinearProblem(new double[][] {{1}}, new double[] {1})
+                .getBuilder()
+                .checker(new ConvergenceChecker<Evaluation>() {
+                    public boolean converged(int iteration, Evaluation previous, Evaluation current) {
+                        return true;
+                    }
+                })
+                .build();
+
+        //action
+        Optimum optimum = optimizer.optimize(lsp);
+
+        //verify
+        //check iterations and evaluations are not switched.
+        Assert.assertThat(optimum.getIterations(), is(1));
+        Assert.assertThat(optimum.getEvaluations(), is(2));
+    }
+
     //TODO delete or use
     private static class QuadraticProblem {
         private List<Double> x;
