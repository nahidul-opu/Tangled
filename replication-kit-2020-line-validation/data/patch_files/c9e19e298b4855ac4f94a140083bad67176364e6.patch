From c9e19e298b4855ac4f94a140083bad67176364e6 Mon Sep 17 00:00:00 2001
From: Maarten Coene <maartenc@apache.org>
Date: Sun, 24 May 2009 22:30:29 +0000
Subject: [PATCH] FIX: Ibiblio resolver throws IndexOutOfBoundsException when
 using snapshot versions with usepoms='false' (IVY-1028)

git-svn-id: https://svn.apache.org/repos/asf/ant/ivy/core/trunk@778247 13f79535-47bb-0310-9956-ffa450edef68
---
 CHANGES.txt                                   |  1 +
 .../ivy/plugins/resolver/IBiblioResolver.java | 71 +++++++++----------
 2 files changed, 33 insertions(+), 39 deletions(-)

diff --git a/CHANGES.txt b/CHANGES.txt
index 32470967f..ffd259905 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -87,6 +87,7 @@ for detailed view of each issue, please consult http://issues.apache.org/jira/br
 	
    trunk
 =====================================
+- FIX: Ibiblio resolver throws IndexOutOfBoundsException when using snapshot versions with usepoms='false' (IVY-1028)
 - FIX: Wrong BuildException messages (findmodules) (IVY-1056)
 - FIX: PomModuleDescriptorBuilder does not resolve ejb type dependencies to jar extension (IVY-1058) (thanks to Andrey Lomakin)
 - FIX: Ivy doesn't handle maven dependencies with type 'test-jar' correctly (IVY-1066)
diff --git a/src/java/org/apache/ivy/plugins/resolver/IBiblioResolver.java b/src/java/org/apache/ivy/plugins/resolver/IBiblioResolver.java
index e8b461bbe..455140bb1 100644
--- a/src/java/org/apache/ivy/plugins/resolver/IBiblioResolver.java
+++ b/src/java/org/apache/ivy/plugins/resolver/IBiblioResolver.java
@@ -130,8 +130,7 @@ private ResolvedResource findSnapshotArtifact(Artifact artifact, Date date,
         String rev = findSnapshotVersion(mrid);
         if (rev != null) {
             // replace the revision token in file name with the resolved revision
-            String pattern = (String) getArtifactPatterns().get(0);
-            pattern = pattern.replaceFirst("\\-\\[revision\\]", "-" + rev);
+            String pattern = getWholePattern().replaceFirst("\\-\\[revision\\]", "-" + rev);
             return findResourceUsingPattern(mrid, pattern, artifact,
                 getDefaultRMDParser(artifact.getModuleRevisionId().getModuleId()), date);
         }
@@ -148,8 +147,7 @@ private ResolvedResource findSnapshotDescriptor(DependencyDescriptor dd, Resolve
             Message.verbose("[" + rev + "] " + mrid);
 
             // replace the revision token in file name with the resolved revision
-            String pattern = (String) getIvyPatterns().get(0);
-            pattern = pattern.replaceFirst("\\-\\[revision\\]", "-" + rev);
+            String pattern = getWholePattern().replaceFirst("\\-\\[revision\\]", "-" + rev);
             return findResourceUsingPattern(mrid, pattern,
                 DefaultArtifact.newPomArtifact(
                     mrid, data.getDate()), getRMDParser(dd, data), data.getDate());
@@ -162,8 +160,7 @@ private String findSnapshotVersion(ModuleRevisionId mrid) {
             return null;
         }
         
-        String pattern = (String) getIvyPatterns().get(0);
-        if (shouldUseMavenMetadata(pattern)) {
+        if (shouldUseMavenMetadata(getWholePattern())) {
             InputStream metadataStream = null;
             try {
                 String metadataLocation = IvyPatternHelper.substitute(
@@ -337,40 +334,37 @@ protected String[] listTokenValues(String pattern, String token) {
         
         // let's see if we should use maven metadata for this listing...
         if (IvyPatternHelper.REVISION_KEY.equals(token) 
-                && isM2compatible()
-                && isUseMavenMetadata()) {
-            if (((String) getIvyPatterns().get(0)).endsWith(M2_PER_MODULE_PATTERN)) {
-                // now we must use metadata if available
+                && shouldUseMavenMetadata(getWholePattern())) {
+            // now we must use metadata if available
+            /*
+             * we substitute tokens with ext token only in the m2 per module pattern, to match
+             * has has been done in the given pattern
+             */
+            String partiallyResolvedM2PerModulePattern = IvyPatternHelper.substituteTokens(
+                M2_PER_MODULE_PATTERN, 
+                Collections.singletonMap(IvyPatternHelper.EXT_KEY, "pom"));
+            if (pattern.endsWith(partiallyResolvedM2PerModulePattern)) {
                 /*
-                 * we substitute tokens with ext token only in the m2 per module pattern, to match
-                 * has has been done in the given pattern
+                 * the given pattern already contain resolved org and module, we just have to
+                 * replace the per module pattern at the end by 'maven-metadata.xml' to have the
+                 * maven metadata file location
                  */
-                String partiallyResolvedM2PerModulePattern = IvyPatternHelper.substituteTokens(
-                    M2_PER_MODULE_PATTERN, 
-                    Collections.singletonMap(IvyPatternHelper.EXT_KEY, "pom"));
-                if (pattern.endsWith(partiallyResolvedM2PerModulePattern)) {
-                    /*
-                     * the given pattern already contain resolved org and module, we just have to
-                     * replace the per module pattern at the end by 'maven-metadata.xml' to have the
-                     * maven metadata file location
-                     */
-                    String metadataLocation = pattern.substring(0, pattern
-                        .lastIndexOf(partiallyResolvedM2PerModulePattern))
-                        + "maven-metadata.xml";
-                    List revs = listRevisionsWithMavenMetadata(getRepository(), metadataLocation);
-                    if (revs != null) {
-                        return (String[]) revs.toArray(new String[revs.size()]);
-                    }
-                } else {
-                    /*
-                     * this is probably because the given pattern has been substituted with jar ext,
-                     * if this resolver has optional module descriptors. But since we have to use
-                     * maven metadata, we don't care about this case, maven metadata has already
-                     * been used when looking for revisions with the pattern substituted with
-                     * ext=xml for the "ivy" pattern.
-                     */  
-                    return new String[0];
+                String metadataLocation = pattern.substring(0, pattern
+                    .lastIndexOf(partiallyResolvedM2PerModulePattern))
+                    + "maven-metadata.xml";
+                List revs = listRevisionsWithMavenMetadata(getRepository(), metadataLocation);
+                if (revs != null) {
+                    return (String[]) revs.toArray(new String[revs.size()]);
                 }
+            } else {
+                /*
+                 * this is probably because the given pattern has been substituted with jar ext,
+                 * if this resolver has optional module descriptors. But since we have to use
+                 * maven metadata, we don't care about this case, maven metadata has already
+                 * been used when looking for revisions with the pattern substituted with
+                 * ext=xml for the "ivy" pattern.
+                 */  
+                return new String[0];
             }
         }
         return super.listTokenValues(pattern, token);
@@ -478,8 +472,7 @@ public void endElement(String uri, String localName, String qName)
     
     protected void findTokenValues(Collection names, List patterns, Map tokenValues, String token) {
         if (IvyPatternHelper.REVISION_KEY.equals(token)) {
-            String pattern = (String) patterns.get(0);
-            if (shouldUseMavenMetadata(pattern)) {
+            if (shouldUseMavenMetadata(getWholePattern())) {
                 List revs = listRevisionsWithMavenMetadata(getRepository(), tokenValues);
                 if (revs != null) {
                     names.addAll(filterNames(revs));
