From 80008f4ccbc6feeaf5160a3f3042f71f5da4c09e Mon Sep 17 00:00:00 2001
From: Henri Yandell <bayard@apache.org>
Date: Fri, 18 May 2007 23:44:30 +0000
Subject: [PATCH] Applying Hiroshi's test from IO-117 with my fix. Fixes
 negative number possibilities in EndianUtils.readSwappedUnsignedInteger()

git-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/io/branches/b1_3@539638 13f79535-47bb-0310-9956-ffa450edef68
---
 .../org/apache/commons/io/EndianUtils.java    | 22 ++++++++++++-------
 .../apache/commons/io/EndianUtilsTest.java    | 13 +++++++++++
 2 files changed, 27 insertions(+), 8 deletions(-)

diff --git a/src/java/org/apache/commons/io/EndianUtils.java b/src/java/org/apache/commons/io/EndianUtils.java
index 1b838368b19..bb41bca597c 100644
--- a/src/java/org/apache/commons/io/EndianUtils.java
+++ b/src/java/org/apache/commons/io/EndianUtils.java
@@ -182,10 +182,13 @@ public static int readSwappedInteger(byte[] data, int offset) {
      * @return the value read
      */
     public static long readSwappedUnsignedInteger(byte[] data, int offset) {
-        return ( ( ( data[ offset + 0 ] & 0xff ) << 0 ) +
-            ( ( data[ offset + 1 ] & 0xff ) << 8 ) +
-            ( ( data[ offset + 2 ] & 0xff ) << 16 ) +
-            ( ( data[ offset + 3 ] & 0xff ) << 24 ) );
+        long low = ( ( ( data[ offset + 0 ] & 0xff ) << 0 ) +
+                     ( ( data[ offset + 1 ] & 0xff ) << 8 ) +
+                     ( ( data[ offset + 2 ] & 0xff ) << 16 ) );
+
+        long high = data[ offset + 3 ] & 0xff;
+
+        return (high << 24) + (0xffffffffL & low); 
     }
 
     /**
@@ -368,10 +371,13 @@ public static long readSwappedUnsignedInteger(InputStream input)
         int value3 = read( input );
         int value4 = read( input );
 
-        return ( ( value1 & 0xff ) << 0 ) +
-            ( ( value2 & 0xff ) << 8 ) +
-            ( ( value3 & 0xff ) << 16 ) +
-            ( ( value4 & 0xff ) << 24 );
+        long low = ( ( ( value1 & 0xff ) << 0 ) +
+                     ( ( value2 & 0xff ) << 8 ) +
+                     ( ( value3 & 0xff ) << 16 ) );
+
+        long high = value4 & 0xff;
+
+        return (high << 24) + (0xffffffffL & low); 
     }
 
     /**
diff --git a/src/test/org/apache/commons/io/EndianUtilsTest.java b/src/test/org/apache/commons/io/EndianUtilsTest.java
index f2891eff12c..f2ff2564bfc 100755
--- a/src/test/org/apache/commons/io/EndianUtilsTest.java
+++ b/src/test/org/apache/commons/io/EndianUtilsTest.java
@@ -263,4 +263,17 @@ public void testSymmetryOfLong() throws IOException {
         }
     }
 
+    // tests #IO-117
+    public void testUnsignedOverrun() throws Exception {
+        byte[] target = new byte[] { 0, 0, 0, (byte)0x80 };
+        long expected = 0x80000000L;
+    
+        long actual = EndianUtils.readSwappedUnsignedInteger(target, 0);
+        assertEquals("readSwappedUnsignedInteger(byte[], int) was incorrect", expected, actual);
+
+        ByteArrayInputStream in = new ByteArrayInputStream(target);
+        actual = EndianUtils.readSwappedUnsignedInteger(in);
+        assertEquals("readSwappedUnsignedInteger(InputStream) was incorrect", expected, actual);
+    }
+
 }
