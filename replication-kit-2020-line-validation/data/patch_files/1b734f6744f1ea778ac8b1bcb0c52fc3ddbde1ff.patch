From 1b734f6744f1ea778ac8b1bcb0c52fc3ddbde1ff Mon Sep 17 00:00:00 2001
From: Oliver Heger <oheger@apache.org>
Date: Tue, 29 Apr 2014 20:34:31 +0000
Subject: [PATCH] [CONFIGURATION-573] ConfigurationNodeIteratorChildren now
 supports qualified names.

Namespace prefixes are now handled when iterating over a node's children.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/configuration/trunk@1591090 13f79535-47bb-0310-9956-ffa450edef68
---
 .../ConfigurationNodeIteratorChildren.java    | 101 ++++++++++++++----
 ...TestConfigurationNodeIteratorChildren.java |  78 +++++++++++++-
 2 files changed, 154 insertions(+), 25 deletions(-)

diff --git a/src/main/java/org/apache/commons/configuration/tree/xpath/ConfigurationNodeIteratorChildren.java b/src/main/java/org/apache/commons/configuration/tree/xpath/ConfigurationNodeIteratorChildren.java
index e1a50b1b88..926ee1a2d6 100644
--- a/src/main/java/org/apache/commons/configuration/tree/xpath/ConfigurationNodeIteratorChildren.java
+++ b/src/main/java/org/apache/commons/configuration/tree/xpath/ConfigurationNodeIteratorChildren.java
@@ -38,6 +38,12 @@
 class ConfigurationNodeIteratorChildren<T> extends
         ConfigurationNodeIteratorBase<T>
 {
+    /** Constant for the prefix separator. */
+    private static final String PREFIX_SEPARATOR = ":";
+
+    /** A format for constructing a node name with a namespace prefix. */
+    private static final String FMT_NAMESPACE = "%s" + PREFIX_SEPARATOR + "%s";
+
     /** The list with the sub nodes to iterate over. */
     private final List<T> subNodes;
 
@@ -108,11 +114,9 @@ protected int size()
      */
     private List<T> createSubNodeList(T node, NodeTest test)
     {
-        List<T> children = getNodeHandler().getChildren(node);
-
         if (test == null)
         {
-            return children;
+            return getNodeHandler().getChildren(node);
         }
         else
         {
@@ -120,24 +124,8 @@ private List<T> createSubNodeList(T node, NodeTest test)
             {
                 NodeNameTest nameTest = (NodeNameTest) test;
                 QName name = nameTest.getNodeName();
-                if (name.getPrefix() == null)
-                {
-                    if (nameTest.isWildcard())
-                    {
-                        return children;
-                    }
-
-                    List<T> result = new ArrayList<T>();
-                    for (T child : children)
-                    {
-                        if (StringUtils.equals(name.getName(), getNodeHandler()
-                                .nodeName(child)))
-                        {
-                            result.add(child);
-                        }
-                    }
-                    return result;
-                }
+                return nameTest.isWildcard() ? createSubNodeListForWildcardName(
+                        node, name) : createSubNodeListForName(node, name);
             }
 
             else if (test instanceof NodeTypeTest)
@@ -146,7 +134,7 @@ else if (test instanceof NodeTypeTest)
                 if (typeTest.getNodeType() == Compiler.NODE_TYPE_NODE
                         || typeTest.getNodeType() == Compiler.NODE_TYPE_TEXT)
                 {
-                    return children;
+                    return getNodeHandler().getChildren(node);
                 }
             }
         }
@@ -154,6 +142,62 @@ else if (test instanceof NodeTypeTest)
         return Collections.emptyList();
     }
 
+    /**
+     * Obtains the list of selected nodes for a {@code NodeNameTest} with either
+     * a simple or a qualified name.
+     *
+     * @param node the current node
+     * @param name the name to be selected
+     * @return the list with selected sub nodes
+     */
+    private List<T> createSubNodeListForName(T node, QName name)
+    {
+        String compareName =
+                (name.getPrefix() == null) ? name.getName() : prefixName(
+                        name.getPrefix(), name.getName());
+        List<T> result = new ArrayList<T>();
+        for (T child : getNodeHandler().getChildren(node))
+        {
+            if (StringUtils.equals(compareName, getNodeHandler()
+                    .nodeName(child)))
+            {
+                result.add(child);
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Obtains the list of selected sub nodes for a {@code NodeNameTest} with a
+     * wildcard name.
+     *
+     * @param node the current node
+     * @param name the name to be selected
+     * @return the list with selected sub nodes
+     */
+    private List<T> createSubNodeListForWildcardName(T node, QName name)
+    {
+        List<T> children = getNodeHandler().getChildren(node);
+        if (name.getPrefix() == null)
+        {
+            return children;
+        }
+        else
+        {
+            List<T> prefixChildren = new ArrayList<T>(children.size());
+            String prefix = prefixName(name.getPrefix(), null);
+            for (T child : children)
+            {
+                if (StringUtils.startsWith(getNodeHandler().nodeName(child),
+                        prefix))
+                {
+                    prefixChildren.add(child);
+                }
+            }
+            return prefixChildren;
+        }
+    }
+
     /**
      * Determines the start position of the iteration. Finds the index of the
      * given start node in the children of the root node.
@@ -176,4 +220,17 @@ private int findStartIndex(List<T> children, T startNode)
 
         return -1;
     }
+
+    /**
+     * Generates a qualified name with a namespace prefix.
+     *
+     * @param prefix the prefix
+     * @param name the name
+     * @return the qualified name
+     */
+    private static String prefixName(String prefix, String name)
+    {
+        return String.format(FMT_NAMESPACE, prefix,
+                StringUtils.defaultString(name));
+    }
 }
diff --git a/src/test/java/org/apache/commons/configuration/tree/xpath/TestConfigurationNodeIteratorChildren.java b/src/test/java/org/apache/commons/configuration/tree/xpath/TestConfigurationNodeIteratorChildren.java
index 68d1d463b3..bf3eb60951 100644
--- a/src/test/java/org/apache/commons/configuration/tree/xpath/TestConfigurationNodeIteratorChildren.java
+++ b/src/test/java/org/apache/commons/configuration/tree/xpath/TestConfigurationNodeIteratorChildren.java
@@ -24,6 +24,7 @@
 import java.util.Locale;
 
 import org.apache.commons.configuration.tree.ImmutableNode;
+import org.apache.commons.configuration.tree.NodeStructureHelper;
 import org.apache.commons.jxpath.ri.Compiler;
 import org.apache.commons.jxpath.ri.QName;
 import org.apache.commons.jxpath.ri.compiler.NodeNameTest;
@@ -42,6 +43,12 @@
  */
 public class TestConfigurationNodeIteratorChildren extends AbstractXPathTest
 {
+    /** Constant for a namespace prefix. */
+    private static final String PREFIX = "commons";
+
+    /** Constant for the name of a node with a namespace. */
+    private static final String PREFIX_NODE = "configuration";
+
     /** Stores the node pointer to the root node. */
     private ConfigurationNodePointer<ImmutableNode> rootPointer;
 
@@ -50,9 +57,20 @@ public class TestConfigurationNodeIteratorChildren extends AbstractXPathTest
     public void setUp() throws Exception
     {
         super.setUp();
-        rootPointer =
-                new ConfigurationNodePointer<ImmutableNode>(root,
-                        Locale.getDefault(), handler);
+        rootPointer = createPointer(root);
+    }
+
+    /**
+     * Helper method for creating a node pointer for a given node.
+     *
+     * @param node the node the pointer points to
+     * @return the node pointer
+     */
+    private ConfigurationNodePointer<ImmutableNode> createPointer(
+            ImmutableNode node)
+    {
+        return new ConfigurationNodePointer<ImmutableNode>(node,
+                Locale.getDefault(), handler);
     }
 
     /**
@@ -234,6 +252,60 @@ public void testIterateStartsWithInvalid()
         assertEquals("Wrong start node", "1", node.getValue());
     }
 
+    /**
+     * Creates a node pointer to a node which also contains a child node with a
+     * namespace prefix.
+     *
+     * @return the node pointer
+     */
+    private ConfigurationNodePointer<ImmutableNode> createPointerWithNamespace()
+    {
+        ImmutableNode node =
+                new ImmutableNode.Builder(2)
+                        .addChild(root)
+                        .addChild(
+                                NodeStructureHelper.createNode(PREFIX + ':'
+                                        + PREFIX_NODE, "test")
+                        ).create();
+        return createPointer(node);
+    }
+
+    /**
+     * Tests whether all nodes with a specific prefix can be obtained.
+     */
+    @Test
+    public void testIterateWithWildcardTestPrefix()
+    {
+        NodeNameTest test = new NodeNameTest(new QName(PREFIX, "*"));
+        ConfigurationNodeIteratorChildren<ImmutableNode> it =
+                new ConfigurationNodeIteratorChildren<ImmutableNode>(
+                        createPointerWithNamespace(), test, false, null);
+        assertEquals("Wrong number of elements", 1, iteratorSize(it));
+        for (NodePointer p : iterationElements(it))
+        {
+            assertEquals("Wrong element", PREFIX + ':' + PREFIX_NODE, p
+                    .getName().getName());
+        }
+    }
+
+    /**
+     * Tests whether nodes with a matching namespace prefix can be obtained.
+     */
+    @Test
+    public void testIterateWithMatchingPrefixTest()
+    {
+        NodeNameTest test = new NodeNameTest(new QName(PREFIX, PREFIX_NODE));
+        ConfigurationNodeIteratorChildren<ImmutableNode> it =
+                new ConfigurationNodeIteratorChildren<ImmutableNode>(
+                        createPointerWithNamespace(), test, false, null);
+        assertEquals("Wrong number of elements", 1, iteratorSize(it));
+        for (NodePointer p : iterationElements(it))
+        {
+            assertEquals("Wrong element", PREFIX + ':' + PREFIX_NODE, p
+                    .getName().getName());
+        }
+    }
+
     /**
      * Helper method for checking the values of the nodes returned by an
      * iterator. Because the values indicate the order of the child nodes with
