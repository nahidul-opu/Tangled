From 4d1f13653f9627766844bd0389750a701917b981 Mon Sep 17 00:00:00 2001
From: Oliver Heger <oheger@apache.org>
Date: Fri, 8 Apr 2011 09:55:27 +0000
Subject: [PATCH] [CONFIGURATION-437] Ported changes to configuration2 branch.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/configuration/branches/configuration2_experimental@1090176 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |   5 +
 .../DefaultConfigurationBuilder.java          |  51 +++++++
 .../userguide/howto_configurationbuilder.xml  |  12 +-
 .../TestDefaultConfigurationBuilder.java      |  77 ++++++++++
 .../AbstractTestConfigurationEvents.java      |  91 +-----------
 .../event/ConfigurationListenerTestImpl.java  | 136 ++++++++++++++++++
 6 files changed, 282 insertions(+), 90 deletions(-)
 create mode 100644 src/test/java/org/apache/commons/configuration2/event/ConfigurationListenerTestImpl.java

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index df6a7ee94c..627cb33625 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -83,6 +83,11 @@
         JNDIConfiguration.getKeys() no more logs an exception if the prefix does
         not exist.
       </action>
+      <action dev="oheger" type="update" issue="CONFIGURATION-437">
+        Child configuration builders created for a &lt;configuration&gt; element
+        in a configuration definition file now inherit some of their properties
+        from the builder object which processed the file.
+      </action>
       <action dev="oheger" type="fix" issue="CONFIGURATION-434">
         HierarchicalINIConfiguration now recognizes comment characters in
         property definitions only if they are preceded by whitespace. Thus
diff --git a/src/main/java/org/apache/commons/configuration2/DefaultConfigurationBuilder.java b/src/main/java/org/apache/commons/configuration2/DefaultConfigurationBuilder.java
index 4d8e864719..ef4bf22214 100644
--- a/src/main/java/org/apache/commons/configuration2/DefaultConfigurationBuilder.java
+++ b/src/main/java/org/apache/commons/configuration2/DefaultConfigurationBuilder.java
@@ -37,6 +37,8 @@
 import org.apache.commons.configuration2.combined.CombinedConfiguration;
 import org.apache.commons.configuration2.combined.OverrideCombiner;
 import org.apache.commons.configuration2.combined.UnionCombiner;
+import org.apache.commons.configuration2.event.ConfigurationErrorListener;
+import org.apache.commons.configuration2.event.ConfigurationListener;
 import org.apache.commons.configuration2.expr.NodeList;
 import org.apache.commons.configuration2.expr.def.DefaultExpressionEngine;
 import org.apache.commons.configuration2.fs.FileSystem;
@@ -1681,6 +1683,55 @@ public AbstractConfiguration getEmptyConfiguration(
         {
             return new CombinedConfiguration();
         }
+
+        /**
+         * {@inheritDoc} This implementation ensures that the configuration
+         * builder created by this provider inherits the properties from the
+         * current configuration builder.
+         */
+        @Override
+        protected void initBeanInstance(Object bean, BeanDeclaration data)
+                throws Exception
+        {
+            ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
+            initChildBuilder(decl.getConfigurationBuilder(),
+                    (DefaultConfigurationBuilder) bean);
+            super.initBeanInstance(bean, data);
+        }
+
+        /**
+         * Initializes the given child configuration builder from its parent
+         * builder. This method copies the values of some properties from the
+         * parent builder to the child builder so that the child inherits
+         * properties from its parent.
+         *
+         * @param parent the parent builder
+         * @param child the child builder
+         */
+        private static void initChildBuilder(
+                DefaultConfigurationBuilder parent,
+                DefaultConfigurationBuilder child)
+        {
+            child.setAttributeSplittingDisabled(parent
+                    .isAttributeSplittingDisabled());
+            child.setBasePath(parent.getBasePath());
+            child.setDelimiterParsingDisabled(parent
+                    .isDelimiterParsingDisabled());
+            child.setListDelimiter(parent.getListDelimiter());
+            child.setThrowExceptionOnMissing(parent.isThrowExceptionOnMissing());
+            child.setLogger(parent.getLogger());
+
+            child.clearConfigurationListeners();
+            for(ConfigurationListener l : parent.getConfigurationListeners())
+            {
+                child.addConfigurationListener(l);
+            }
+            child.clearErrorListeners();
+            for (ConfigurationErrorListener l : parent.getErrorListeners())
+            {
+                child.addErrorListener(l);
+            }
+        }
     }
 
     /**
diff --git a/src/site/xdoc/userguide/howto_configurationbuilder.xml b/src/site/xdoc/userguide/howto_configurationbuilder.xml
index 82bbc62478..2c64f9af40 100644
--- a/src/site/xdoc/userguide/howto_configurationbuilder.xml
+++ b/src/site/xdoc/userguide/howto_configurationbuilder.xml
@@ -148,7 +148,17 @@
         combined configuration. Like all file-based configurations the
         <code>fileName</code> attribute can be used to specify the configuration
         definition file to be loaded. This file must be an XML document that
-        conforms to the format described here.</dd>
+        conforms to the format described here. Some of the most important
+        settings are copied from the original <code>DefaultConfigurationBuilder</code>
+        object to the newly created builder:
+        <ul>
+        <li>the base path under which configuration files are searched</li>
+        <li>some flags, e.g. for controlling delimiter parsing or throwing
+        exceptions on missing properties</li>
+        <li>the logger</li>
+        <li>the configuration and error listeners</li>
+        </ul>
+        </dd>
         <dt>ini</dt>
         <dd>This tag can be used to include an ini file into the resulting
         combined configuration. Behind the scenes an instance of
diff --git a/src/test/java/org/apache/commons/configuration2/TestDefaultConfigurationBuilder.java b/src/test/java/org/apache/commons/configuration2/TestDefaultConfigurationBuilder.java
index ae0c6ddc69..2fed567b16 100644
--- a/src/test/java/org/apache/commons/configuration2/TestDefaultConfigurationBuilder.java
+++ b/src/test/java/org/apache/commons/configuration2/TestDefaultConfigurationBuilder.java
@@ -31,6 +31,7 @@
 import org.apache.commons.configuration2.beanutils.BeanHelper;
 import org.apache.commons.configuration2.combined.CombinedConfiguration;
 import org.apache.commons.configuration2.combined.DynamicCombinedConfiguration;
+import org.apache.commons.configuration2.event.ConfigurationListenerTestImpl;
 import org.apache.commons.configuration2.expr.NodeHandler;
 import org.apache.commons.configuration2.expr.xpath.XPathExpressionEngine;
 import org.apache.commons.configuration2.reloading.FileChangedReloadingStrategy;
@@ -760,6 +761,82 @@ public void testConfigurationBuilderProvider()
         checkProperties(cc);
     }
 
+    /**
+     * Tests whether settings of the builder are propagated to child builders.
+     */
+    public void testConfigurationBuilderProviderInheritProperties()
+            throws Exception
+    {
+        factory.addProperty("override.configuration[@fileName]",
+                TEST_FILE.getAbsolutePath());
+        factory.setBasePath("conf");
+        factory.setAttributeSplittingDisabled(true);
+        factory.setDelimiterParsingDisabled(true);
+        factory.setListDelimiter('/');
+        factory.setThrowExceptionOnMissing(true);
+        Log log = LogFactory.getLog(getClass());
+        factory.setLogger(log);
+        factory.clearErrorListeners();
+        factory.clearConfigurationListeners();
+        ConfigurationListenerTestImpl l =
+                new ConfigurationListenerTestImpl(factory);
+        factory.addConfigurationListener(l);
+        DefaultConfigurationBuilder.ConfigurationDeclaration decl =
+                new DefaultConfigurationBuilder.ConfigurationDeclaration(
+                        factory,
+                        factory.configurationAt("override.configuration"));
+        DefaultConfigurationBuilder.ConfigurationBuilderProvider provider =
+                new DefaultConfigurationBuilder.ConfigurationBuilderProvider();
+        DefaultConfigurationBuilder child =
+                (DefaultConfigurationBuilder) provider.createBean(
+                        provider.fetchConfigurationClass(), decl, null);
+        assertEquals("Wrong base path", factory.getBasePath(),
+                child.getBasePath());
+        assertEquals("Wrong attribute splitting flag",
+                factory.isAttributeSplittingDisabled(),
+                child.isAttributeSplittingDisabled());
+        assertEquals("Wrong delimiter parsing flag",
+                factory.isDelimiterParsingDisabled(),
+                child.isDelimiterParsingDisabled());
+        assertEquals("Wrong list delimiter", factory.getListDelimiter(),
+                child.getListDelimiter());
+        assertEquals("Wrong exception flag",
+                factory.isThrowExceptionOnMissing(),
+                child.isThrowExceptionOnMissing());
+        assertSame("Wrong logger", log, child.getLogger());
+        assertTrue("Got error listeners", child.getErrorListeners().isEmpty());
+        assertEquals("Wrong number of listeners", 1, child
+                .getConfigurationListeners().size());
+        assertEquals("Wrong listener", l, child.getConfigurationListeners()
+                .iterator().next());
+    }
+
+    /**
+     * Tests whether properties of the parent configuration can be overridden.
+     */
+    public void testConfigurationBuilderProviderOverrideProperties()
+            throws Exception
+    {
+        factory.addProperty("override.configuration[@fileName]",
+                TEST_FILE.getAbsolutePath());
+        factory.addProperty("override.configuration[@basePath]", "base");
+        factory.addProperty("override.configuration[@throwExceptionOnMissing]",
+                "false");
+        factory.setBasePath("conf");
+        factory.setThrowExceptionOnMissing(true);
+        DefaultConfigurationBuilder.ConfigurationDeclaration decl =
+                new DefaultConfigurationBuilder.ConfigurationDeclaration(
+                        factory,
+                        factory.configurationAt("override.configuration"));
+        DefaultConfigurationBuilder.ConfigurationBuilderProvider provider =
+                new DefaultConfigurationBuilder.ConfigurationBuilderProvider();
+        DefaultConfigurationBuilder child =
+                (DefaultConfigurationBuilder) provider.createBean(
+                        provider.fetchConfigurationClass(), decl, null);
+        assertEquals("Wrong base path", "base", child.getBasePath());
+        assertFalse("Wrong exception flag", child.isThrowExceptionOnMissing());
+    }
+
     /**
      * Tests whether XML settings can be inherited.
      */
diff --git a/src/test/java/org/apache/commons/configuration2/event/AbstractTestConfigurationEvents.java b/src/test/java/org/apache/commons/configuration2/event/AbstractTestConfigurationEvents.java
index 16b3aa9f81..099fd9945c 100644
--- a/src/test/java/org/apache/commons/configuration2/event/AbstractTestConfigurationEvents.java
+++ b/src/test/java/org/apache/commons/configuration2/event/AbstractTestConfigurationEvents.java
@@ -16,8 +16,6 @@
  */
 package org.apache.commons.configuration2.event;
 
-import java.util.LinkedList;
-
 import junit.framework.TestCase;
 
 import org.apache.commons.configuration2.AbstractConfiguration;
@@ -49,7 +47,7 @@ public abstract class AbstractTestConfigurationEvents extends TestCase
     protected AbstractConfiguration config;
 
     /** A test event listener. */
-    protected TestConfigurationListener l;
+    protected ConfigurationListenerTestImpl l;
 
     @Override
     protected void setUp() throws Exception
@@ -57,7 +55,7 @@ protected void setUp() throws Exception
         super.setUp();
         config = createConfiguration();
         config.addProperty(EXIST_PROPERTY, "existing value");
-        l = new TestConfigurationListener();
+        l = new ConfigurationListenerTestImpl(config);
         config.addConfigurationListener(l);
     }
 
@@ -180,89 +178,4 @@ public void testClearEventWithDetails()
         l.checkEvent(AbstractConfiguration.EVENT_CLEAR, null, null, false);
         l.done();
     }
-
-    /**
-     * A test event listener class used for testing events generated by the
-     * configuration.
-     */
-    protected class TestConfigurationListener implements ConfigurationListener
-    {
-        /** Stores the received events. */
-        private LinkedList<ConfigurationEvent> events = new LinkedList<ConfigurationEvent>();
-
-        public void configurationChanged(ConfigurationEvent event)
-        {
-            events.add(event);
-        }
-
-        /**
-         * Checks if at least <code>minEvents</code> events have been
-         * received.
-         *
-         * @param minEvents the minimum number of expected events
-         */
-        public void checkEventCount(int minEvents)
-        {
-            assertTrue("Too view events received", events.size() >= minEvents);
-        }
-
-        /**
-         * Checks an expected event.
-         *
-         * @param type the event type
-         * @param propName the expected property name
-         * @param propValue the expected property value
-         * @param before the expected before flag
-         */
-        public void checkEvent(int type, String propName, Object propValue,
-                boolean before)
-        {
-            ConfigurationEvent e = nextEvent(type);
-            assertEquals("Wrong property name", propName, e.getPropertyName());
-            assertEquals("Wrong property value", propValue, e
-                    .getPropertyValue());
-            assertEquals("Wrong before flag", before, e.isBeforeUpdate());
-        }
-
-        /**
-         * Returns the next received event and checks for the expected type.
-         * This method can be used instead of <code>checkEvent()</code> for
-         * comparing complex event values.
-         * @param expectedType the expected type of the event
-         * @return the event object
-         */
-        public ConfigurationEvent nextEvent(int expectedType)
-        {
-            assertFalse("Too few events received", events.isEmpty());
-            ConfigurationEvent e = (ConfigurationEvent) events.removeFirst();
-            assertEquals("Wrong event source", config, e.getSource());
-            assertEquals("Wrong event type", expectedType, e.getType());
-            return e;
-        }
-
-        /**
-         * Skips to the last received event and checks that no events of the
-         * given type have been received. This method is used by checks for
-         * detail events to ignore the detail events.
-         *
-         * @param type the event type
-         */
-        public void skipToLast(int type)
-        {
-            while (events.size() > 1)
-            {
-                ConfigurationEvent e = (ConfigurationEvent) events
-                        .removeFirst();
-                assertTrue("Found end event in details", type != e.getType());
-            }
-        }
-
-        /**
-         * Checks if all events has been processed.
-         */
-        public void done()
-        {
-            assertTrue("Too many events received", events.isEmpty());
-        }
-    }
 }
diff --git a/src/test/java/org/apache/commons/configuration2/event/ConfigurationListenerTestImpl.java b/src/test/java/org/apache/commons/configuration2/event/ConfigurationListenerTestImpl.java
new file mode 100644
index 0000000000..f56e94aefc
--- /dev/null
+++ b/src/test/java/org/apache/commons/configuration2/event/ConfigurationListenerTestImpl.java
@@ -0,0 +1,136 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.configuration2.event;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * A test event listener class that can be used for testing whether
+ * configurations generated correct events.
+ *
+ * @author <a
+ *         href="http://commons.apache.org/configuration/team-list.html">Commons
+ *         Configuration team</a>
+ * @version $Id$
+ */
+public class ConfigurationListenerTestImpl implements ConfigurationListener
+{
+    /** The expected event source. */
+    private final Object expectedSource;
+
+    /** Stores the received events. */
+    private final List<ConfigurationEvent> events;
+
+    /**
+     * Creates a new instance of {@code ConfigurationListenerTestImpl} and sets
+     * the expected event source.
+     *
+     * @param source the event source (<b>null</b> if the source need not to be
+     *        checked)
+     */
+    public ConfigurationListenerTestImpl(Object source)
+    {
+        expectedSource = source;
+        events = new LinkedList<ConfigurationEvent>();
+    }
+
+    public void configurationChanged(ConfigurationEvent event)
+    {
+        events.add(event);
+    }
+
+    /**
+     * Checks if at least <code>minEvents</code> events have been received.
+     *
+     * @param minEvents the minimum number of expected events
+     */
+    public void checkEventCount(int minEvents)
+    {
+        AbstractTestConfigurationEvents.assertTrue("Too view events received",
+                events.size() >= minEvents);
+    }
+
+    /**
+     * Checks an expected event.
+     *
+     * @param type the event type
+     * @param propName the expected property name
+     * @param propValue the expected property value
+     * @param before the expected before flag
+     */
+    public void checkEvent(int type, String propName, Object propValue,
+            boolean before)
+    {
+        ConfigurationEvent e = nextEvent(type);
+        AbstractTestConfigurationEvents.assertEquals("Wrong property name",
+                propName, e.getPropertyName());
+        AbstractTestConfigurationEvents.assertEquals("Wrong property value",
+                propValue, e.getPropertyValue());
+        AbstractTestConfigurationEvents.assertEquals("Wrong before flag",
+                before, e.isBeforeUpdate());
+    }
+
+    /**
+     * Returns the next received event and checks for the expected type. This
+     * method can be used instead of <code>checkEvent()</code> for comparing
+     * complex event values.
+     *
+     * @param expectedType the expected type of the event
+     * @return the event object
+     */
+    public ConfigurationEvent nextEvent(int expectedType)
+    {
+        AbstractTestConfigurationEvents.assertFalse("Too few events received",
+                events.isEmpty());
+        ConfigurationEvent e = (ConfigurationEvent) events.remove(0);
+        if (expectedSource != null)
+        {
+            AbstractTestConfigurationEvents.assertEquals("Wrong event source",
+                    expectedSource, e.getSource());
+        }
+        AbstractTestConfigurationEvents.assertEquals("Wrong event type",
+                expectedType, e.getType());
+        return e;
+    }
+
+    /**
+     * Skips to the last received event and checks that no events of the given
+     * type have been received. This method is used by checks for detail events
+     * to ignore the detail events.
+     *
+     * @param type the event type
+     */
+    public void skipToLast(int type)
+    {
+        while (events.size() > 1)
+        {
+            ConfigurationEvent e = (ConfigurationEvent) events.remove(0);
+            AbstractTestConfigurationEvents.assertTrue(
+                    "Found end event in details", type != e.getType());
+        }
+    }
+
+    /**
+     * Checks if all events has been processed.
+     */
+    public void done()
+    {
+        AbstractTestConfigurationEvents.assertTrue("Too many events received",
+                events.isEmpty());
+    }
+}
