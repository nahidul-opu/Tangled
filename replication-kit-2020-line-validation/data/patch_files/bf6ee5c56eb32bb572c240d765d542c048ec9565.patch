From bf6ee5c56eb32bb572c240d765d542c048ec9565 Mon Sep 17 00:00:00 2001
From: Benedikt Ritter <britter@apache.org>
Date: Sat, 14 Mar 2015 12:46:02 +0000
Subject: [PATCH] LANG-948: Exception while using ExtendedMessageFormat and
 escaping braces. This fixes #19 from github. Thanks to Andrey Khobnya.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1666679 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  1 +
 .../lang3/text/ExtendedMessageFormat.java     | 35 ++++++++-----------
 .../lang3/text/ExtendedMessageFormatTest.java | 16 +++++++++
 3 files changed, 32 insertions(+), 20 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 2c2bea9e170..4234a77422a 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -22,6 +22,7 @@
   <body>
 
   <release version="3.4" date="tba" description="tba">
+    <action issue="LANG-948" type="fix" dev="britter" due-to="Andrey Khobnya">Exception while using ExtendedMessageFormat and escaping braces</action>
     <action issue="LANG-1098" type="update" dev="britter" due-to="Mikhail Mazurskiy, Fabian Lange">Avoid String allocation in StrBuilder.append(CharSequence)</action>
     <action issue="LANG-1098" type="update" dev="britter" due-to="Michał Kordas">Update maven-checkstyle-plugin to 2.14</action>
     <action issue="LANG-1097" type="update" dev="britter" due-to="Michał Kordas">Update org.easymock:easymock to 3.3.1</action>
diff --git a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
index dd11b8caffb..b465bff56b3 100644
--- a/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
+++ b/src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
@@ -157,7 +157,7 @@ public final void applyPattern(final String pattern) {
         while (pos.getIndex() < pattern.length()) {
             switch (c[pos.getIndex()]) {
             case QUOTE:
-                appendQuotedString(pattern, pos, stripCustom, true);
+                appendQuotedString(pattern, pos, stripCustom);
                 break;
             case START_FE:
                 fmtCount++;
@@ -384,7 +384,7 @@ private String parseFormatDescription(final String pattern, final ParsePosition
                 }
                 break;
             case QUOTE:
-                getQuotedString(pattern, pos, false);
+                getQuotedString(pattern, pos);
                 break;
             default:
                 break;
@@ -413,7 +413,7 @@ private String insertFormats(final String pattern, final ArrayList<String> custo
             final char c = pattern.charAt(pos.getIndex());
             switch (c) {
             case QUOTE:
-                appendQuotedString(pattern, pos, sb, false);
+                appendQuotedString(pattern, pos, sb);
                 break;
             case START_FE:
                 depth++;
@@ -471,26 +471,23 @@ private ParsePosition next(final ParsePosition pos) {
      * @param pattern pattern to parse
      * @param pos current parse position
      * @param appendTo optional StringBuilder to append
-     * @param escapingOn whether to process escaped quotes
      * @return <code>appendTo</code>
      */
     private StringBuilder appendQuotedString(final String pattern, final ParsePosition pos,
-            final StringBuilder appendTo, final boolean escapingOn) {
+            final StringBuilder appendTo) {
+        assert pattern.toCharArray()[pos.getIndex()] == QUOTE : 
+            "Quoted string must start with quote character";
+
+        // handle quote character at the beginning of the string
+        if(appendTo != null) {
+            appendTo.append(QUOTE);
+        }
+        next(pos);
+
         final int start = pos.getIndex();
         final char[] c = pattern.toCharArray();
-        if (escapingOn && c[start] == QUOTE) {
-            next(pos);
-            return appendTo == null ? null : appendTo.append(QUOTE);
-        }
         int lastHold = start;
         for (int i = pos.getIndex(); i < pattern.length(); i++) {
-            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {
-                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(
-                        QUOTE);
-                pos.setIndex(i + ESCAPED_QUOTE.length());
-                lastHold = pos.getIndex();
-                continue;
-            }
             switch (c[pos.getIndex()]) {
             case QUOTE:
                 next(pos);
@@ -509,11 +506,9 @@ private StringBuilder appendQuotedString(final String pattern, final ParsePositi
      *
      * @param pattern pattern to parse
      * @param pos current parse position
-     * @param escapingOn whether to process escaped quotes
      */
-    private void getQuotedString(final String pattern, final ParsePosition pos,
-            final boolean escapingOn) {
-        appendQuotedString(pattern, pos, null, escapingOn);
+    private void getQuotedString(final String pattern, final ParsePosition pos) {
+        appendQuotedString(pattern, pos, null);
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java b/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java
index 82d8f1069d5..926019e8d0b 100644
--- a/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java
+++ b/src/test/java/org/apache/commons/lang3/text/ExtendedMessageFormatTest.java
@@ -89,6 +89,22 @@ public void testEmbeddedPatternInChoice() {
         assertEquals(emf.format(new Object[] {"there", 3, "great"}), "Hi there, got 3, GREAT!");
     }
 
+    /**
+     * Test Bug LANG-948 - Exception while using ExtendedMessageFormat and escaping braces
+     */
+    @Test
+    public void testEscapedBraces_LANG_948() {
+        // message without placeholder because braces are escaped by quotes 
+        final String pattern = "Message without placeholders '{}'";
+        final ExtendedMessageFormat emf = new ExtendedMessageFormat(pattern, registry);
+        assertEquals("Message without placeholders {}", emf.format(new Object[] {"DUMMY"}));
+
+        // message with placeholder because quotes are escaped by quotes 
+        final String pattern2 = "Message with placeholder ''{0}''";
+        final ExtendedMessageFormat emf2 = new ExtendedMessageFormat(pattern2, registry);
+        assertEquals("Message with placeholder 'DUMMY'", emf2.format(new Object[] {"DUMMY"}));
+    }
+
     /**
      * Test extended and built in formats.
      */
