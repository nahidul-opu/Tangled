From fe56886f6d4c6f872caa23faa4b94e34b0b221a1 Mon Sep 17 00:00:00 2001
From: "Gary D. Gregory" <ggregory@apache.org>
Date: Mon, 19 Mar 2012 19:48:00 +0000
Subject: [PATCH] [CODEC-130] Base64InputStream.skip skips underlying stream,
 not output. Better exception information. Less verbose code with a single
 return. Order methods AB.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1302622 13f79535-47bb-0310-9956-ffa450edef68
---
 .../codec/binary/BaseNCodecInputStream.java   | 60 +++++++++----------
 1 file changed, 28 insertions(+), 32 deletions(-)

diff --git a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
index d1eb77bbc7..6c335ecfc0 100644
--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
@@ -30,10 +30,10 @@
  */
 public class BaseNCodecInputStream extends FilterInputStream {
 
-    private final boolean doEncode;
-
     private final BaseNCodec baseNCodec;
 
+    private final boolean doEncode;
+
     private final byte[] singleByte = new byte[1];
 
     protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
@@ -42,6 +42,31 @@ protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean d
         this.baseNCodec = baseNCodec;
     }
 
+    /**
+     * {@inheritDoc}
+     *
+     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,
+     * <code>1</code> otherwise
+     */
+    public int available() throws IOException {
+        // Note: the logic is similar to the InflaterInputStream:
+        //       as long as we have not reached EOF, indicate that there is more
+        //       data available. As we do not know for sure how much data is left,
+        //       just return 1 as a safe guess.
+
+        // use the EOF flag of the underlying codec instance
+        return baseNCodec.eof ? 0 : 1;
+    }
+
+    /**
+     * {@inheritDoc}
+     * 
+     * @return false
+     */
+    @Override
+    public boolean markSupported() {
+        return false; // not an easy job to support marks
+    }
     /**
      * Reads one <code>byte</code> from this input stream.
      * 
@@ -124,15 +149,6 @@ public int read(byte b[], int offset, int len) throws IOException {
             return readLen;
         }
     }
-    /**
-     * {@inheritDoc}
-     * 
-     * @return false
-     */
-    @Override
-    public boolean markSupported() {
-        return false; // not an easy job to support marks
-    }
 
     /**
      * {@inheritDoc}
@@ -142,7 +158,7 @@ public boolean markSupported() {
     @Override
     public long skip(long n) throws IOException {
         if (n < 0) {
-            throw new IllegalArgumentException("Negative skip length");
+            throw new IllegalArgumentException("Negative skip length: " + n);
         }
 
         // skip in chunks of 512 bytes
@@ -164,24 +180,4 @@ public long skip(long n) throws IOException {
 
         return total;
     }
-
-    /**
-     * {@inheritDoc}
-     *
-     * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>,
-     * <code>1</code> otherwise
-     */
-    public int available() throws IOException {
-        // Note: the logic is similar to the InflaterInputStream:
-        //       as long as we have not reached EOF, indicate that there is more
-        //       data available. As we do not know for sure how much data is left,
-        //       just return 1 as a safe guess.
-
-        // use the EOF flag of the underlying codec instance
-        if (baseNCodec.eof) {
-            return 0;
-        } else {
-            return 1;
-        }
-    }
 }
