From 9fcd616fe5790778febb79d50c7b297b056877a6 Mon Sep 17 00:00:00 2001
From: Maarten Coene <maartenc@apache.org>
Date: Mon, 26 Mar 2012 22:45:10 +0000
Subject: [PATCH] FIX: Impossible to get artifacts when data has not been
 loaded for multiple dynamic revisions (IVY-1333)

git-svn-id: https://svn.apache.org/repos/asf/ant/ivy/core/trunk@1305644 13f79535-47bb-0310-9956-ffa450edef68
---
 CHANGES.txt                                   |  1 +
 .../apache/ivy/core/resolve/ResolveData.java  | 96 +++++++++++++++----
 .../apache/ivy/core/resolve/ResolveTest.java  | 18 ++++
 3 files changed, 98 insertions(+), 17 deletions(-)

diff --git a/CHANGES.txt b/CHANGES.txt
index 81ed2c9a4..efd493f21 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -146,6 +146,7 @@ for detailed view of each issue, please consult http://issues.apache.org/jira/br
 - IMPROVEMENT: ivy:retrieve can now convert 'dotted'-organisation names into a directory tree.
 - IMPROVEMENT: ivy:retrieve now accepts a nested mapper type.
 
+- FIX: Impossible to get artifacts when data has not been loaded for multiple dynamic revisions (IVY-1333)
 - FIX: Ivy didn't properly handle some file: URLs (IVY-1340)
 - FIX: fallback mechanism didn't work properly for private configurations
 - FIX: /localivy target does not work when building Ivy jar (IVY-1338) (thanks to Ben Schmidt)
diff --git a/src/java/org/apache/ivy/core/resolve/ResolveData.java b/src/java/org/apache/ivy/core/resolve/ResolveData.java
index dee201dc2..8fb88806e 100644
--- a/src/java/org/apache/ivy/core/resolve/ResolveData.java
+++ b/src/java/org/apache/ivy/core/resolve/ResolveData.java
@@ -94,7 +94,69 @@ public Collection getNodeIds() {
     }
 
     public VisitData getVisitData(ModuleRevisionId mrid) {
-        return (VisitData) visitData.get(mrid);
+        VisitData result = (VisitData) visitData.get(mrid);
+
+        if (result == null) {
+            // search again, now ignore the missing extra attributes
+            for (Iterator it = visitData.entrySet().iterator(); it.hasNext();) {
+                Map.Entry entry = (Entry) it.next();
+                ModuleRevisionId current = (ModuleRevisionId) entry.getKey();
+                
+                if (isSubMap(mrid.getAttributes(), current.getAttributes())) {
+                    result = (VisitData) entry.getValue();
+                    break;
+                }
+            }
+        }
+
+        return result;
+    }
+    
+    /**
+     * Checks whether one map is a sub-map of the other.
+     */
+    private static boolean isSubMap(Map map1, Map map2) {
+        int map1Size = map1.size();
+        int map2Size = map2.size();
+        
+        if (map1Size == map2Size) {
+            return map1.equals(map2);
+        }
+        
+        Map smallest = map1Size < map2Size ? map1 : map2;
+        Map largest = map1Size < map2Size ? map2 : map1;
+        
+        for (Iterator it = smallest.entrySet().iterator(); it.hasNext(); ) {
+            Map.Entry entry = (Entry) it.next();
+            
+            if (!largest.containsKey(entry.getKey())) {
+                return false;
+            }
+            
+            Object map1Value = smallest.get(entry.getKey());
+            Object map2Value = largest.get(entry.getKey());
+            if (!isEqual(map1Value, map2Value)) {
+                return false;
+            }
+        }
+        
+        return true;
+    }
+    
+    private static boolean isEqual(Object obj1, Object obj2) {
+        if (obj1 == obj2) {
+            return true;
+        }
+        
+        if (obj1 == null) {
+            return obj2 == null;
+        }
+        
+        if (obj2 == null) {
+            return obj1 == null;
+        }
+        
+        return obj1.equals(obj2);
     }
     
     /**
@@ -210,22 +272,22 @@ void blacklist(IvyNode node) {
     public boolean isBlacklisted(String rootModuleConf, ModuleRevisionId mrid) {
         IvyNode node = getNode(mrid);
         
-        if (node == null) {
-            // search again, now ignore the extra attributes
-            // TODO: maybe we should search the node that has at least the 
-            // same attributes as mrid
-            for (Iterator it = visitData.entrySet().iterator(); it.hasNext();) {
-                Map.Entry entry = (Entry) it.next();
-                ModuleRevisionId current = (ModuleRevisionId) entry.getKey();
-                if (current.getModuleId().equals(mrid.getModuleId())
-                        && current.getRevision().equals(mrid.getRevision())) {
-                    VisitData data = (VisitData) entry.getValue();
-                    node = data.getNode();
-                    break;
-                }
-            }
-        }
-        
+//        if (node == null) {
+//            // search again, now ignore the extra attributes
+//            // TODO: maybe we should search the node that has at least the 
+//            // same attributes as mrid
+//            for (Iterator it = visitData.entrySet().iterator(); it.hasNext();) {
+//                Map.Entry entry = (Entry) it.next();
+//                ModuleRevisionId current = (ModuleRevisionId) entry.getKey();
+//                if (current.getModuleId().equals(mrid.getModuleId())
+//                        && current.getRevision().equals(mrid.getRevision())) {
+//                    VisitData data = (VisitData) entry.getValue();
+//                    node = data.getNode();
+//                    break;
+//                }
+//            }
+//        }
+//        
         return node != null && node.isBlacklisted(rootModuleConf);
     }
 
diff --git a/test/java/org/apache/ivy/core/resolve/ResolveTest.java b/test/java/org/apache/ivy/core/resolve/ResolveTest.java
index 024d9bedd..d13a7ab91 100644
--- a/test/java/org/apache/ivy/core/resolve/ResolveTest.java
+++ b/test/java/org/apache/ivy/core/resolve/ResolveTest.java
@@ -3380,6 +3380,24 @@ public void testIVY1233() throws Exception {
         assertTrue(modRevIds.contains(ModuleRevisionId.newInstance("test", "c", "3.0")));
     }
 
+    public void testIVY1333() throws Exception {
+        Ivy ivy = new Ivy();
+        ivy.configure(new File("test/repositories/IVY-1333/ivysettings.xml"));
+        ivy.getSettings().setDefaultCache(cache);
+
+        ResolveReport rr = ivy.resolve(new File("test/repositories/IVY-1333/ivy.xml").toURI().toURL(),
+            getResolveOptions(new String[] {"*"}));
+        ConfigurationResolveReport crr = rr.getConfigurationReport("default");
+        Set modRevIds = crr.getModuleRevisionIds();
+        assertEquals(3, modRevIds.size());
+        assertTrue(modRevIds.contains(ModuleRevisionId.newInstance("org", "dep1", "1.0")));
+        assertTrue(modRevIds.contains(ModuleRevisionId.newInstance("org", "dep2", "1.0")));
+        
+        Map extra = new HashMap();
+        extra.put("o:a", "58701");
+        assertTrue(modRevIds.contains(ModuleRevisionId.newInstance("org", "badArtifact", "1.0.0.m4", extra)));
+    }
+
     public void testIVY999() throws Exception {
         Ivy ivy = new Ivy();
         ivy.configure(new File("test/repositories/IVY-999/ivysettings.xml"));
