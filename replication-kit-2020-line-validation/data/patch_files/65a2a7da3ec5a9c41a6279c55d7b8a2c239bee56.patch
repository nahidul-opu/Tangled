From 65a2a7da3ec5a9c41a6279c55d7b8a2c239bee56 Mon Sep 17 00:00:00 2001
From: Maarten Coene <maartenc@apache.org>
Date: Fri, 23 Mar 2012 22:27:47 +0000
Subject: [PATCH] FIX: Infinite loop in latest-compatible conflict manager
 (IVY-1233) (thanks to Payam Hekmat and Sven Zethelius)

git-svn-id: https://svn.apache.org/repos/asf/ant/ivy/core/trunk@1304633 13f79535-47bb-0310-9956-ffa450edef68
---
 CHANGES.txt                                   |  3 ++-
 .../LatestCompatibleConflictManager.java      | 15 +++++++--------
 .../LatestCompatibleConflictManagerTest.java  | 19 +++++++++++++++++++
 3 files changed, 28 insertions(+), 9 deletions(-)

diff --git a/CHANGES.txt b/CHANGES.txt
index 103dd3657..92607813d 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -119,6 +119,7 @@ for detailed view of each issue, please consult http://issues.apache.org/jira/br
 	Chris Wood
 	Patrick Woodworth
 	Jaroslaw Wypychowski
+	Sven Zethelius
 	Aleksey Zhukov
 	
    trunk
@@ -154,7 +155,7 @@ for detailed view of each issue, please consult http://issues.apache.org/jira/br
 - FIX: extra attributes lost from info when ivy file is merged with parent (IVY-1206)
 - FIX: ivy:report ant task intermittently "cannot compile stylesheet" (IVY-1325)
 - FIX: Maven 'eclipse-plugin', 'jbi-component' and 'jbi-shared-library' packaging is now mapped to 'jar' extension (IVY-899)
-- FIX: Infinite loop in latest-compatible conflict manager (IVY-1233) (thanks to Payam Hekmat)
+- FIX: Infinite loop in latest-compatible conflict manager (IVY-1233) (thanks to Payam Hekmat and Sven Zethelius)
 - FIX: extends section of ivy.xml info does not replace variable in location tag (IVY-1287) (thanks to Jean-Louis Boudart)
 - FIX: Valid Path does not work for Filesystem Resolver (IVY-1268)
 - FIX: quiet="true" does not surpress download 'dots' on packager resolver (IVY-1269)
diff --git a/src/java/org/apache/ivy/plugins/conflict/LatestCompatibleConflictManager.java b/src/java/org/apache/ivy/plugins/conflict/LatestCompatibleConflictManager.java
index 3b415a052..d393bfbb8 100644
--- a/src/java/org/apache/ivy/plugins/conflict/LatestCompatibleConflictManager.java
+++ b/src/java/org/apache/ivy/plugins/conflict/LatestCompatibleConflictManager.java
@@ -188,7 +188,7 @@ private void blackListIncompatibleCallerAndRestartResolveIfPossible(IvySettings
         Stack callerStack = new Stack();
         callerStack.push(evicted);
         final Collection toBlacklist = blackListIncompatibleCaller(
-            settings.getVersionMatcher(), parent, selected, evicted, callerStack, false); 
+            settings.getVersionMatcher(), parent, selected, evicted, callerStack); 
         if (toBlacklist != null) {
             final StringBuffer blacklisted = new StringBuffer();
             for (Iterator iterator = toBlacklist.iterator(); iterator.hasNext();) {
@@ -217,7 +217,7 @@ private void blackListIncompatibleCallerAndRestartResolveIfPossible(IvySettings
 
     private boolean handleIncompatibleCaller(Stack callerStack, IvyNode node, IvyNode callerNode,
             IvyNode conflictParent, IvyNode selectedNode, IvyNode evictedNode,
-            Collection blacklisted, VersionMatcher versionMatcher, boolean dynamicCaller) {
+            Collection blacklisted, VersionMatcher versionMatcher) {
         if (callerStack.subList(0, callerStack.size() - 1).contains(node)) {
             // circular dependency found and handled: the current top of the stack (node)
             // was already contained in the rest of the stack, the circle is closed, nothing
@@ -226,7 +226,7 @@ private boolean handleIncompatibleCaller(Stack callerStack, IvyNode node, IvyNod
         } else {
             callerStack.push(callerNode);
             Collection sub = blackListIncompatibleCaller(versionMatcher, conflictParent,
-                selectedNode, evictedNode, callerStack, dynamicCaller);
+                selectedNode, evictedNode, callerStack);
             callerStack.pop();
             if (sub == null) {
                 // propagate the fact that a path with unblacklistable caller has been found
@@ -257,8 +257,7 @@ private boolean handleIncompatibleCaller(Stack callerStack, IvyNode node, IvyNod
     private Collection/*<IvyNodeBlacklist>*/ blackListIncompatibleCaller(
             VersionMatcher versionMatcher,
             IvyNode conflictParent, IvyNode selectedNode, IvyNode evictedNode, 
-            Stack/*<IvyNode>*/ callerStack,
-            boolean dynamicCaller) {
+            Stack/*<IvyNode>*/ callerStack) {
         Collection/*<IvyNodeBlacklist>*/ blacklisted = new ArrayList/*<IvyNodeBlacklist>*/();
         IvyNode node = (IvyNode) callerStack.peek();
         String rootModuleConf = conflictParent.getData().getReport().getConfiguration();
@@ -273,15 +272,15 @@ private boolean handleIncompatibleCaller(Stack callerStack, IvyNode node, IvyNod
                         node, rootModuleConf));
                 if (node.isEvicted(rootModuleConf)
                         && !handleIncompatibleCaller(callerStack, node, callerNode, conflictParent,
-                            selectedNode, evictedNode, blacklisted, versionMatcher, true)) {
+                            selectedNode, evictedNode, blacklisted, versionMatcher)) {
                     return null;
                 }
             } else if(!handleIncompatibleCaller(callerStack, node, callerNode, conflictParent,
-                    selectedNode, evictedNode, blacklisted, versionMatcher, false)) {
+                    selectedNode, evictedNode, blacklisted, versionMatcher)) {
                 return null;
             }
         }
-        if (!dynamicCaller && blacklisted.isEmpty() 
+        if (blacklisted.isEmpty() 
                 && !callerStack.subList(0, callerStack.size() - 1).contains(node)) {
             return null;
         }
diff --git a/test/java/org/apache/ivy/plugins/conflict/LatestCompatibleConflictManagerTest.java b/test/java/org/apache/ivy/plugins/conflict/LatestCompatibleConflictManagerTest.java
index 5b9688a65..60ff3c32c 100644
--- a/test/java/org/apache/ivy/plugins/conflict/LatestCompatibleConflictManagerTest.java
+++ b/test/java/org/apache/ivy/plugins/conflict/LatestCompatibleConflictManagerTest.java
@@ -176,6 +176,25 @@ public void testConflict() throws Exception {
             // this is expected
         }
     }
+    
+    public void testDynamicRootConflict() throws Exception {
+        try {
+            fixture
+                .addMD("#A;conflict-> {#B;[1.2,2.0[ #C;pCC.main.+ #D;[1.5,1.7[ }")
+                .addMD("#B;1.0.0->#D;[1.6.1,2.0[")
+                .addMD("#B;1.1.0->#D;[1.6.1,2.0[")
+                .addMD("#B;pCC.main.0.0->#D;[1.6.1,2.0[")
+                .addMD("#C;1.0.0-> {#B;[1.0,2.0[ #D;[1.6.0,1.7[ }")
+                .addMD("#C;1.1.0-> {#B;[1.1,2.0[ #D;[1.6.0,1.7[ }")
+                .addMD("#C;pCC.main.1.9-> {#B;pCC.main.+ #D;[1.6.0,1.7[ }")
+                .addMD("#D;1.6.1").init();
+            fixture.resolve("#A;conflict");
+    
+            fail("Resolve should have failed with a conflict");
+        } catch (StrictConflictException e) { 
+            // this is expected }
+        }
+    }
 
     private void resolveAndAssert(String mrid, String expectedModuleSet) 
         throws ParseException, IOException {
