From 20a88d9b49beda71ddee69af92872716fd00f13a Mon Sep 17 00:00:00 2001
From: "Gary D. Gregory" <ggregory@apache.org>
Date: Mon, 27 Jul 2009 23:41:58 +0000
Subject: [PATCH] - Applied patch for [CODEC-81] production pretty much
 unchanged. - Applied patch for [CODEC-81] tests and split one new unit test
 method into two tests. One for URL-safe and another for normal processing. -
 Renamed StringBytesUtils to StringUtils - Added missing @return tags to
 StringUtils

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@798333 13f79535-47bb-0310-9956-ffa450edef68
---
 .../apache/commons/codec/binary/Base64.java   | 130 +++++++++++-------
 .../codec/binary/Base64InputStream.java       | 101 +++++++-------
 .../codec/binary/Base64OutputStream.java      | 130 ++++++++++--------
 ...StringBytesUtils.java => StringUtils.java} |  41 +++---
 .../codec/net/QuotedPrintableCodec.java       |   6 +-
 .../commons/codec/net/RFC1522Codec.java       |   6 +-
 .../apache/commons/codec/net/URLCodec.java    |   6 +-
 .../codec/binary/Base64InputStreamTest.java   |  28 ++--
 .../codec/binary/Base64OutputStreamTest.java  |  20 +--
 .../commons/codec/binary/Base64Test.java      | 110 ++++++++-------
 .../commons/codec/binary/Base64TestData.java  |   1 +
 ...tesUtilsTest.java => StringUtilsTest.java} |  34 ++---
 12 files changed, 345 insertions(+), 268 deletions(-)
 rename src/java/org/apache/commons/codec/binary/{StringBytesUtils.java => StringUtils.java} (84%)
 rename src/test/org/apache/commons/codec/binary/{StringBytesUtilsTest.java => StringUtilsTest.java} (82%)

diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java
index b85f9f4cdf..eb09b5c200 100644
--- a/src/java/org/apache/commons/codec/binary/Base64.java
+++ b/src/java/org/apache/commons/codec/binary/Base64.java
@@ -254,7 +254,7 @@ public Base64(boolean urlSafe) {
      * </p>
      * 
      * @param lineLength
-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).
+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
      * @since 1.4
      */
@@ -276,7 +276,7 @@ public Base64(int lineLength) {
      * </p>
      * 
      * @param lineLength
-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).
+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
      * @param lineSeparator
      *            Each line of encoded data will end with this sequence of bytes.
@@ -302,7 +302,7 @@ public Base64(int lineLength, byte[] lineSeparator) {
      * </p>
      * 
      * @param lineLength
-     *            Each line of encoded data will be at most of the given length (rounded up to nearest multiple of 4).
+     *            Each line of encoded data will be at most of the given length (rounded down to nearest multiple of 4).
      *            If lineLength <= 0, then the output will not be divided into lines (chunks). Ignored when decoding.
      * @param lineSeparator
      *            Each line of encoded data will end with this sequence of bytes.
@@ -314,7 +314,7 @@ public Base64(int lineLength, byte[] lineSeparator) {
      * @since 1.4
      */
     public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
-        this.lineLength = lineLength;
+        this.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;
         this.lineSeparator = new byte[lineSeparator.length];
         System.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);
         if (lineLength > 0) {
@@ -324,7 +324,7 @@ public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {
         }
         this.decodeSize = this.encodeSize - 1;
         if (containsBase64Byte(lineSeparator)) {
-            String sep = StringBytesUtils.newStringUtf8(lineSeparator);
+            String sep = StringUtils.newStringUtf8(lineSeparator);
             throw new IllegalArgumentException("lineSeperator must not contain base64 characters: [" + sep + "]");
         }
         this.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;
@@ -669,10 +669,11 @@ public static byte[] encodeBase64Chunked(byte[] binaryData) {
      *             if the parameter supplied is not of type byte[]
      */
     public Object decode(Object pObject) throws DecoderException {
-        if (!(pObject instanceof byte[])) {
+        if (pObject instanceof byte[]) {
+            return decode((byte[]) pObject);
+        } else {
             throw new DecoderException("Parameter supplied to Base64 decode is not a byte[]");
         }
-        return decode((byte[]) pObject);
     }
 
     /**
@@ -683,7 +684,24 @@ public Object decode(Object pObject) throws DecoderException {
      * @return a byte array containing binary data
      */
     public byte[] decode(byte[] pArray) {
-        return decodeBase64(pArray);
+        if (pArray == null || pArray.length == 0) {
+            return pArray;
+        }
+        long len = (pArray.length * 3) / 4;
+        byte[] buf = new byte[(int) len];
+        setInitialBuffer(buf, 0, buf.length);
+        decode(pArray, 0, pArray.length);
+        decode(pArray, 0, -1); // Notify decoder of EOF.
+
+        // Would be nice to just return buf (like we sometimes do in the encode
+        // logic), but we have no idea what the line-length was (could even be
+        // variable).  So we cannot determine ahead of time exactly how big an
+        // array is necessary.  Hence the need to construct a 2nd byte array to
+        // hold the final result:
+
+        byte[] result = new byte[pos];
+        readResults(result, 0, result.length);
+        return result;
     }
 
     /**
@@ -739,41 +757,17 @@ public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean
         if (binaryData == null || binaryData.length == 0) {
             return binaryData;
         }
-        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
-        long len = (binaryData.length * 4) / 3;
-        long mod = len % 4;
-        if (mod != 0) {
-            len += 4 - mod;
-        }
-        if (isChunked) {
-            boolean lenChunksPerfectly = len % CHUNK_SIZE == 0;
-            len += (len / CHUNK_SIZE) * CHUNK_SEPARATOR.length;
-            if (!lenChunksPerfectly) {
-                len += CHUNK_SEPARATOR.length;
-            }
-        }
+
+        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
         if (len > maxResultSize) {
             throw new IllegalArgumentException("Input array too big, the output array would be bigger (" +
                 len +
                 ") than the specified maxium size of " +
                 maxResultSize);
         }
-        byte[] buf = new byte[(int) len];
-        b64.setInitialBuffer(buf, 0, buf.length);
-        b64.encode(binaryData, 0, binaryData.length);
-        b64.encode(binaryData, 0, -1); // Notify encoder of EOF.
-        // Encoder might have resized, even though it was unnecessary.
-        if (b64.buffer != buf) {
-            b64.readResults(buf, 0, buf.length);
-        }
-        // In URL-SAFE mode we skip the padding characters, so sometimes our
-        // final length is a bit smaller.
-        if (urlSafe && b64.pos < buf.length) {
-            byte[] smallerBuf = new byte[b64.pos];
-            System.arraycopy(buf, 0, smallerBuf, 0, b64.pos);
-            buf = smallerBuf;
-        }
-        return buf;
+                
+        Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);
+        return b64.encode(binaryData);
     }
 
     /**
@@ -784,20 +778,8 @@ public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean
      * @return Array containing decoded data.
      */
     public static byte[] decodeBase64(byte[] base64Data) {
-        if (base64Data == null || base64Data.length == 0) {
-            return base64Data;
-        }
         Base64 b64 = new Base64();
-        long len = (base64Data.length * 3) / 4;
-        byte[] buf = new byte[(int) len];
-        b64.setInitialBuffer(buf, 0, buf.length);
-        b64.decode(base64Data, 0, base64Data.length);
-        b64.decode(base64Data, 0, -1); // Notify decoder of EOF.
-        // We have no idea what the line-length was, so we
-        // cannot know how much of our array wasn't used.
-        byte[] result = new byte[b64.pos];
-        b64.readResults(result, 0, result.length);
-        return result;
+        return b64.decode(base64Data);
     }
 
     /**
@@ -873,7 +855,53 @@ public Object encode(Object pObject) throws EncoderException {
      * @return A byte array containing only Base64 character data
      */
     public byte[] encode(byte[] pArray) {
-        return encodeBase64(pArray, false, isUrlSafe());
+        long len = getEncodeLength(pArray, lineLength, lineSeparator);
+        byte[] buf = new byte[(int) len];
+        setInitialBuffer(buf, 0, buf.length);
+        encode(pArray, 0, pArray.length);
+        encode(pArray, 0, -1); // Notify encoder of EOF.
+        // Encoder might have resized, even though it was unnecessary.
+        if (buffer != buf) {
+            readResults(buf, 0, buf.length);
+        }
+        // In URL-SAFE mode we skip the padding characters, so sometimes our
+        // final length is a bit smaller.
+        if (isUrlSafe() && pos < buf.length) {
+            byte[] smallerBuf = new byte[pos];
+            System.arraycopy(buf, 0, smallerBuf, 0, pos);
+            buf = smallerBuf;
+        }
+        return buf;        
+    }
+
+    /**
+     * Pre-calculates the amount of space needed to base64-encode the supplied array.
+     *
+     * @param pArray byte[] array which will later be encoded
+     * @param chunkSize line-length of the output (<= 0 means no chunking) between each
+     *        chunkSeparator (e.g. CRLF).
+     * @param chunkSeparator the sequence of bytes used to separate chunks of output (e.g. CRLF).
+     *
+     * @return amount of space needed to encoded the supplied array.  Returns
+     *         a long since a max-len array will require Integer.MAX_VALUE + 33%.
+     */
+    private static long getEncodeLength(byte[] pArray, int chunkSize, byte[] chunkSeparator) {
+        // base64 always encodes to multiples of 4.
+        chunkSize = (chunkSize / 4) * 4;
+
+        long len = (pArray.length * 4) / 3;
+        long mod = len % 4;
+        if (mod != 0) {
+            len += 4 - mod;
+        }
+        if (chunkSize > 0 && chunkSeparator != null) {
+            boolean lenChunksPerfectly = len % chunkSize == 0;
+            len += (len / chunkSize) * chunkSeparator.length;
+            if (!lenChunksPerfectly) {
+                len += chunkSeparator.length;
+            }
+        }
+        return len;
     }
 
     // Implementation of integer encoding used for crypto
diff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java
index ce9a5d25d0..87bae711f7 100644
--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java
+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java
@@ -22,21 +22,22 @@
 import java.io.InputStream;
 
 /**
- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).
- * When encoding the default lineLength is 76 characters and the default
- * lineEnding is CRLF, but these can be overridden by using the appropriate
+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength
+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
  * constructor.
  * <p>
- * The default behaviour of the Base64InputStream is to DECODE, whereas the
- * default behaviour of the Base64OutputStream is to ENCODE, but this
- * behaviour can be overridden by using a different constructor.
- * </p><p>
+ * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream
+ * is to ENCODE, but this behaviour can be overridden by using a different constructor.
+ * </p>
+ * <p>
  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
- * </p><p>
+ * </p>
+ * <p>
  * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc). 
+ * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
  * </p>
+ * 
  * @author Apache Software Foundation
  * @version $Id $
  * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
@@ -45,26 +46,29 @@
 public class Base64InputStream extends FilterInputStream {
 
     private final boolean doEncode;
+
     private final Base64 base64;
+
     private final byte[] singleByte = new byte[1];
 
     /**
-     * Creates a Base64InputStream such that all data read is Base64-decoded
-     * from the original provided InputStream.
-     *
-     * @param in InputStream to wrap.
+     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.
+     * 
+     * @param in
+     *            InputStream to wrap.
      */
     public Base64InputStream(InputStream in) {
         this(in, false);
     }
 
     /**
-     * Creates a Base64InputStream such that all data read is either
-     * Base64-encoded or Base64-decoded from the original provided InputStream.
-     *
-     * @param in       InputStream to wrap.
-     * @param doEncode true if we should encode all data read from us,
-     *                 false if we should decode.
+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
+     * provided InputStream.
+     * 
+     * @param in
+     *            InputStream to wrap.
+     * @param doEncode
+     *            true if we should encode all data read from us, false if we should decode.
      */
     public Base64InputStream(InputStream in, boolean doEncode) {
         super(in);
@@ -73,20 +77,20 @@ public Base64InputStream(InputStream in, boolean doEncode) {
     }
 
     /**
-     * Creates a Base64InputStream such that all data read is either
-     * Base64-encoded or Base64-decoded from the original provided InputStream.
-     *
-     * @param in            InputStream to wrap.
-     * @param doEncode      true if we should encode all data read from us,
-     *                      false if we should decode.
-     * @param lineLength    If doEncode is true, each line of encoded
-     *                      data will contain lineLength characters.
-     *                      If lineLength <=0, the encoded data is not divided into lines.
-     *                      If doEncode is false, lineLength is ignored.
-     * @param lineSeparator If doEncode is true, each line of encoded
-     *                      data will be terminated with this byte sequence (e.g. \r\n).
-     *                      If lineLength <= 0, the lineSeparator is not used.  
-     *                      If doEncode is false lineSeparator is ignored.
+     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
+     * provided InputStream.
+     * 
+     * @param in
+     *            InputStream to wrap.
+     * @param doEncode
+     *            true if we should encode all data read from us, false if we should decode.
+     * @param lineLength
+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is
+     *            false, lineLength is ignored.
+     * @param lineSeparator
+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \r\n).
+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
      */
     public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {
         super(in);
@@ -97,8 +101,9 @@ public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[
     /**
      * Reads one <code>byte</code> from this input stream.
      * 
-     * @return the byte as an integer in the range 0 to 255
-     * Returns -1 if EOF has been reached.
+     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     public int read() throws IOException {
         int r = read(singleByte, 0, 1);
@@ -112,18 +117,23 @@ public int read() throws IOException {
     }
 
     /**
-     * Attempts to read <code>len</code> bytes into the specified
-     * <code>b</code> array starting at <code>offset</code> from
-     * this InputStream.
+     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
+     * from this InputStream.
      * 
-     * @param b destination byte array
-     * @param offset where to start writing the bytes
-     * @param len maximum number of bytes to read
+     * @param b
+     *            destination byte array
+     * @param offset
+     *            where to start writing the bytes
+     * @param len
+     *            maximum number of bytes to read
      * 
      * @return number of bytes read
-     * @throws IOException if an I/O error occurs.
-     * @throws NullPointerException if the byte array parameter is null
-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid
+     * @throws IOException
+     *             if an I/O error occurs.
+     * @throws NullPointerException
+     *             if the byte array parameter is null
+     * @throws IndexOutOfBoundsException
+     *             if offset, len or buffer size are invalid
      */
     public int read(byte b[], int offset, int len) throws IOException {
         if (b == null) {
@@ -138,13 +148,11 @@ public int read(byte b[], int offset, int len) throws IOException {
             if (!base64.hasData()) {
                 byte[] buf = new byte[doEncode ? 4096 : 8192];
                 int c = in.read(buf);
-
                 // A little optimization to avoid System.arraycopy()
                 // when possible.
                 if (c > 0 && b.length == len) {
                     base64.setInitialBuffer(b, offset, len);
                 }
-
                 if (doEncode) {
                     base64.encode(buf, 0, c);
                 } else {
@@ -157,6 +165,7 @@ public int read(byte b[], int offset, int len) throws IOException {
 
     /**
      * {@inheritDoc}
+     * 
      * @return false
      */
     public boolean markSupported() {
diff --git a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java
index 50690955d3..349c6429f8 100644
--- a/src/java/org/apache/commons/codec/binary/Base64OutputStream.java
+++ b/src/java/org/apache/commons/codec/binary/Base64OutputStream.java
@@ -22,21 +22,22 @@
 import java.io.OutputStream;
 
 /**
- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size).
- * When encoding the default lineLength is 76 characters and the default
- * lineEnding is CRLF, but these can be overridden by using the appropriate
+ * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength
+ * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
  * constructor.
  * <p>
- * The default behaviour of the Base64OutputStream is to ENCODE, whereas the
- * default behaviour of the Base64InputStream is to DECODE.  But this behaviour
- * can be overridden by using a different constructor.
- * </p><p>
+ * The default behaviour of the Base64OutputStream is to ENCODE, whereas the default behaviour of the Base64InputStream
+ * is to DECODE. But this behaviour can be overridden by using a different constructor.
+ * </p>
+ * <p>
  * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
  * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
- * </p><p>
+ * </p>
+ * <p>
  * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
  * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
- * </p> 
+ * </p>
+ * 
  * @author Apache Software Foundation
  * @version $Id $
  * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
@@ -44,26 +45,29 @@
  */
 public class Base64OutputStream extends FilterOutputStream {
     private final boolean doEncode;
+
     private final Base64 base64;
+
     private final byte[] singleByte = new byte[1];
 
     /**
-     * Creates a Base64OutputStream such that all data written is Base64-encoded
-     * to the original provided OutputStream.
-     *
-     * @param out OutputStream to wrap.
+     * Creates a Base64OutputStream such that all data written is Base64-encoded to the original provided OutputStream.
+     * 
+     * @param out
+     *            OutputStream to wrap.
      */
     public Base64OutputStream(OutputStream out) {
         this(out, true);
     }
 
     /**
-     * Creates a Base64OutputStream such that all data written is either
-     * Base64-encoded or Base64-decoded to the original provided OutputStream.
-     *
-     * @param out      OutputStream to wrap.
-     * @param doEncode true if we should encode all data written to us,
-     *                 false if we should decode.
+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the
+     * original provided OutputStream.
+     * 
+     * @param out
+     *            OutputStream to wrap.
+     * @param doEncode
+     *            true if we should encode all data written to us, false if we should decode.
      */
     public Base64OutputStream(OutputStream out, boolean doEncode) {
         super(out);
@@ -72,20 +76,20 @@ public Base64OutputStream(OutputStream out, boolean doEncode) {
     }
 
     /**
-     * Creates a Base64OutputStream such that all data written is either
-     * Base64-encoded or Base64-decoded to the original provided OutputStream.
-     *
-     * @param out           OutputStream to wrap.
-     * @param doEncode      true if we should encode all data written to us,
-     *                      false if we should decode.
-     * @param lineLength    If doEncode is true, each line of encoded
-     *                      data will contain lineLength characters.  
-     *                      If lineLength <=0, the encoded data is not divided into lines.
-     *                      If doEncode is false, lineLength is ignored.
-     * @param lineSeparator If doEncode is true, each line of encoded
-     *                      data will be terminated with this byte sequence (e.g. \r\n).  
-     *                      If lineLength <= 0, the lineSeparator is not used.
-     *                      If doEncode is false lineSeparator is ignored.
+     * Creates a Base64OutputStream such that all data written is either Base64-encoded or Base64-decoded to the
+     * original provided OutputStream.
+     * 
+     * @param out
+     *            OutputStream to wrap.
+     * @param doEncode
+     *            true if we should encode all data written to us, false if we should decode.
+     * @param lineLength
+     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
+     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is
+     *            false, lineLength is ignored.
+     * @param lineSeparator
+     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \r\n).
+     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
      */
     public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, byte[] lineSeparator) {
         super(out);
@@ -95,6 +99,11 @@ public Base64OutputStream(OutputStream out, boolean doEncode, int lineLength, by
 
     /**
      * Writes the specified <code>byte</code> to this output stream.
+     * 
+     * @param i
+     *            source byte
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     public void write(int i) throws IOException {
         singleByte[0] = (byte) i;
@@ -102,17 +111,22 @@ public void write(int i) throws IOException {
     }
 
     /**
-     * Writes <code>len</code> bytes from the specified
-     * <code>b</code> array starting at <code>offset</code> to
-     * this output stream.
-     *
-     * @param b source byte array
-     * @param offset where to start reading the bytes
-     * @param len maximum number of bytes to write
+     * Writes <code>len</code> bytes from the specified <code>b</code> array starting at <code>offset</code> to this
+     * output stream.
+     * 
+     * @param b
+     *            source byte array
+     * @param offset
+     *            where to start reading the bytes
+     * @param len
+     *            maximum number of bytes to write
      * 
-     * @throws IOException if an I/O error occurs.
-     * @throws NullPointerException if the byte array parameter is null
-     * @throws IndexOutOfBoundsException if offset, len or buffer size are invalid
+     * @throws IOException
+     *             if an I/O error occurs.
+     * @throws NullPointerException
+     *             if the byte array parameter is null
+     * @throws IndexOutOfBoundsException
+     *             if offset, len or buffer size are invalid
      */
     public void write(byte b[], int offset, int len) throws IOException {
         if (b == null) {
@@ -132,13 +146,13 @@ public void write(byte b[], int offset, int len) throws IOException {
     }
 
     /**
-     * Flushes this output stream and forces any buffered output bytes
-     * to be written out to the stream.  If propogate is true, the wrapped
-     * stream will also be flushed.
-     *
-     * @param propogate boolean flag to indicate whether the wrapped
-     *                  OutputStream should also be flushed.
-     * @throws IOException if an I/O error occurs.
+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream. If propogate is
+     * true, the wrapped stream will also be flushed.
+     * 
+     * @param propogate
+     *            boolean flag to indicate whether the wrapped OutputStream should also be flushed.
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     private void flush(boolean propogate) throws IOException {
         int avail = base64.avail();
@@ -155,18 +169,20 @@ private void flush(boolean propogate) throws IOException {
     }
 
     /**
-     * Flushes this output stream and forces any buffered output bytes
-     * to be written out to the stream.
-     *
-     * @throws IOException if an I/O error occurs.
+     * Flushes this output stream and forces any buffered output bytes to be written out to the stream.
+     * 
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     public void flush() throws IOException {
-        flush(true); 
+        flush(true);
     }
 
     /**
-     * Closes this output stream and releases any system resources
-     * associated with the stream.
+     * Closes this output stream and releases any system resources associated with the stream.
+     * 
+     * @throws IOException
+     *             if an I/O error occurs.
      */
     public void close() throws IOException {
         // Notify encoder of EOF (-1).
diff --git a/src/java/org/apache/commons/codec/binary/StringBytesUtils.java b/src/java/org/apache/commons/codec/binary/StringUtils.java
similarity index 84%
rename from src/java/org/apache/commons/codec/binary/StringBytesUtils.java
rename to src/java/org/apache/commons/codec/binary/StringUtils.java
index 18d0a1979e..eb8d2e0855 100644
--- a/src/java/org/apache/commons/codec/binary/StringBytesUtils.java
+++ b/src/java/org/apache/commons/codec/binary/StringUtils.java
@@ -31,7 +31,7 @@
  * @version $Id: $
  * @since 1.4
  */
-public class StringBytesUtils {
+public class StringUtils {
 
     /**
      * Encodes the given string into a sequence of bytes using the ISO-8859-1 charset, storing the result into a new
@@ -46,7 +46,7 @@ public class StringBytesUtils {
      * @see #getSupportedBytes(String, String)
      */
     public static byte[] getBytesIso8859_1(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.ISO_8859_1);
+        return StringUtils.getSupportedBytes(string, CharEncoding.ISO_8859_1);
     }
 
     /**
@@ -62,7 +62,7 @@ public static byte[] getBytesIso8859_1(String string) {
      * @see #getSupportedBytes(String, String)
      */
     public static byte[] getBytesUsAscii(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.US_ASCII);
+        return StringUtils.getSupportedBytes(string, CharEncoding.US_ASCII);
     }
 
     /**
@@ -78,7 +78,7 @@ public static byte[] getBytesUsAscii(String string) {
      * @see #getSupportedBytes(String, String)
      */
     public static byte[] getBytesUtf16(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.UTF_16);
+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16);
     }
 
     /**
@@ -94,7 +94,7 @@ public static byte[] getBytesUtf16(String string) {
      * @see #getSupportedBytes(String, String)
      */
     public static byte[] getBytesUtf16Be(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.UTF_16BE);
+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16BE);
     }
 
     /**
@@ -110,7 +110,7 @@ public static byte[] getBytesUtf16Be(String string) {
      * @see #getSupportedBytes(String, String)
      */
     public static byte[] getBytesUtf16Le(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.UTF_16LE);
+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_16LE);
     }
 
     /**
@@ -126,7 +126,7 @@ public static byte[] getBytesUtf16Le(String string) {
      * @see #getSupportedBytes(String, String)
      */
     public static byte[] getBytesUtf8(String string) {
-        return StringBytesUtils.getSupportedBytes(string, CharEncoding.UTF_8);
+        return StringUtils.getSupportedBytes(string, CharEncoding.UTF_8);
     }
 
     /**
@@ -152,7 +152,7 @@ public static byte[] getSupportedBytes(String string, String charsetName) {
         try {
             return string.getBytes(charsetName);
         } catch (UnsupportedEncodingException e) {
-            throw StringBytesUtils.newIllegalStateException(charsetName, e);
+            throw StringUtils.newIllegalStateException(charsetName, e);
         }
     }
 
@@ -171,6 +171,7 @@ private static IllegalStateException newIllegalStateException(String charsetName
      *            The bytes to be decoded into characters
      * @param charsetName
      *            The name of a required {@link java.nio.charset.Charset}
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
      * @throws IllegalStateException
      *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen for a
      *             required charset name.
@@ -181,7 +182,7 @@ public static String newString(byte[] bytes, String charsetName) {
         try {
             return new String(bytes, charsetName);
         } catch (UnsupportedEncodingException e) {
-            throw StringBytesUtils.newIllegalStateException(charsetName, e);
+            throw StringUtils.newIllegalStateException(charsetName, e);
         }
     }
 
@@ -190,12 +191,13 @@ public static String newString(byte[] bytes, String charsetName) {
      * 
      * @param bytes
      *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
      * @throws IllegalStateException
      *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
      *             charset is required.
      */
     public static String newStringIso8859_1(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.ISO_8859_1);
+        return StringUtils.newString(bytes, CharEncoding.ISO_8859_1);
     }
 
     /**
@@ -203,12 +205,13 @@ public static String newStringIso8859_1(byte[] bytes) {
      * 
      * @param bytes
      *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
      * @throws IllegalStateException
      *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
      *             charset is required.
      */
     public static String newStringUsAscii(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.US_ASCII);
+        return StringUtils.newString(bytes, CharEncoding.US_ASCII);
     }
 
     /**
@@ -216,12 +219,13 @@ public static String newStringUsAscii(byte[] bytes) {
      * 
      * @param bytes
      *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
      * @throws IllegalStateException
      *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
      *             charset is required.
      */
     public static String newStringUtf16(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.UTF_16);
+        return StringUtils.newString(bytes, CharEncoding.UTF_16);
     }
 
     /**
@@ -229,12 +233,13 @@ public static String newStringUtf16(byte[] bytes) {
      * 
      * @param bytes
      *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
      * @throws IllegalStateException
      *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
      *             charset is required.
      */
     public static String newStringUtf16Be(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.UTF_16BE);
+        return StringUtils.newString(bytes, CharEncoding.UTF_16BE);
     }
 
     /**
@@ -242,12 +247,13 @@ public static String newStringUtf16Be(byte[] bytes) {
      * 
      * @param bytes
      *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
      * @throws IllegalStateException
      *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
      *             charset is required.
      */
     public static String newStringUtf16Le(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.UTF_16LE);
+        return StringUtils.newString(bytes, CharEncoding.UTF_16LE);
     }
 
     /**
@@ -255,15 +261,16 @@ public static String newStringUtf16Le(byte[] bytes) {
      * 
      * @param bytes
      *            The bytes to be decoded into characters
+     * @return A new <code>String</code> decoded from the specified array of bytes using the given charset.
      * @throws IllegalStateException
      *             Thrown when a {@link UnsupportedEncodingException} is caught, which should never happen since the
      *             charset is required.
      */
     public static String newStringUtf8(byte[] bytes) {
-        return StringBytesUtils.newString(bytes, CharEncoding.UTF_8);
+        return StringUtils.newString(bytes, CharEncoding.UTF_8);
     }
 
-    private StringBytesUtils() {
-        // noop, cannot instantiate.
+    private StringUtils() {
+        // noop, cannot instantiate. Can always relax later.
     }
 }
diff --git a/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
index ab34516994..9c546f5fee 100644
--- a/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
+++ b/src/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
@@ -28,7 +28,7 @@
 import org.apache.commons.codec.CharEncoding;
 import org.apache.commons.codec.StringDecoder;
 import org.apache.commons.codec.StringEncoder;
-import org.apache.commons.codec.binary.StringBytesUtils;
+import org.apache.commons.codec.binary.StringUtils;
 
 /**
  * <p>
@@ -277,7 +277,7 @@ public String decode(String pString, String charset) throws DecoderException, Un
         if (pString == null) {
             return null;
         }
-        return new String(decode(StringBytesUtils.getBytesUsAscii(pString)), charset);
+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);
     }
 
     /**
@@ -382,6 +382,6 @@ public String encode(String pString, String charset) throws UnsupportedEncodingE
         if (pString == null) {
             return null;
         }
-        return StringBytesUtils.newStringUsAscii(encode(pString.getBytes(charset)));
+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));
     }
 }
diff --git a/src/java/org/apache/commons/codec/net/RFC1522Codec.java b/src/java/org/apache/commons/codec/net/RFC1522Codec.java
index ac0be48034..a33b573a02 100644
--- a/src/java/org/apache/commons/codec/net/RFC1522Codec.java
+++ b/src/java/org/apache/commons/codec/net/RFC1522Codec.java
@@ -21,7 +21,7 @@
 
 import org.apache.commons.codec.DecoderException;
 import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.binary.StringBytesUtils;
+import org.apache.commons.codec.binary.StringUtils;
 
 /**
  * <p>
@@ -76,7 +76,7 @@ protected String encodeText(final String text, final String charset)
         buffer.append(getEncoding()); 
         buffer.append('?');
         byte [] rawdata = doEncoding(text.getBytes(charset)); 
-        buffer.append(StringBytesUtils.newStringUsAscii(rawdata));
+        buffer.append(StringUtils.newStringUsAscii(rawdata));
         buffer.append("?="); 
         return buffer.toString();
     }
@@ -125,7 +125,7 @@ protected String decodeText(final String text)
         }
         from = to + 1;
         to = text.indexOf("?", from);
-        byte[] data = StringBytesUtils.getBytesUsAscii(text.substring(from, to));
+        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));
         data = doDecoding(data); 
         return new String(data, charset);
     }
diff --git a/src/java/org/apache/commons/codec/net/URLCodec.java b/src/java/org/apache/commons/codec/net/URLCodec.java
index 48420037dc..a8599c0c19 100644
--- a/src/java/org/apache/commons/codec/net/URLCodec.java
+++ b/src/java/org/apache/commons/codec/net/URLCodec.java
@@ -28,7 +28,7 @@
 import org.apache.commons.codec.CharEncoding;
 import org.apache.commons.codec.StringDecoder;
 import org.apache.commons.codec.StringEncoder;
-import org.apache.commons.codec.binary.StringBytesUtils;
+import org.apache.commons.codec.binary.StringUtils;
 
 /**
  * <p>Implements the 'www-form-urlencoded' encoding scheme, 
@@ -224,7 +224,7 @@ public String encode(String pString, String charset) throws UnsupportedEncodingE
         if (pString == null) {
             return null;
         }
-        return StringBytesUtils.newStringUsAscii(encode(pString.getBytes(charset)));
+        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));
     }
 
     /**
@@ -265,7 +265,7 @@ public String decode(String pString, String charset) throws DecoderException, Un
         if (pString == null) {
             return null;
         }
-        return new String(decode(StringBytesUtils.getBytesUsAscii(pString)), charset);
+        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);
     }
 
     /**
diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
index 72a147dfbe..b96416fd56 100644
--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -67,23 +67,23 @@ public void testBase64EmptyInputStream() throws Exception {
      */
     public void testBase64InputStreamByChunk() throws Exception {
         // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
+        encoded = StringUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
+        encoded = StringUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
 
@@ -104,23 +104,23 @@ public void testBase64InputStreamByChunk() throws Exception {
      */
     public void testBase64InputStreamByteByByte() throws Exception {
         // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
+        encoded = StringUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
+        encoded = StringUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
 
@@ -250,7 +250,7 @@ private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[
      * @throws Exception
      */
     public void testMarkSupported() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         // Always returns false for now.
@@ -263,7 +263,7 @@ public void testMarkSupported() throws Exception {
      * @throws Exception
      */
     public void testRead0() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         byte[] buf = new byte[1024];
         int bytesRead = 0;
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
@@ -279,7 +279,7 @@ public void testRead0() throws Exception {
      *             for some failure scenarios.
      */
     public void testReadNull() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         try {
@@ -296,7 +296,7 @@ public void testReadNull() throws Exception {
      * @throws Exception
      */
     public void testReadOutOfBounds() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         byte[] buf = new byte[1024];
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
index 83db86ee02..d0c9200a10 100644
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -67,23 +67,23 @@ public void testBase64EmptyOutputStream() throws Exception {
      */
     public void testBase64OutputStreamByChunk() throws Exception {
         // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
+        encoded = StringUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
+        encoded = StringUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
 
@@ -104,23 +104,23 @@ public void testBase64OutputStreamByChunk() throws Exception {
      */
     public void testBase64OutputStreamByteByByte() throws Exception {
         // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] encoded = StringUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringUtils.getBytesUtf8(STRING_FIXTURE);
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
+        encoded = StringUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
+        encoded = StringUtils.getBytesUtf8(Base64TestData.ENCODED_64_CHARS_PER_LINE);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED_64_CHARS_PER_LINE.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
+        encoded = StringUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
 
diff --git a/src/test/org/apache/commons/codec/binary/Base64Test.java b/src/test/org/apache/commons/codec/binary/Base64Test.java
index ed61c8dc9a..43a248f1fa 100644
--- a/src/test/org/apache/commons/codec/binary/Base64Test.java
+++ b/src/test/org/apache/commons/codec/binary/Base64Test.java
@@ -17,7 +17,6 @@
 
 package org.apache.commons.codec.binary;
 
-import java.io.UnsupportedEncodingException;
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.Random;
@@ -30,6 +29,7 @@
 /**
  * Test cases for Base64 class.
  * 
+ * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
  * @author Apache Software Foundation
  * @version $Id$
  */
@@ -66,15 +66,13 @@ public void testBase64() {
 
     /**
      * Tests Base64.encodeBase64().
-     * 
-     * @throws Exception
      */
-    public void testChunkedEncodeMultipleOf76() throws Exception {
+    public void testChunkedEncodeMultipleOf76() {
         byte[] expectedEncode = Base64.encodeBase64(Base64TestData.DECODED, true);
         // convert to "\r\n" so we're equal to the old openssl encoding test stored
         // in Base64TestData.ENCODED_76_CHARS_PER_LINE:
         String actualResult = Base64TestData.ENCODED_76_CHARS_PER_LINE.replaceAll("\n", "\r\n");
-        byte[] actualEncode = actualResult.getBytes("UTF-8");
+        byte[] actualEncode = StringUtils.getBytesUtf8(actualResult);
         assertTrue("chunkedEncodeMultipleOf76", Arrays.equals(expectedEncode, actualEncode));
     }
 
@@ -177,6 +175,28 @@ public void testConstructors() {
         base64 = new Base64(64, new byte[]{' ', '$', '\n', '\r', '\t'}); // OK
     }
 
+    public void testConstructor_Int_ByteArray_Boolean() {
+        Base64 base64 = new Base64(65, new byte[]{'\t'}, false);
+        byte[] encoded = base64.encode(Base64TestData.DECODED);
+        String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;
+        expectedResult = expectedResult.replace('\n', '\t');
+        String result = StringUtils.newStringUtf8(encoded);
+        assertEquals("new Base64(65, \\t, false)", expectedResult, result);
+    }
+
+    public void testConstructor_Int_ByteArray_Boolean_UrlSafe() {
+        // url-safe variation
+        Base64 base64 = new Base64(64, new byte[]{'\t'}, true);
+        byte[] encoded = base64.encode(Base64TestData.DECODED);
+        String expectedResult = Base64TestData.ENCODED_64_CHARS_PER_LINE;
+        expectedResult = expectedResult.replaceAll("=", ""); // url-safe has no == padding.
+        expectedResult = expectedResult.replace('\n', '\t');
+        expectedResult = expectedResult.replace('+', '-');
+        expectedResult = expectedResult.replace('/', '_');
+        String result = StringUtils.newStringUtf8(encoded);
+        assertEquals("new Base64(64, \\t, true)", result, expectedResult);
+    }
+
     /**
      * Tests conditional true branch for "marker0" test.
      */
@@ -414,8 +434,7 @@ public void testObjectDecodeWithInvalidParameter() throws Exception {
     public void testObjectDecodeWithValidParameter() throws Exception {
 
         String original = "Hello World!";
-        byte[] bArray = Base64.encodeBase64(original.getBytes());
-        Object o = bArray;
+        Object o = Base64.encodeBase64(original.getBytes());
 
         Base64 b64 = new Base64();
         Object oDecoded = b64.decode(o);
@@ -438,8 +457,7 @@ public void testObjectEncodeWithInvalidParameter() throws Exception {
     public void testObjectEncodeWithValidParameter() throws Exception {
 
         String original = "Hello World!";
-        byte[] origBytes = original.getBytes();
-        Object origObj = origBytes;
+        Object origObj = original.getBytes();
 
         Base64 b64 = new Base64();
         Object oEncoded = b64.encode(origObj);
@@ -849,8 +867,6 @@ public void testUrlSafe() {
      * 
      * @throws DecoderException
      *             if Hex.decode() fails - a serious problem since Hex comes from our own commons-codec!
-     * @throws UnsupportedEncodingException
-     *             Thrown if "UTF-8" character set is not available, not possible according to Java documentation.
      */
     public void testUUID() throws DecoderException {
         // The 4 UUID's below contains mixtures of + and / to help us test the
@@ -871,31 +887,31 @@ public void testUUID() throws DecoderException {
         ids[3] = Hex.decodeHex("ff7f8fc01cdb471a8c8b5a9306183fe8".toCharArray());
 
         byte[][] standard = new byte[4][];
-        standard[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA==");
-        standard[1] = StringBytesUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA==");
-        standard[2] = StringBytesUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg==");
-        standard[3] = StringBytesUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A==");
+        standard[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg+2dATTcA==");
+        standard[1] = StringUtils.getBytesUtf8("K/fMJwH+Q5e0nr7tWsxwkA==");
+        standard[2] = StringUtils.getBytesUtf8("ZL4VS2/6QCWNGgEojnwxyg==");
+        standard[3] = StringUtils.getBytesUtf8("/3+PwBzbRxqMi1qTBhg/6A==");
 
         byte[][] urlSafe1 = new byte[4][];
         // regular padding (two '==' signs).
-        urlSafe1[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA==");
-        urlSafe1[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA==");
-        urlSafe1[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg==");
-        urlSafe1[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A==");
+        urlSafe1[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA==");
+        urlSafe1[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA==");
+        urlSafe1[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg==");
+        urlSafe1[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A==");
 
         byte[][] urlSafe2 = new byte[4][];
         // single padding (only one '=' sign).
-        urlSafe2[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=");
-        urlSafe2[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=");
-        urlSafe2[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=");
-        urlSafe2[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=");
+        urlSafe2[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA=");
+        urlSafe2[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA=");
+        urlSafe2[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg=");
+        urlSafe2[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A=");
 
         byte[][] urlSafe3 = new byte[4][];
         // no padding (no '=' signs).
-        urlSafe3[0] = StringBytesUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA");
-        urlSafe3[1] = StringBytesUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA");
-        urlSafe3[2] = StringBytesUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg");
-        urlSafe3[3] = StringBytesUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A");
+        urlSafe3[0] = StringUtils.getBytesUtf8("lO2NAxnkSTOZVg-2dATTcA");
+        urlSafe3[1] = StringUtils.getBytesUtf8("K_fMJwH-Q5e0nr7tWsxwkA");
+        urlSafe3[2] = StringUtils.getBytesUtf8("ZL4VS2_6QCWNGgEojnwxyg");
+        urlSafe3[3] = StringUtils.getBytesUtf8("_3-PwBzbRxqMi1qTBhg_6A");
 
         for (int i = 0; i < 4; i++) {
             byte[] encodedStandard = Base64.encodeBase64(ids[i]);
@@ -909,26 +925,26 @@ public void testUUID() throws DecoderException {
             // ever need to delve closely into this stuff.
             if (false) {
                 System.out.println("reference: [" + new String(Hex.encodeHex(ids[i])) + "]");
-                System.out.println("standard:  ["
-                    + new String(Hex.encodeHex(decodedStandard))
-                    + "] From: ["
-                    + StringBytesUtils.newStringUtf8(standard[i])
-                    + "]");
-                System.out.println("safe1:     ["
-                    + new String(Hex.encodeHex(decodedUrlSafe1))
-                    + "] From: ["
-                    + StringBytesUtils.newStringUtf8(urlSafe1[i])
-                    + "]");
-                System.out.println("safe2:     ["
-                    + new String(Hex.encodeHex(decodedUrlSafe2))
-                    + "] From: ["
-                    + StringBytesUtils.newStringUtf8(urlSafe2[i])
-                    + "]");
-                System.out.println("safe3:     ["
-                    + new String(Hex.encodeHex(decodedUrlSafe3))
-                    + "] From: ["
-                    + StringBytesUtils.newStringUtf8(urlSafe3[i])
-                    + "]");
+                System.out.println("standard:  [" +
+                    new String(Hex.encodeHex(decodedStandard)) +
+                    "] From: [" +
+                    StringUtils.newStringUtf8(standard[i]) +
+                    "]");
+                System.out.println("safe1:     [" +
+                    new String(Hex.encodeHex(decodedUrlSafe1)) +
+                    "] From: [" +
+                    StringUtils.newStringUtf8(urlSafe1[i]) +
+                    "]");
+                System.out.println("safe2:     [" +
+                    new String(Hex.encodeHex(decodedUrlSafe2)) +
+                    "] From: [" +
+                    StringUtils.newStringUtf8(urlSafe2[i]) +
+                    "]");
+                System.out.println("safe3:     [" +
+                    new String(Hex.encodeHex(decodedUrlSafe3)) +
+                    "] From: [" +
+                    StringUtils.newStringUtf8(urlSafe3[i]) +
+                    "]");
             }
 
             assertTrue("standard encode uuid", Arrays.equals(encodedStandard, standard[i]));
diff --git a/src/test/org/apache/commons/codec/binary/Base64TestData.java b/src/test/org/apache/commons/codec/binary/Base64TestData.java
index 200077b0a2..f4be0f4bf2 100644
--- a/src/test/org/apache/commons/codec/binary/Base64TestData.java
+++ b/src/test/org/apache/commons/codec/binary/Base64TestData.java
@@ -25,6 +25,7 @@
  * This random data was encoded by OpenSSL. Java had nothing to do with it. This data helps us test interop between
  * Commons-Codec and OpenSSL. Notice that OpenSSL creates 64 character lines instead of the 76 of Commons-Codec.
  * 
+ * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
  * @author Apache Software Foundation
  * @version $Id $
  * @since 1.4
diff --git a/src/test/org/apache/commons/codec/binary/StringBytesUtilsTest.java b/src/test/org/apache/commons/codec/binary/StringUtilsTest.java
similarity index 82%
rename from src/test/org/apache/commons/codec/binary/StringBytesUtilsTest.java
rename to src/test/org/apache/commons/codec/binary/StringUtilsTest.java
index c9af364186..e7a48dd023 100644
--- a/src/test/org/apache/commons/codec/binary/StringBytesUtilsTest.java
+++ b/src/test/org/apache/commons/codec/binary/StringUtilsTest.java
@@ -27,7 +27,7 @@
  * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>
  * @version $Id: $
  */
-public class StringBytesUtilsTest extends TestCase {
+public class StringUtilsTest extends TestCase {
 
     private static byte[] BYTES_FIXTURE;
 
@@ -44,7 +44,7 @@ public void testGetBytesIso8859_1() throws UnsupportedEncodingException {
         String charsetName = "ISO-8859-1";
         testGetSupportedBytes(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesIso8859_1(STRING_FIXTURE);
+        byte[] actual = StringUtils.getBytesIso8859_1(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
@@ -52,7 +52,7 @@ public void testGetBytesUsAscii() throws UnsupportedEncodingException {
         String charsetName = "US-ASCII";
         testGetSupportedBytes(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUsAscii(STRING_FIXTURE);
+        byte[] actual = StringUtils.getBytesUsAscii(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
@@ -60,7 +60,7 @@ public void testGetBytesUtf16() throws UnsupportedEncodingException {
         String charsetName = "UTF-16";
         testGetSupportedBytes(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUtf16(STRING_FIXTURE);
+        byte[] actual = StringUtils.getBytesUtf16(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
@@ -68,7 +68,7 @@ public void testGetBytesUtf16Be() throws UnsupportedEncodingException {
         String charsetName = "UTF-16BE";
         testGetSupportedBytes(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUtf16Be(STRING_FIXTURE);
+        byte[] actual = StringUtils.getBytesUtf16Be(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
@@ -76,7 +76,7 @@ public void testGetBytesUtf16Le() throws UnsupportedEncodingException {
         String charsetName = "UTF-16LE";
         testGetSupportedBytes(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUtf16Le(STRING_FIXTURE);
+        byte[] actual = StringUtils.getBytesUtf16Le(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
@@ -84,19 +84,19 @@ public void testGetBytesUtf8() throws UnsupportedEncodingException {
         String charsetName = "UTF-8";
         testGetSupportedBytes(charsetName);
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
+        byte[] actual = StringUtils.getBytesUtf8(STRING_FIXTURE);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
     private void testGetSupportedBytes(String charsetName) throws UnsupportedEncodingException {
         byte[] expected = STRING_FIXTURE.getBytes(charsetName);
-        byte[] actual = StringBytesUtils.getSupportedBytes(STRING_FIXTURE, charsetName);
+        byte[] actual = StringUtils.getSupportedBytes(STRING_FIXTURE, charsetName);
         Assert.assertTrue(Arrays.equals(expected, actual));
     }
 
     public void testGetSupportedBytesBadEnc() {
         try {
-            StringBytesUtils.getSupportedBytes(STRING_FIXTURE, "UNKNOWN");
+            StringUtils.getSupportedBytes(STRING_FIXTURE, "UNKNOWN");
             Assert.fail("Expected " + IllegalStateException.class.getName());
         } catch (IllegalStateException e) {
             // Expected
@@ -105,13 +105,13 @@ public void testGetSupportedBytesBadEnc() {
 
     private void testNewString(String charsetName) throws UnsupportedEncodingException {
         String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newString(BYTES_FIXTURE, charsetName);
+        String actual = StringUtils.newString(BYTES_FIXTURE, charsetName);
         Assert.assertEquals(expected, actual);
     }
 
     public void testNewStringBadEnc() {
         try {
-            StringBytesUtils.newString(BYTES_FIXTURE, "UNKNOWN");
+            StringUtils.newString(BYTES_FIXTURE, "UNKNOWN");
             Assert.fail("Expected " + IllegalStateException.class.getName());
         } catch (IllegalStateException e) {
             // Expected
@@ -122,7 +122,7 @@ public void testNewStringIso8859_1() throws UnsupportedEncodingException {
         String charsetName = "ISO-8859-1";
         testNewString(charsetName);
         String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringIso8859_1(BYTES_FIXTURE);
+        String actual = StringUtils.newStringIso8859_1(BYTES_FIXTURE);
         Assert.assertEquals(expected, actual);
     }
 
@@ -130,7 +130,7 @@ public void testNewStringUsAscii() throws UnsupportedEncodingException {
         String charsetName = "US-ASCII";
         testNewString(charsetName);
         String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUsAscii(BYTES_FIXTURE);
+        String actual = StringUtils.newStringUsAscii(BYTES_FIXTURE);
         Assert.assertEquals(expected, actual);
     }
 
@@ -138,7 +138,7 @@ public void testNewStringUtf16() throws UnsupportedEncodingException {
         String charsetName = "UTF-16";
         testNewString(charsetName);
         String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUtf16(BYTES_FIXTURE);
+        String actual = StringUtils.newStringUtf16(BYTES_FIXTURE);
         Assert.assertEquals(expected, actual);
     }
 
@@ -146,7 +146,7 @@ public void testNewStringUtf16Be() throws UnsupportedEncodingException {
         String charsetName = "UTF-16BE";
         testNewString(charsetName);
         String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUtf16Be(BYTES_FIXTURE);
+        String actual = StringUtils.newStringUtf16Be(BYTES_FIXTURE);
         Assert.assertEquals(expected, actual);
     }
 
@@ -154,7 +154,7 @@ public void testNewStringUtf16Le() throws UnsupportedEncodingException {
         String charsetName = "UTF-16LE";
         testNewString(charsetName);
         String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUtf16Le(BYTES_FIXTURE);
+        String actual = StringUtils.newStringUtf16Le(BYTES_FIXTURE);
         Assert.assertEquals(expected, actual);
     }
 
@@ -162,7 +162,7 @@ public void testNewStringUtf8() throws UnsupportedEncodingException {
         String charsetName = "UTF-8";
         testNewString(charsetName);
         String expected = new String(BYTES_FIXTURE, charsetName);
-        String actual = StringBytesUtils.newStringUtf8(BYTES_FIXTURE);
+        String actual = StringUtils.newStringUtf8(BYTES_FIXTURE);
         Assert.assertEquals(expected, actual);
     }
 
