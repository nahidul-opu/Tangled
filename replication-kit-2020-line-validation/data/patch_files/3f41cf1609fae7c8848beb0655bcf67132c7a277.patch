From 3f41cf1609fae7c8848beb0655bcf67132c7a277 Mon Sep 17 00:00:00 2001
From: "Gary D. Gregory" <ggregory@apache.org>
Date: Tue, 3 Apr 2012 17:23:55 +0000
Subject: [PATCH] [CODEC-96] Base64 encode() method is no longer thread-safe,
 breaking clients using it as a shared BinaryEncoder

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1309055 13f79535-47bb-0310-9956-ffa450edef68
---
 .../apache/commons/codec/binary/Base32.java   | 194 +++++++++---------
 .../apache/commons/codec/binary/Base64.java   | 112 +++++-----
 .../commons/codec/binary/BaseNCodec.java      | 185 +++++++++--------
 .../codec/binary/BaseNCodecInputStream.java   |  15 +-
 .../codec/binary/BaseNCodecOutputStream.java  |  17 +-
 .../commons/codec/binary/Base32Test.java      |   7 +-
 .../commons/codec/binary/BaseNCodecTest.java  |   4 +-
 7 files changed, 279 insertions(+), 255 deletions(-)

diff --git a/src/main/java/org/apache/commons/codec/binary/Base32.java b/src/main/java/org/apache/commons/codec/binary/Base32.java
index b985f5eca6..2744e37e49 100644
--- a/src/main/java/org/apache/commons/codec/binary/Base32.java
+++ b/src/main/java/org/apache/commons/codec/binary/Base32.java
@@ -33,7 +33,7 @@
  * This class operates directly on byte streams, and not character streams.
  * </p>
  * <p>
- * This class is not thread-safe. Each thread should use its own instance.
+ * This class is thread-safe.
  * </p>
  * 
  * @see <a href="http://www.ietf.org/rfc/rfc4648.txt">RFC 4648</a>
@@ -122,8 +122,6 @@ public class Base32 extends BaseNCodec {
      * Place holder for the bytes we're dealing with for our based logic. 
      * Bitwise operations store and extract the encoding or decoding from this variable.
      */
-    private long bitWorkArea;
-
     /**
      * Convenience variable to help us determine when our buffer is going to run out of room and needs resizing.
      * <code>decodeSize = {@link #BYTES_PER_ENCODED_BLOCK} - 1 + lineSeparator.length;</code>
@@ -275,36 +273,37 @@ public Base32(int lineLength, byte[] lineSeparator, boolean useHex) {
      *            Position to start reading data from.
      * @param inAvail
      *            Amount of bytes available from input for encoding.
+     * @param context the context to be used
      *
      * Output is written to {@link #buffer} as 8-bit octets, using {@link #pos} as the buffer position
      */
     @Override
-    void decode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams
-        if (eof) {
+    void decode(byte[] in, int inPos, int inAvail, Context context) { // package protected for access from I/O streams
+        if (context.eof) {
             return;
         }
         if (inAvail < 0) {
-            eof = true;
+            context.eof = true;
         }
         for (int i = 0; i < inAvail; i++) {
             byte b = in[inPos++];
             if (b == PAD) {
                 // We're done.
-                eof = true;
+                context.eof = true;
                 break;
             } else {
-                ensureBufferSize(decodeSize);
+                ensureBufferSize(decodeSize, context);
                 if (b >= 0 && b < this.decodeTable.length) {
                     int result = this.decodeTable[b];
                     if (result >= 0) {
-                        modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK;
-                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes
-                        if (modulus == 0) { // we can output the 5 bytes
-                            buffer[pos++] = (byte) ((bitWorkArea >> 32) & MASK_8BITS);
-                            buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
-                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
-                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
-                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
+                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;
+                        context.lbitWorkArea = (context.lbitWorkArea << BITS_PER_ENCODED_BYTE) + result; // collect decoded bytes
+                        if (context.modulus == 0) { // we can output the 5 bytes
+                            context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 32) & MASK_8BITS);
+                            context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
+                            context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
+                            context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
+                            context.buffer[context.pos++] = (byte) (context.lbitWorkArea & MASK_8BITS);
                         }
                     }
                 }
@@ -314,40 +313,40 @@ void decode(byte[] in, int inPos, int inAvail) { // package protected for access
         // Two forms of EOF as far as Base32 decoder is concerned: actual
         // EOF (-1) and first time '=' character is encountered in stream.
         // This approach makes the '=' padding characters completely optional.
-        if (eof && modulus >= 2) { // if modulus < 2, nothing to do
-            ensureBufferSize(decodeSize);
+        if (context.eof && context.modulus >= 2) { // if modulus < 2, nothing to do
+            ensureBufferSize(decodeSize, context);
     
             //  we ignore partial bytes, i.e. only multiples of 8 count
-            switch (modulus) {
+            switch (context.modulus) {
                 case 2 : // 10 bits, drop 2 and output one byte
-                    buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
                     break;
                 case 3 : // 15 bits, drop 7 and output 1 byte
-                    buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
                     break;
                 case 4 : // 20 bits = 2*8 + 4
-                    bitWorkArea = bitWorkArea >> 4; // drop 4 bits
-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
+                    context.lbitWorkArea = context.lbitWorkArea >> 4; // drop 4 bits
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                     break;
                 case 5 : // 25bits = 3*8 + 1
-                    bitWorkArea = bitWorkArea >> 1;
-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
+                    context.lbitWorkArea = context.lbitWorkArea >> 1;
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                     break;
                 case 6 : // 30bits = 3*8 + 6
-                    bitWorkArea = bitWorkArea >> 6;
-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
+                    context.lbitWorkArea = context.lbitWorkArea >> 6;
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                     break;
                 case 7 : // 35 = 4*8 +3
-                    bitWorkArea = bitWorkArea >> 3;
-                    buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
+                    context.lbitWorkArea = context.lbitWorkArea >> 3;
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
                     break;
             }
         }
@@ -366,93 +365,94 @@ void decode(byte[] in, int inPos, int inAvail) { // package protected for access
      *            Position to start reading data from.
      * @param inAvail
      *            Amount of bytes available from input for encoding.
+     * @param context the context to be used
      */
     @Override
-    void encode(byte[] in, int inPos, int inAvail) { // package protected for access from I/O streams
-        if (eof) {
+    void encode(byte[] in, int inPos, int inAvail, Context context) { // package protected for access from I/O streams
+        if (context.eof) {
             return;
         }
         // inAvail < 0 is how we're informed of EOF in the underlying data we're
         // encoding.
         if (inAvail < 0) {
-            eof = true;
-            if (0 == modulus && lineLength == 0) {
+            context.eof = true;
+            if (0 == context.modulus && lineLength == 0) {
                 return; // no leftovers to process and not using chunking
             }
-            ensureBufferSize(encodeSize);
-            int savedPos = pos;
-            switch (modulus) { // % 5
+            ensureBufferSize(encodeSize, context);
+            int savedPos = context.pos;
+            switch (context.modulus) { // % 5
                 case 1 : // Only 1 octet; take top 5 bits then remainder
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; // 5-3=2
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 3) & MASK_5BITS]; // 8-1*5 = 3
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea << 2) & MASK_5BITS]; // 5-3=2
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
                     break;
     
                 case 2 : // 2 octets = 16 bits to use
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 11) & MASK_5BITS]; // 16-1*5 = 11
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  6) & MASK_5BITS]; // 16-2*5 = 6
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  1) & MASK_5BITS]; // 16-3*5 = 1
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  4) & MASK_5BITS]; // 5-1 = 4
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
                     break;
                 case 3 : // 3 octets = 24 bits to use
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
-                    buffer[pos++] = PAD;
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 19) & MASK_5BITS]; // 24-1*5 = 19
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 14) & MASK_5BITS]; // 24-2*5 = 14
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  9) & MASK_5BITS]; // 24-3*5 = 9
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  4) & MASK_5BITS]; // 24-4*5 = 4
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  1) & MASK_5BITS]; // 5-4 = 1
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
+                    context.buffer[context.pos++] = PAD;
                     break;
                 case 4 : // 4 octets = 32 bits to use
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3
-                    buffer[pos++] = PAD;
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 27) & MASK_5BITS]; // 32-1*5 = 27
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 22) & MASK_5BITS]; // 32-2*5 = 22
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 17) & MASK_5BITS]; // 32-3*5 = 17
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 12) & MASK_5BITS]; // 32-4*5 = 12
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  7) & MASK_5BITS]; // 32-5*5 =  7
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >>  2) & MASK_5BITS]; // 32-6*5 =  2
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea <<  3) & MASK_5BITS]; // 5-2 = 3
+                    context.buffer[context.pos++] = PAD;
                     break;
             }
-            currentLinePos += pos - savedPos; // keep track of current line position
+            context.currentLinePos += context.pos - savedPos; // keep track of current line position
             // if currentPos == 0 we are at the start of a line, so don't add CRLF
-            if (lineLength > 0 && currentLinePos > 0){ // add chunk separator if required
-                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
-                pos += lineSeparator.length;
+            if (lineLength > 0 && context.currentLinePos > 0){ // add chunk separator if required
+                System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
+                context.pos += lineSeparator.length;
             }            
         } else {
             for (int i = 0; i < inAvail; i++) {
-                ensureBufferSize(encodeSize);
-                modulus = (modulus+1) % BYTES_PER_UNENCODED_BLOCK;
+                ensureBufferSize(encodeSize, context);
+                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;
                 int b = in[inPos++];
                 if (b < 0) {
                     b += 256;
                 }
-                bitWorkArea = (bitWorkArea << 8) + b; // BITS_PER_BYTE
-                if (0 == modulus) { // we have enough bytes to create our output 
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 35) & MASK_5BITS];
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 30) & MASK_5BITS];
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 25) & MASK_5BITS];
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 20) & MASK_5BITS];
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 15) & MASK_5BITS];
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 10) & MASK_5BITS];
-                    buffer[pos++] = encodeTable[(int)(bitWorkArea >> 5) & MASK_5BITS];
-                    buffer[pos++] = encodeTable[(int)bitWorkArea & MASK_5BITS];
-                    currentLinePos += BYTES_PER_ENCODED_BLOCK;
-                    if (lineLength > 0 && lineLength <= currentLinePos) {
-                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
-                        pos += lineSeparator.length;
-                        currentLinePos = 0;
+                context.lbitWorkArea = (context.lbitWorkArea << 8) + b; // BITS_PER_BYTE
+                if (0 == context.modulus) { // we have enough bytes to create our output 
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 35) & MASK_5BITS];
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 30) & MASK_5BITS];
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 25) & MASK_5BITS];
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 20) & MASK_5BITS];
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 15) & MASK_5BITS];
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 10) & MASK_5BITS];
+                    context.buffer[context.pos++] = encodeTable[(int)(context.lbitWorkArea >> 5) & MASK_5BITS];
+                    context.buffer[context.pos++] = encodeTable[(int)context.lbitWorkArea & MASK_5BITS];
+                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
+                    if (lineLength > 0 && lineLength <= context.currentLinePos) {
+                        System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
+                        context.pos += lineSeparator.length;
+                        context.currentLinePos = 0;
                     }
                 }
             }
diff --git a/src/main/java/org/apache/commons/codec/binary/Base64.java b/src/main/java/org/apache/commons/codec/binary/Base64.java
index aa2672730b..b81151b5ec 100644
--- a/src/main/java/org/apache/commons/codec/binary/Base64.java
+++ b/src/main/java/org/apache/commons/codec/binary/Base64.java
@@ -40,7 +40,7 @@
  * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
  * </p>
  * <p>
- * This class is not thread-safe. Each thread should use its own instance.
+ * This class is thread-safe.
  * </p>
  * 
  * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
@@ -155,12 +155,6 @@ public class Base64 extends BaseNCodec {
      */
     private final int encodeSize;
 
-    /**
-     * Place holder for the bytes we're dealing with for our based logic. 
-     * Bitwise operations store and extract the encoding or decoding from this variable.
-     */
-    private int bitWorkArea;
-
     /**
      * Creates a Base64 codec used for decoding (all modes) and encoding in URL-unsafe mode.
      * <p>
@@ -321,67 +315,68 @@ public boolean isUrlSafe() {
      *            Position to start reading data from.
      * @param inAvail
      *            Amount of bytes available from input for encoding.
+     * @param context the context to be used
      */
     @Override
-    void encode(byte[] in, int inPos, int inAvail) {
-        if (eof) {
+    void encode(byte[] in, int inPos, int inAvail, Context context) {
+        if (context.eof) {
             return;
         }
         // inAvail < 0 is how we're informed of EOF in the underlying data we're
         // encoding.
         if (inAvail < 0) {
-            eof = true;
-            if (0 == modulus && lineLength == 0) {
+            context.eof = true;
+            if (0 == context.modulus && lineLength == 0) {
                 return; // no leftovers to process and not using chunking
             }
-            ensureBufferSize(encodeSize);
-            int savedPos = pos;
-            switch (modulus) { // 0-2
+            ensureBufferSize(encodeSize, context);
+            int savedPos = context.pos;
+            switch (context.modulus) { // 0-2
                 case 1 : // 8 bits = 6 + 2
-                    buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; // top 6 bits
-                    buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; // remaining 2 
+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS]; // top 6 bits
+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS]; // remaining 2 
                     // URL-SAFE skips the padding to further reduce size.
                     if (encodeTable == STANDARD_ENCODE_TABLE) {
-                        buffer[pos++] = PAD;
-                        buffer[pos++] = PAD;
+                        context.buffer[context.pos++] = PAD;
+                        context.buffer[context.pos++] = PAD;
                     }
                     break;
 
                 case 2 : // 16 bits = 6 + 6 + 4
-                    buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
-                    buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
-                    buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
                     // URL-SAFE skips the padding to further reduce size.
                     if (encodeTable == STANDARD_ENCODE_TABLE) {
-                        buffer[pos++] = PAD;
+                        context.buffer[context.pos++] = PAD;
                     }
                     break;
             }
-            currentLinePos += pos - savedPos; // keep track of current line position
+            context.currentLinePos += context.pos - savedPos; // keep track of current line position
             // if currentPos == 0 we are at the start of a line, so don't add CRLF
-            if (lineLength > 0 && currentLinePos > 0) { 
-                System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
-                pos += lineSeparator.length;
+            if (lineLength > 0 && context.currentLinePos > 0) { 
+                System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
+                context.pos += lineSeparator.length;
             }
         } else {
             for (int i = 0; i < inAvail; i++) {
-                ensureBufferSize(encodeSize);
-                modulus = (modulus+1) % BYTES_PER_UNENCODED_BLOCK;
+                ensureBufferSize(encodeSize, context);
+                context.modulus = (context.modulus+1) % BYTES_PER_UNENCODED_BLOCK;
                 int b = in[inPos++];
                 if (b < 0) {
                     b += 256;
                 }
-                bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE
-                if (0 == modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract
-                    buffer[pos++] = encodeTable[(bitWorkArea >> 18) & MASK_6BITS];
-                    buffer[pos++] = encodeTable[(bitWorkArea >> 12) & MASK_6BITS];
-                    buffer[pos++] = encodeTable[(bitWorkArea >> 6) & MASK_6BITS];
-                    buffer[pos++] = encodeTable[bitWorkArea & MASK_6BITS];
-                    currentLinePos += BYTES_PER_ENCODED_BLOCK;
-                    if (lineLength > 0 && lineLength <= currentLinePos) {
-                        System.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);
-                        pos += lineSeparator.length;
-                        currentLinePos = 0;
+                context.ibitWorkArea = (context.ibitWorkArea << 8) + b; //  BITS_PER_BYTE
+                if (0 == context.modulus) { // 3 bytes = 24 bits = 4 * 6 bits to extract
+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 18) & MASK_6BITS];
+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 12) & MASK_6BITS];
+                    context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 6) & MASK_6BITS];
+                    context.buffer[context.pos++] = encodeTable[context.ibitWorkArea & MASK_6BITS];
+                    context.currentLinePos += BYTES_PER_ENCODED_BLOCK;
+                    if (lineLength > 0 && lineLength <= context.currentLinePos) {
+                        System.arraycopy(lineSeparator, 0, context.buffer, context.pos, lineSeparator.length);
+                        context.pos += lineSeparator.length;
+                        context.currentLinePos = 0;
                     }
                 }
             }
@@ -410,32 +405,33 @@ void encode(byte[] in, int inPos, int inAvail) {
      *            Position to start reading data from.
      * @param inAvail
      *            Amount of bytes available from input for encoding.
+     * @param context the context to be used
      */
     @Override
-    void decode(byte[] in, int inPos, int inAvail) {
-        if (eof) {
+    void decode(byte[] in, int inPos, int inAvail, Context context) {
+        if (context.eof) {
             return;
         }
         if (inAvail < 0) {
-            eof = true;
+            context.eof = true;
         }
         for (int i = 0; i < inAvail; i++) {
-            ensureBufferSize(decodeSize);
+            ensureBufferSize(decodeSize, context);
             byte b = in[inPos++];
             if (b == PAD) {
                 // We're done.
-                eof = true;
+                context.eof = true;
                 break;
             } else {
                 if (b >= 0 && b < DECODE_TABLE.length) {
                     int result = DECODE_TABLE[b];
                     if (result >= 0) {
-                        modulus = (modulus+1) % BYTES_PER_ENCODED_BLOCK;
-                        bitWorkArea = (bitWorkArea << BITS_PER_ENCODED_BYTE) + result;
-                        if (modulus == 0) {
-                            buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
-                            buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
-                            buffer[pos++] = (byte) (bitWorkArea & MASK_8BITS);
+                        context.modulus = (context.modulus+1) % BYTES_PER_ENCODED_BLOCK;
+                        context.ibitWorkArea = (context.ibitWorkArea << BITS_PER_ENCODED_BYTE) + result;
+                        if (context.modulus == 0) {
+                            context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 16) & MASK_8BITS);
+                            context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
+                            context.buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);
                         }
                     }
                 }
@@ -445,22 +441,22 @@ void decode(byte[] in, int inPos, int inAvail) {
         // Two forms of EOF as far as base64 decoder is concerned: actual
         // EOF (-1) and first time '=' character is encountered in stream.
         // This approach makes the '=' padding characters completely optional.
-        if (eof && modulus != 0) {
-            ensureBufferSize(decodeSize);
+        if (context.eof && context.modulus != 0) {
+            ensureBufferSize(decodeSize, context);
             
             // We have some spare bits remaining
             // Output all whole multiples of 8 bits and ignore the rest
-            switch (modulus) {
+            switch (context.modulus) {
            //   case 1: // 6 bits - ignore entirely
            //       break;
                 case 2 : // 12 bits = 8 + 4
-                    bitWorkArea = bitWorkArea >> 4; // dump the extra 4 bits
-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
+                    context.ibitWorkArea = context.ibitWorkArea >> 4; // dump the extra 4 bits
+                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
                     break;
                 case 3 : // 18 bits = 8 + 8 + 2
-                    bitWorkArea = bitWorkArea >> 2; // dump 2 bits
-                    buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
-                    buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
+                    context.ibitWorkArea = context.ibitWorkArea >> 2; // dump 2 bits
+                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
+                    context.buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
                     break;
             }
         }
diff --git a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java
index 1f2f1e7040..0fb839f537 100644
--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java
+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodec.java
@@ -26,12 +26,69 @@
  * Abstract superclass for Base-N encoders and decoders.
  *
  * <p>
- * This class is not thread-safe.
- * Each thread should use its own instance.
+ * This class is thread-safe.
  * </p>
  */
 public abstract class BaseNCodec implements BinaryEncoder, BinaryDecoder {
 
+    /**
+     * Holds thread context so classes can be thread-safe.
+     * 
+     * This class is not itself thread-safe; each thread must allocate its own copy.
+     * 
+     * @since 1.7
+     */
+    static class Context {
+
+        /**
+         * Place holder for the bytes we're dealing with for our based logic. 
+         * Bitwise operations store and extract the encoding or decoding from this variable.
+         */
+        int ibitWorkArea;
+
+        /**
+         * Place holder for the bytes we're dealing with for our based logic. 
+         * Bitwise operations store and extract the encoding or decoding from this variable.
+         */
+        long lbitWorkArea;
+
+        /**
+         * Buffer for streaming.
+         */
+        byte[] buffer;
+
+        /**
+         * Position where next character should be written in the buffer.
+         */
+        int pos;
+
+        /**
+         * Position where next character should be read from the buffer.
+         */
+        int readPos;
+
+        /**
+         * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,
+         * and must be thrown away.
+         */
+        boolean eof;
+
+        /**
+         * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to
+         * make sure each encoded line never goes beyond lineLength (if lineLength > 0).
+         */
+        int currentLinePos;
+
+        /**
+         * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding.
+         * This variable helps track that.
+         */
+        int modulus;
+
+        Context() {
+        }
+    }
+
     /**
      * EOF
      * 
@@ -99,39 +156,6 @@ public abstract class BaseNCodec implements BinaryEncoder, BinaryDecoder {
      */
     private final int chunkSeparatorLength;
 
-    /**
-     * Buffer for streaming.
-     */
-    protected byte[] buffer;
-
-    /**
-     * Position where next character should be written in the buffer.
-     */
-    protected int pos;
-
-    /**
-     * Position where next character should be read from the buffer.
-     */
-    private int readPos;
-
-    /**
-     * Boolean flag to indicate the EOF has been reached. Once EOF has been reached, this object becomes useless,
-     * and must be thrown away.
-     */
-    protected boolean eof;
-
-    /**
-     * Variable tracks how many characters have been written to the current line. Only used when encoding. We use it to
-     * make sure each encoded line never goes beyond lineLength (if lineLength > 0).
-     */
-    protected int currentLinePos;
-
-    /**
-     * Writes to the buffer only occur after every 3/5 reads when encoding, and every 4/8 reads when decoding.
-     * This variable helps track that.
-     */
-    protected int modulus;
-
     /**
      * Note <code>lineLength</code> is rounded down to the nearest multiple of {@link #encodedBlockSize}
      * If <code>chunkSeparatorLength</code> is zero, then chunking is disabled.
@@ -150,19 +174,21 @@ protected BaseNCodec(int unencodedBlockSize, int encodedBlockSize, int lineLengt
     /**
      * Returns true if this object has buffered data for reading.
      *
+     * @param context the context to be used
      * @return true if there is data still available for reading.
      */
-    boolean hasData() {  // package protected for access from I/O streams
-        return this.buffer != null;
+    boolean hasData(Context context) {  // package protected for access from I/O streams
+        return context.buffer != null;
     }
 
     /**
      * Returns the amount of buffered data available for reading.
      *
+     * @param context the context to be used
      * @return The amount of buffered data available for reading.
      */
-    int available() {  // package protected for access from I/O streams
-        return buffer != null ? pos - readPos : 0;
+    int available(Context context) {  // package protected for access from I/O streams
+        return context.buffer != null ? context.pos - context.readPos : 0;
     }
 
     /**
@@ -174,16 +200,19 @@ protected int getDefaultBufferSize() {
         return DEFAULT_BUFFER_SIZE;
     }
 
-    /** Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}. */
-    private void resizeBuffer() {
-        if (buffer == null) {
-            buffer = new byte[getDefaultBufferSize()];
-            pos = 0;
-            readPos = 0;
+    /** 
+     * Increases our buffer by the {@link #DEFAULT_BUFFER_RESIZE_FACTOR}.
+     * @param context the context to be used
+     */
+    private void resizeBuffer(Context context) {
+        if (context.buffer == null) {
+            context.buffer = new byte[getDefaultBufferSize()];
+            context.pos = 0;
+            context.readPos = 0;
         } else {
-            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
-            System.arraycopy(buffer, 0, b, 0, buffer.length);
-            buffer = b;
+            byte[] b = new byte[context.buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];
+            System.arraycopy(context.buffer, 0, b, 0, context.buffer.length);
+            context.buffer = b;
         }
     }
 
@@ -191,10 +220,11 @@ private void resizeBuffer() {
      * Ensure that the buffer has room for <code>size</code> bytes
      *
      * @param size minimum spare space required
+     * @param context the context to be used
      */
-    protected void ensureBufferSize(int size){
-        if ((buffer == null) || (buffer.length < pos + size)){
-            resizeBuffer();
+    protected void ensureBufferSize(int size, Context context){
+        if ((context.buffer == null) || (context.buffer.length < context.pos + size)){
+            resizeBuffer(context);
         }
     }
 
@@ -208,19 +238,20 @@ protected void ensureBufferSize(int size){
      *            position in byte[] array to start extraction at.
      * @param bAvail
      *            amount of bytes we're allowed to extract. We may extract fewer (if fewer are available).
+     * @param context the context to be used
      * @return The number of bytes successfully extracted into the provided byte[] array.
      */
-    int readResults(byte[] b, int bPos, int bAvail) {  // package protected for access from I/O streams
-        if (buffer != null) {
-            int len = Math.min(available(), bAvail);
-            System.arraycopy(buffer, readPos, b, bPos, len);
-            readPos += len;
-            if (readPos >= pos) {
-                buffer = null; // so hasData() will return false, and this method can return -1
+    int readResults(byte[] b, int bPos, int bAvail, Context context) {  // package protected for access from I/O streams
+        if (context.buffer != null) {
+            int len = Math.min(available(context), bAvail);
+            System.arraycopy(context.buffer, context.readPos, b, bPos, len);
+            context.readPos += len;
+            if (context.readPos >= context.pos) {
+                context.buffer = null; // so hasData() will return false, and this method can return -1
             }
             return len;
         }
-        return eof ? EOF : 0;
+        return context.eof ? EOF : 0;
     }
 
     /**
@@ -242,18 +273,6 @@ protected static boolean isWhiteSpace(byte byteToCheck) {
         }
     }
 
-    /**
-     * Resets this object to its initial newly constructed state.
-     */
-    private void reset() {
-        buffer = null;
-        pos = 0;
-        readPos = 0;
-        currentLinePos = 0;
-        modulus = 0;
-        eof = false;
-    }
-
     /**
      * Encodes an Object using the Base-N algorithm. This method is provided in order to satisfy the requirements of the
      * Encoder interface, and will throw an EncoderException if the supplied object is not of type byte[].
@@ -321,14 +340,14 @@ public byte[] decode(String pArray) {
      * @return a byte array containing binary data
      */
     public byte[] decode(byte[] pArray) {
-        reset();
+        Context context = new Context();
         if (pArray == null || pArray.length == 0) {
             return pArray;
         }
-        decode(pArray, 0, pArray.length);
-        decode(pArray, 0, EOF); // Notify decoder of EOF.
-        byte[] result = new byte[pos];
-        readResults(result, 0, result.length);
+        decode(pArray, 0, pArray.length, context);
+        decode(pArray, 0, EOF, context); // Notify decoder of EOF.
+        byte[] result = new byte[context.pos];
+        readResults(result, 0, result.length, context);
         return result;
     }
 
@@ -340,14 +359,14 @@ public byte[] decode(byte[] pArray) {
      * @return A byte array containing only the basen alphabetic character data
      */
     public byte[] encode(byte[] pArray) {
-        reset();        
+        Context context = new Context();
         if (pArray == null || pArray.length == 0) {
             return pArray;
         }
-        encode(pArray, 0, pArray.length);
-        encode(pArray, 0, EOF); // Notify encoder of EOF.
-        byte[] buf = new byte[pos - readPos];
-        readResults(buf, 0, buf.length);
+        encode(pArray, 0, pArray.length, context);
+        encode(pArray, 0, EOF, context); // Notify encoder of EOF.
+        byte[] buf = new byte[context.pos - context.readPos];
+        readResults(buf, 0, buf.length, context);
         return buf;
     }
     
@@ -362,9 +381,9 @@ public String encodeAsString(byte[] pArray){
         return StringUtils.newStringUtf8(encode(pArray));
     }
 
-    abstract void encode(byte[] pArray, int i, int length);  // package protected for access from I/O streams
+    abstract void encode(byte[] pArray, int i, int length, Context context);  // package protected for access from I/O streams
 
-    abstract void decode(byte[] pArray, int i, int length); // package protected for access from I/O streams
+    abstract void decode(byte[] pArray, int i, int length, Context context); // package protected for access from I/O streams
     
     /**
      * Returns whether or not the <code>octet</code> is in the current alphabet.
diff --git a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
index 88c658e38d..e0db4bba93 100644
--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
@@ -23,6 +23,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 
+import org.apache.commons.codec.binary.BaseNCodec.Context;
+
 /**
  * Abstract superclass for Base-N input streams.
  * 
@@ -36,6 +38,8 @@ public class BaseNCodecInputStream extends FilterInputStream {
 
     private final byte[] singleByte = new byte[1];
 
+    private Context context = new Context();
+
     protected BaseNCodecInputStream(InputStream in, BaseNCodec baseNCodec, boolean doEncode) {
         super(in);
         this.doEncode = doEncode;
@@ -55,8 +59,7 @@ public int available() throws IOException {
         //       data available. As we do not know for sure how much data is left,
         //       just return 1 as a safe guess.
 
-        // use the EOF flag of the underlying codec instance
-        return baseNCodec.eof ? 0 : 1;
+        return context.eof ? 0 : 1;
     }
 
     /**
@@ -148,16 +151,16 @@ public int read(byte b[], int offset, int len) throws IOException {
              This is a fix for CODEC-101
             */
             while (readLen == 0) {
-                if (!baseNCodec.hasData()) {
+                if (!baseNCodec.hasData(context)) {
                     byte[] buf = new byte[doEncode ? 4096 : 8192];
                     int c = in.read(buf);
                     if (doEncode) {
-                        baseNCodec.encode(buf, 0, c);
+                        baseNCodec.encode(buf, 0, c, context);
                     } else {
-                        baseNCodec.decode(buf, 0, c);
+                        baseNCodec.decode(buf, 0, c, context);
                     }
                 }
-                readLen = baseNCodec.readResults(b, offset, len);
+                readLen = baseNCodec.readResults(b, offset, len, context);
             }
             return readLen;
         }
diff --git a/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java b/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java
index 51a027d742..885e7f0687 100644
--- a/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java
+++ b/src/main/java/org/apache/commons/codec/binary/BaseNCodecOutputStream.java
@@ -23,6 +23,8 @@
 import java.io.IOException;
 import java.io.OutputStream;
 
+import org.apache.commons.codec.binary.BaseNCodec.Context;
+
 /**
  * Abstract superclass for Base-N output streams.
  * 
@@ -36,6 +38,9 @@ public class BaseNCodecOutputStream extends FilterOutputStream {
 
     private final byte[] singleByte = new byte[1];
 
+    private Context context = new Context();
+
+    // TODO should this be protected?
     public BaseNCodecOutputStream(OutputStream out, BaseNCodec basedCodec, boolean doEncode) {
         super(out);
         this.baseNCodec = basedCodec;
@@ -84,9 +89,9 @@ public void write(byte b[], int offset, int len) throws IOException {
             throw new IndexOutOfBoundsException();
         } else if (len > 0) {
             if (doEncode) {
-                baseNCodec.encode(b, offset, len);
+                baseNCodec.encode(b, offset, len, context);
             } else {
-                baseNCodec.decode(b, offset, len);
+                baseNCodec.decode(b, offset, len, context);
             }
             flush(false);
         }
@@ -102,10 +107,10 @@ public void write(byte b[], int offset, int len) throws IOException {
      *             if an I/O error occurs.
      */
     private void flush(boolean propogate) throws IOException {
-        int avail = baseNCodec.available();
+        int avail = baseNCodec.available(context);
         if (avail > 0) {
             byte[] buf = new byte[avail];
-            int c = baseNCodec.readResults(buf, 0, avail);
+            int c = baseNCodec.readResults(buf, 0, avail, context);
             if (c > 0) {
                 out.write(buf, 0, c);
             }
@@ -136,9 +141,9 @@ public void flush() throws IOException {
     public void close() throws IOException {
         // Notify encoder of EOF (-1).
         if (doEncode) {
-            baseNCodec.encode(singleByte, 0, EOF);
+            baseNCodec.encode(singleByte, 0, EOF, context);
         } else {
-            baseNCodec.decode(singleByte, 0, EOF);
+            baseNCodec.decode(singleByte, 0, EOF, context);
         }
         flush();
         out.close();
diff --git a/src/test/java/org/apache/commons/codec/binary/Base32Test.java b/src/test/java/org/apache/commons/codec/binary/Base32Test.java
index 81088ec5c3..87851a8888 100644
--- a/src/test/java/org/apache/commons/codec/binary/Base32Test.java
+++ b/src/test/java/org/apache/commons/codec/binary/Base32Test.java
@@ -87,15 +87,16 @@ public void testBase32Chunked () throws Exception {
     public void testSingleCharEncoding() {
         for (int i = 0; i < 20; i++) {
             Base32 codec = new Base32();
+            BaseNCodec.Context context = new BaseNCodec.Context();
             byte unencoded[] = new byte[i];
             byte allInOne[] = codec.encode(unencoded);
             codec = new Base32();
             for (int j=0; j< unencoded.length; j++) {
-                codec.encode(unencoded, j, 1);
+                codec.encode(unencoded, j, 1, context);
             }
-            codec.encode(unencoded, 0, -1);
+            codec.encode(unencoded, 0, -1, context);
             byte singly[] = new byte[allInOne.length];
-            codec.readResults(singly, 0, 100);
+            codec.readResults(singly, 0, 100, context);
             if (!Arrays.equals(allInOne, singly)){
                 fail();
             }
diff --git a/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java b/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java
index 36a86ed8af..bbbb60d4aa 100644
--- a/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java
+++ b/src/test/java/org/apache/commons/codec/binary/BaseNCodecTest.java
@@ -38,11 +38,11 @@ protected boolean isInAlphabet(byte b) {
             }
             
             @Override
-            void encode(byte[] pArray, int i, int length) {
+            void encode(byte[] pArray, int i, int length, Context context) {
             }
             
             @Override
-            void decode(byte[] pArray, int i, int length) {
+            void decode(byte[] pArray, int i, int length, Context context) {
             }
         };        
     }
