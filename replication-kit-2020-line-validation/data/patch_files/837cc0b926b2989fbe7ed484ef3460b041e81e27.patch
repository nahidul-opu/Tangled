From 837cc0b926b2989fbe7ed484ef3460b041e81e27 Mon Sep 17 00:00:00 2001
From: Damjan Jovanovic <damjan@apache.org>
Date: Sun, 2 Dec 2012 09:57:49 +0000
Subject: [PATCH] When not in strict mode, allow errors when reading
 subdirectory tags (and ignore the tags in that case).

Jira issue key: IMAGING-90



git-svn-id: https://svn.apache.org/repos/asf/commons/proper/imaging/trunk@1416148 13f79535-47bb-0310-9956-ffa450edef68
---
 .../imaging/formats/png/PngConstants.java     |   2 +
 .../imaging/formats/png/PngWriter.java        | 154 ++++++++++--------
 .../TransparencyFilterIndexedColor.java       |  12 +-
 .../imaging/formats/tiff/TiffReader.java      |  72 ++++----
 .../imaging/palette/MedianCutQuantizer.java   |  38 ++++-
 .../imaging/palette/PaletteFactory.java       |   2 +-
 .../images/tiff/6/bad-interoperability.asm    | 115 +++++++++++++
 .../images/tiff/6/bad-interoperability.tiff   | Bin 0 -> 136 bytes
 8 files changed, 265 insertions(+), 130 deletions(-)
 create mode 100644 src/test/data/images/tiff/6/bad-interoperability.asm
 create mode 100644 src/test/data/images/tiff/6/bad-interoperability.tiff

diff --git a/src/main/java/org/apache/commons/imaging/formats/png/PngConstants.java b/src/main/java/org/apache/commons/imaging/formats/png/PngConstants.java
index 2ee6e2dd0..70f1af800 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/PngConstants.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/PngConstants.java
@@ -28,6 +28,8 @@ public interface PngConstants extends ImagingConstants {
             new byte[] { 73, 72, 68, 82 });
     public final static BinaryConstant PLTE_CHUNK_TYPE = new BinaryConstant(
             new byte[] { 80, 76, 84, 69 });
+    public final static BinaryConstant TRNS_CHUNK_TYPE = new BinaryConstant(
+            new byte[] { 't', 'R', 'N', 'S'});
     public final static BinaryConstant IEND_CHUNK_TYPE = new BinaryConstant(
             new byte[] { 73, 69, 78, 68 });
     public final static BinaryConstant IDAT_CHUNK_TYPE = new BinaryConstant(
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java b/src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java
index 05605469b..871abf76a 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/PngWriter.java
@@ -48,22 +48,20 @@ public PngWriter(Map<String,Object> params) {
     }
 
     /*
-     * 1. IHDR: image header, which is the first chunk in a PNG datastream. 2.
-     * PLTE: palette table associated with indexed PNG images. 3. IDAT: image
-     * data chunks. 4. IEND: image trailer, which is the last chunk in a PNG
-     * datastream.
-     * 
-     * The remaining 14 chunk types are termed ancillary chunk types, which
-     * encoders may generate and decoders may interpret.
-     * 
-     * 1. Transparency information: tRNS (see 11.3.2: Transparency information).
-     * 2. Colour space information: cHRM, gAMA, iCCP, sBIT, sRGB (see 11.3.3:
-     * Colour space information). 3. Textual information: iTXt, tEXt, zTXt (see
-     * 11.3.4: Textual information). 4. Miscellaneous information: bKGD, hIST,
-     * pHYs, sPLT (see 11.3.5: Miscellaneous information). 5. Time information:
-     * tIME (see 11.3.6: Time stamp information).
-     */
-
+     1. IHDR: image header, which is the first chunk in a PNG datastream.
+     2. PLTE: palette table associated with indexed PNG images.
+     3. IDAT: image data chunks.
+     4. IEND: image trailer, which is the last chunk in a PNG datastream.
+
+     The remaining 14 chunk types are termed ancillary chunk types, which encoders may generate and decoders may interpret.
+
+     1. Transparency information: tRNS (see 11.3.2: Transparency information).
+     2. Colour space information: cHRM, gAMA, iCCP, sBIT, sRGB (see 11.3.3: Colour space information).
+     3. Textual information: iTXt, tEXt, zTXt (see 11.3.4: Textual information).
+     4. Miscellaneous information: bKGD, hIST, pHYs, sPLT (see 11.3.5: Miscellaneous information).
+     5. Time information: tIME (see 11.3.6: Time stamp information).
+    */
+    
     private final void writeInt(OutputStream os, int value) throws IOException {
         os.write(0xff & (value >> 24));
         os.write(0xff & (value >> 16));
@@ -80,26 +78,14 @@ private final void writeChunk(OutputStream os, byte chunkType[],
             os.write(data);
         }
 
-        // Debug.debug("writeChunk chunkType", chunkType);
-        // Debug.debug("writeChunk data", data);
-
-        {
-            PngCrc png_crc = new PngCrc();
-
-            long crc1 = png_crc.start_partial_crc(chunkType, chunkType.length);
-            long crc2 = data == null ? crc1 : png_crc.continue_partial_crc(
-                    crc1, data, data.length);
-            int crc = (int) png_crc.finish_partial_crc(crc2);
+        PngCrc png_crc = new PngCrc();
 
-            // Debug.debug("crc1", crc1 + " (" + Long.toHexString(crc1)
-            // + ")");
-            // Debug.debug("crc2", crc2 + " (" + Long.toHexString(crc2)
-            // + ")");
-            // Debug.debug("crc3", crc + " (" + Integer.toHexString(crc)
-            // + ")");
+        long crc1 = png_crc.start_partial_crc(chunkType, chunkType.length);
+        long crc2 = data == null ? crc1 : png_crc.continue_partial_crc(
+                crc1, data, data.length);
+        int crc = (int) png_crc.finish_partial_crc(crc2);
 
-            writeInt(os, crc);
-        }
+        writeInt(os, crc);
     }
 
     private static class ImageHeader {
@@ -264,6 +250,16 @@ private void writeChunkPLTE(OutputStream os, Palette palette)
 
         writeChunk(os, PLTE_CHUNK_TYPE.toByteArray(), bytes);
     }
+    
+    private void writeChunkTRNS(OutputStream os, Palette palette) throws IOException {
+        byte[] bytes = new byte[palette.length()];
+        
+        for (int i = 0; i < bytes.length; i++) {
+            bytes[i] = (byte) (0xff & (palette.getEntry(i) >> 24));
+        }
+        
+        writeChunk(os, TRNS_CHUNK_TYPE.toByteArray(), bytes);
+    }
 
     private void writeChunkIEND(OutputStream os) throws IOException {
         writeChunk(os, IEND_CHUNK_TYPE.toByteArray(), null);
@@ -348,21 +344,33 @@ private byte getBitDepth(final byte colorType, Map<String,Object> params) {
     }
 
     /*
-     * between two chunk types indicates alternatives. Table 5.3 — Chunk
-     * ordering rules Critical chunks (shall appear in this order, except PLTE
-     * is optional) Chunk name Multiple allowed Ordering constraints IHDR No
-     * Shall be first PLTE No Before first IDAT IDAT Yes Multiple IDAT chunks
-     * shall be consecutive IEND No Shall be last Ancillary chunks (need not
-     * appear in this order) Chunk name Multiple allowed Ordering constraints
-     * cHRM No Before PLTE and IDAT gAMA No Before PLTE and IDAT iCCP No Before
-     * PLTE and IDAT. If the iCCP chunk is present, the sRGB chunk should not be
-     * present. sBIT No Before PLTE and IDAT sRGB No Before PLTE and IDAT. If
-     * the sRGB chunk is present, the iCCP chunk should not be present. bKGD No
-     * After PLTE; before IDAT hIST No After PLTE; before IDAT tRNS No After
-     * PLTE; before IDAT pHYs No Before IDAT sPLT Yes Before IDAT tIME No None
-     * iTXt Yes None tEXt Yes None zTXt Yes None
-     */
-
+     between two chunk types indicates alternatives.
+     Table 5.3 â€” Chunk ordering rules Critical chunks
+     (shall appear in this order, except PLTE is optional)
+     Chunk name     Multiple allowed    Ordering constraints
+     IHDR   No  Shall be first
+     PLTE   No  Before first IDAT
+     IDAT   Yes     Multiple IDAT chunks shall be consecutive
+     IEND   No  Shall be last
+     Ancillary chunks
+     (need not appear in this order)
+     Chunk name     Multiple allowed    Ordering constraints
+     cHRM   No  Before PLTE and IDAT
+     gAMA   No  Before PLTE and IDAT
+     iCCP   No  Before PLTE and IDAT. If the iCCP chunk is present, the sRGB chunk should not be present.
+     sBIT   No  Before PLTE and IDAT
+     sRGB   No  Before PLTE and IDAT. If the sRGB chunk is present, the iCCP chunk should not be present.
+     bKGD   No  After PLTE; before IDAT
+     hIST   No  After PLTE; before IDAT
+     tRNS   No  After PLTE; before IDAT
+     pHYs   No  Before IDAT
+     sPLT   Yes     Before IDAT
+     tIME   No  None
+     iTXt   Yes     None
+     tEXt   Yes     None
+     zTXt   Yes     None
+    */
+    
     public void writeImage(BufferedImage src, OutputStream os, Map<String,Object> params)
             throws ImageWriteException, IOException {
         // make copy of params; we'll clear keys as we consume them.
@@ -480,29 +488,25 @@ public void writeImage(BufferedImage src, OutputStream os, Map<String,Object> pa
         if (colorType == COLOR_TYPE_INDEXED_COLOR) {
             // PLTE No Before first IDAT
 
-            int max_colors = hasAlpha ? 255 : 256;
-
-            palette = new MedianCutQuantizer(true).process(src, max_colors,
+            palette = new MedianCutQuantizer(!hasAlpha).process(src, 256,
                     verbose);
-            // Palette palette2 = new PaletteFactory().makePaletteSimple(src,
-            // max_colors);
-
-            // palette.dump();
-
             writeChunkPLTE(os, palette);
+            if (hasAlpha) {
+                writeChunkTRNS(os, palette);
+            }
         }
 
         Object pixelDensityObj = params.get(PARAM_KEY_PIXEL_DENSITY);
         if (pixelDensityObj instanceof PixelDensity) {
             PixelDensity pixelDensity = (PixelDensity) pixelDensityObj;
             if (pixelDensity.isUnitless()) {
-                writeChunkPHYS(os, (int) Math.round(pixelDensity
-                        .getRawHorizontalDensity()),
+                writeChunkPHYS(os,
+                        (int) Math.round(pixelDensity.getRawHorizontalDensity()),
                         (int) Math.round(pixelDensity.getRawVerticalDensity()),
                         (byte) 0);
             } else {
-                writeChunkPHYS(os, (int) Math.round(pixelDensity
-                        .horizontalDensityMetres()),
+                writeChunkPHYS(os,
+                        (int) Math.round(pixelDensity.horizontalDensityMetres()),
                         (int) Math.round(pixelDensity.verticalDensityMetres()),
                         (byte) 1);
             }
@@ -628,16 +632,24 @@ public void writeImage(BufferedImage src, OutputStream os, Map<String,Object> pa
         }
 
         /*
-         * Ancillary chunks (need not appear in this order) Chunk name Multiple
-         * allowed Ordering constraints cHRM No Before PLTE and IDAT gAMA No
-         * Before PLTE and IDAT iCCP No Before PLTE and IDAT. If the iCCP chunk
-         * is present, the sRGB chunk should not be present. sBIT No Before PLTE
-         * and IDAT sRGB No Before PLTE and IDAT. If the sRGB chunk is present,
-         * the iCCP chunk should not be present. bKGD No After PLTE; before IDAT
-         * hIST No After PLTE; before IDAT tRNS No After PLTE; before IDAT pHYs
-         * No Before IDAT sPLT Yes Before IDAT tIME No None iTXt Yes None tEXt
-         * Yes None zTXt Yes None
-         */
+         Ancillary chunks
+         (need not appear in this order)
+         Chunk name     Multiple allowed    Ordering constraints
+         cHRM           No                  Before PLTE and IDAT
+         gAMA           No                  Before PLTE and IDAT
+         iCCP           No                  Before PLTE and IDAT. If the iCCP chunk is present, the sRGB chunk should not be present.
+         sBIT           No                  Before PLTE and IDAT
+         sRGB           No                  Before PLTE and IDAT. If the sRGB chunk is present, the iCCP chunk should not be present.
+         bKGD           No                  After PLTE; before IDAT
+         hIST           No                  After PLTE; before IDAT
+         tRNS           No                  After PLTE; before IDAT
+         pHYs           No                  Before IDAT
+         sPLT           Yes                 Before IDAT
+         tIME           No                  None
+         iTXt           Yes                 None
+         tEXt           Yes                 None
+         zTXt           Yes                 None
+        */
 
         os.close();
     } // todo: filter types
diff --git a/src/main/java/org/apache/commons/imaging/formats/png/transparencyfilters/TransparencyFilterIndexedColor.java b/src/main/java/org/apache/commons/imaging/formats/png/transparencyfilters/TransparencyFilterIndexedColor.java
index c68d85c7a..99b940ba1 100644
--- a/src/main/java/org/apache/commons/imaging/formats/png/transparencyfilters/TransparencyFilterIndexedColor.java
+++ b/src/main/java/org/apache/commons/imaging/formats/png/transparencyfilters/TransparencyFilterIndexedColor.java
@@ -26,27 +26,19 @@ public TransparencyFilterIndexedColor(byte bytes[]) {
         super(bytes);
     }
 
-    int count = 0;
-
     @Override
     public int filter(int rgb, int index) throws ImageReadException,
             IOException {
         if (index >= bytes.length) {
             return rgb;
-        }
-
-        if ((index < 0) || (index > bytes.length)) {
+        } else if (index < 0) {
             throw new ImageReadException(
-                    "TransparencyFilterIndexedColor index: " + index
-                            + ", bytes.length: " + bytes.length);
+                    "Invalid TransparencyFilterIndexedColor index: " + index);
         }
 
         int alpha = bytes[index];
         int result = ((0xff & alpha) << 24) | (0x00ffffff & rgb);
 
-        if ((count < 100) && (index > 0)) {
-            count++;
-        }
         return result;
     }
 }
diff --git a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java
index 743b291b6..14e7de7bd 100644
--- a/src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java
+++ b/src/main/java/org/apache/commons/imaging/formats/tiff/TiffReader.java
@@ -32,6 +32,7 @@
 import org.apache.commons.imaging.formats.tiff.constants.ExifTagConstants;
 import org.apache.commons.imaging.formats.tiff.constants.TiffConstants;
 import org.apache.commons.imaging.formats.tiff.constants.TiffTagConstants;
+import org.apache.commons.imaging.formats.tiff.taginfos.TagInfoLong;
 import org.apache.commons.imaging.util.Debug;
 
 public class TiffReader extends BinaryFileParser implements TiffConstants {
@@ -245,48 +246,39 @@ private boolean readDirectory(ByteSource byteSource, int offset,
             }
 
             if (listener.readOffsetDirectories()) {
-                List<TiffField> fieldsToRemove = new ArrayList<TiffField>();
-                for (int j = 0; j < fields.size(); j++) {
-                    TiffField entry = fields.get(j);
-
-                    if (entry.tag == ExifTagConstants.EXIF_TAG_EXIF_OFFSET.tag
-                            || entry.tag == ExifTagConstants.EXIF_TAG_GPSINFO.tag
-                            || entry.tag == ExifTagConstants.EXIF_TAG_INTEROP_OFFSET.tag) { /*
-                                                                                             * do
-                                                                                             * nothing
-                                                                                             */
-                    } else {
-                        continue;
-                    }
-
-                    int subDirectoryOffset = ((Number) entry.getValue())
-                            .intValue();
-                    int subDirectoryType;
-                    if (entry.tag == ExifTagConstants.EXIF_TAG_EXIF_OFFSET.tag) {
-                        subDirectoryType = TiffDirectory.DIRECTORY_TYPE_EXIF;
-                    } else if (entry.tag == ExifTagConstants.EXIF_TAG_GPSINFO.tag) {
-                        subDirectoryType = TiffDirectory.DIRECTORY_TYPE_GPS;
-                    } else if (entry.tag == ExifTagConstants.EXIF_TAG_INTEROP_OFFSET.tag) {
-                        subDirectoryType = TiffDirectory.DIRECTORY_TYPE_INTEROPERABILITY;
-                    } else {
-                        throw new ImageReadException(
-                                "Unknown subdirectory type.");
-                    }
-
-                    // Debug.debug("sub dir", subDirectoryOffset);
-                    boolean subDirectoryRead = readDirectory(byteSource,
-                            subDirectoryOffset, subDirectoryType,
-                            formatCompliance, listener, true, visited);
-
-                    if (!subDirectoryRead) {
-                        // Offset field pointed to invalid location.
-                        // This is a bug in certain cameras. Ignore offset
-                        // field.
-                        fieldsToRemove.add(entry);
+                final TagInfoLong[] offsetFields = {
+                        EXIF_TAG_EXIF_OFFSET,
+                        EXIF_TAG_GPSINFO,
+                        EXIF_TAG_INTEROP_OFFSET
+                };
+                final int[] directoryTypes = {
+                        TiffDirectory.DIRECTORY_TYPE_EXIF,
+                        TiffDirectory.DIRECTORY_TYPE_GPS,
+                        TiffDirectory.DIRECTORY_TYPE_INTEROPERABILITY
+                };
+                for (int i = 0; i < offsetFields.length; i++) {
+                    TagInfoLong offsetField = offsetFields[i];
+                    if (directory.findField(offsetField) != null) {
+                        int subDirectoryOffset;
+                        int subDirectoryType;
+                        boolean subDirectoryRead = false;
+                        try {
+                            subDirectoryOffset = directory.getSingleFieldValue(offsetField);
+                            subDirectoryType = directoryTypes[i];
+                            subDirectoryRead = readDirectory(byteSource,
+                                    subDirectoryOffset, subDirectoryType,
+                                    formatCompliance, listener, true, visited);
+    
+                        } catch (ImageReadException imageReadException) {
+                            if (strict) {
+                                throw imageReadException;
+                            }
+                        }
+                        if (!subDirectoryRead) {
+                            fields.remove(offsetField);
+                        }
                     }
-
                 }
-                fields.removeAll(fieldsToRemove);
             }
 
             if (!ignoreNextDirectory && directory.nextDirectoryOffset > 0) {
diff --git a/src/main/java/org/apache/commons/imaging/palette/MedianCutQuantizer.java b/src/main/java/org/apache/commons/imaging/palette/MedianCutQuantizer.java
index 4c159896b..059ab05ee 100644
--- a/src/main/java/org/apache/commons/imaging/palette/MedianCutQuantizer.java
+++ b/src/main/java/org/apache/commons/imaging/palette/MedianCutQuantizer.java
@@ -21,8 +21,10 @@
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import org.apache.commons.imaging.ImageWriteException;
 import org.apache.commons.imaging.util.Debug;
@@ -89,6 +91,7 @@ private class ColorGroup {
 
         public final int max_diff;
         public final int diff_total;
+        public final int totalPoints;
 
         public ColorGroup(final List<ColorCount> color_counts)
                 throws ImageWriteException {
@@ -98,8 +101,10 @@ public ColorGroup(final List<ColorCount> color_counts)
                 throw new ImageWriteException("empty color_group");
             }
 
+            int totalPoints = 0;
             for (int i = 0; i < color_counts.size(); i++) {
                 ColorCount color = color_counts.get(i);
+                totalPoints += color.count;
 
                 min_alpha = Math.min(min_alpha, color.alpha);
                 max_alpha = Math.max(max_alpha, color.alpha);
@@ -110,6 +115,7 @@ public ColorGroup(final List<ColorCount> color_counts)
                 min_blue = Math.min(min_blue, color.blue);
                 max_blue = Math.max(max_blue, color.blue);
             }
+            this.totalPoints = totalPoints;
 
             alpha_diff = max_alpha - min_alpha;
             red_diff = max_red - min_red;
@@ -271,21 +277,37 @@ public Palette process(BufferedImage image, int max_colors, boolean verbose)
 
         final Comparator<ColorGroup> comparator = new Comparator<ColorGroup>() {
             public int compare(ColorGroup cg1, ColorGroup cg2) {
-                if (cg1.max_diff == cg2.max_diff) {
-                    return cg2.diff_total - cg1.diff_total;
-                }
-                return cg2.max_diff - cg1.max_diff;
+                return cg2.totalPoints - cg1.totalPoints;
+//                if (cg1.max_diff == cg2.max_diff) {
+//                    return cg2.diff_total - cg1.diff_total;
+//                }
+//                return cg2.max_diff - cg1.max_diff;
             }
         };
 
+        Set<ColorGroup> ignore = new HashSet<ColorGroup>();
         while (color_groups.size() < max_colors) {
             Collections.sort(color_groups, comparator);
 
             ColorGroup color_group = color_groups.get(0);
-
-            if (color_group.max_diff == 0) {
-                break;
-            }
+//            if (color_group.max_diff == 0) {
+//                for (ColorGroup c : color_groups) {
+//                    System.out.println("max_diff: " + c.max_diff);
+//                }
+//                break;
+//            }
+            
+//            ColorGroup color_group = null;
+//            for (ColorGroup c : color_groups) {
+//                if (c.max_diff > 0) {
+//                    color_group = c;
+//                    break;
+//                }
+//            }
+//            if (color_group == null) {
+//                break;
+//            }
+            
             if (!ignoreAlpha
                     && color_group.alpha_diff > color_group.red_diff
                     && color_group.alpha_diff > color_group.green_diff
diff --git a/src/main/java/org/apache/commons/imaging/palette/PaletteFactory.java b/src/main/java/org/apache/commons/imaging/palette/PaletteFactory.java
index ec0cd82d0..287a96b3d 100644
--- a/src/main/java/org/apache/commons/imaging/palette/PaletteFactory.java
+++ b/src/main/java/org/apache/commons/imaging/palette/PaletteFactory.java
@@ -334,7 +334,7 @@ private List<ColorSpaceSubset> divide(List<ColorSpaceSubset> v,
      * Builds an inexact opaque palette of at most {@code max} colors in {@code src}
      * using a variation of the Median Cut algorithm. Accurate to 6 bits per component,
      * and works by splitting the color bounding box most heavily populated by colors
-     * along the component which splits the colors most evenly.
+     * along the component which splits the colors in that box most evenly.
      * @param src the image whose palette to build
      * @param max the maximum number of colors the palette can contain
      * @return the palette of at most {@code max} colors
diff --git a/src/test/data/images/tiff/6/bad-interoperability.asm b/src/test/data/images/tiff/6/bad-interoperability.asm
new file mode 100644
index 000000000..08acdce9a
--- /dev/null
+++ b/src/test/data/images/tiff/6/bad-interoperability.asm
@@ -0,0 +1,115 @@
+; Licensed to the Apache Software Foundation (ASF) under one
+; or more contributor license agreements.  See the NOTICE file
+; distributed with this work for additional information
+; regarding copyright ownership.  The ASF licenses this file
+; to you under the Apache License, Version 2.0 (the
+; "License"); you may not use this file except in compliance
+; with the License.  You may obtain a copy of the License at
+;
+;    http://www.apache.org/licenses/LICENSE-2.0
+;
+; Unless required by applicable law or agreed to in writing,
+; software distributed under the License is distributed on an
+; "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+; KIND, either express or implied.  See the License for the
+; specific language governing permissions and limitations
+; under the License.
+
+
+; Assemblers are the perfect tool for generating
+; custom test images as they let us insert offsets
+; to unknown locations easily and totally
+; customize the file byte-by-byte.
+;
+; To generate a TIFF from this, run:
+; nasm -f bin /path/to/this/file.asm -o /path/to/file.tiff
+
+; TIFF header
+db 0x49,0x49
+db 0x2a, 0x00
+db 0x08, 0x00, 0x00, 0x00
+
+; Number of directory entries
+dw 8
+
+; entry 0: tag, type, count, value
+dw 0x0100 ; tag = image width
+dw 3 ; type = short
+dd 1 ; length = 1
+dd 2 ; value = 2
+
+; entry 1
+dw 0x0101 ; tag = image length
+dw 3 ; type = short
+dd 1 ; length = 1
+dd 2 ; value = 2
+
+; entry 2
+dw 0x0103 ; tag = compression
+dw 3
+dd 1
+dd 1 ; no compression, but pack bits tightly
+
+; entry 3
+dw 0x0106 ; tag = PhotometricInterpretation
+dw 3
+dd 1
+dd 1 ; black is zero
+
+; entry 4
+dw 0x0111 ; tag = StripOffsets
+dw 4 ; type = long
+dd 1
+dd $imageStrip1
+
+; entry 5
+dw 0x0117 ; tag = StripByteCounts
+dw 4 ; type = long
+dd 1
+dd 2
+
+; entry 6
+dw 0x0116 ; tag = RowsPerStrip
+dw 4 ; type = long
+dd 1
+dd 2
+
+; entry 7
+dw 0x8769 ; tag = EXIF
+dw 4 ; type = long
+dd 1
+dd $exif
+
+; offset to next directory
+dd 0
+
+
+; values that couldn't fit:
+
+
+; image data
+imageStrip1:
+db 0x80, 0x40
+
+
+; EXIF
+
+exif:
+; number of directory entries:
+dw 1
+
+; entry 0
+dw 0xA005 ; tag = Interoperability
+dw  4 ; type = long
+dd 0 ; bad count of 0
+dd $interoperability
+
+; offset to next directory
+dd 0
+
+interoperability:
+; number of directory entries
+dw 0
+
+; offset to next directory
+dd 0
diff --git a/src/test/data/images/tiff/6/bad-interoperability.tiff b/src/test/data/images/tiff/6/bad-interoperability.tiff
new file mode 100644
index 0000000000000000000000000000000000000000..870b86c61308b63d4eb75f6c92626f0479441694
GIT binary patch
literal 136
zcmebD)MDUZU;tr8W(GzeiwTGsk=V>oHb{;Qi7m*;0#=^~6c>lGL3+iI*qQARH3dL%
T5NL2<WMEyu0%kXXNf-eD3}6KW

literal 0
HcmV?d00001

