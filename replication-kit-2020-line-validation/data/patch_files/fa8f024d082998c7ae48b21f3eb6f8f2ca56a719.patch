From fa8f024d082998c7ae48b21f3eb6f8f2ca56a719 Mon Sep 17 00:00:00 2001
From: cduffy <cduffy@unknown>
Date: Thu, 19 Dec 2013 21:14:39 +0000
Subject: [PATCH] IVY-1454 handle multi-threading (as opposed to only
 multi-process) case in locking

git-svn-id: https://svn.apache.org/repos/asf/ant/ivy/core/trunk@1552434 13f79535-47bb-0310-9956-ffa450edef68
---
 .../plugins/lock/FileBasedLockStrategy.java   | 177 +++++++++++++++---
 .../org/apache/ivy/ant/IvyResolveTest.java    |  22 ++-
 test/repositories/ivysettings-with-nio.xml    |  50 +++++
 3 files changed, 218 insertions(+), 31 deletions(-)
 create mode 100644 test/repositories/ivysettings-with-nio.xml

diff --git a/src/java/org/apache/ivy/plugins/lock/FileBasedLockStrategy.java b/src/java/org/apache/ivy/plugins/lock/FileBasedLockStrategy.java
index 56165d45a..7e04751a9 100644
--- a/src/java/org/apache/ivy/plugins/lock/FileBasedLockStrategy.java
+++ b/src/java/org/apache/ivy/plugins/lock/FileBasedLockStrategy.java
@@ -21,8 +21,11 @@
 import java.io.IOException;
 import java.io.RandomAccessFile;
 import java.nio.channels.FileLock;
+import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 import org.apache.ivy.util.Message;
 
@@ -37,8 +40,13 @@ public abstract class FileBasedLockStrategy extends AbstractLockStrategy {
     private FileLocker locker;
     
     private long timeout = DEFAULT_TIMEOUT;
-    
-    private Map/*<File, Integer>*/ currentLockCounters = new HashMap();
+
+    /**
+     * Lock counter list must be static: locks are implicitly shared to the
+     * entire process, so the list too much be.
+     */
+    private static ConcurrentMap/*<File, Map<Thread, Integer>>*/ currentLockHolders
+        = new ConcurrentHashMap();
     
     protected FileBasedLockStrategy() {
         this(new CreateFileLocker(false), false);
@@ -53,40 +61,68 @@ protected FileBasedLockStrategy(FileLocker locker, boolean debugLocking) {
         this.locker = locker;
     }
 
-        
     protected boolean acquireLock(File file) throws InterruptedException {
+        Thread currentThread = Thread.currentThread();
         if (isDebugLocking()) {
             debugLocking("acquiring lock on " + file);
         }
         long start = System.currentTimeMillis();
         do {
-            synchronized (this) {
-                if (hasLock(file)) {
-                    int holdLocks = incrementLock(file);
+            synchronized (currentLockHolders) {
+                if (isDebugLocking()) {
+                    debugLocking("entered synchronized area (locking)");
+                }
+                int lockCount = hasLock(file, currentThread);
+                if (isDebugLocking()) {
+                    debugLocking("current status for " + file
+                        + " is " + lockCount
+                        + " held locks: "
+                        + getCurrentLockHolderNames(file));
+                }
+                if (lockCount < 0) {
+                    /* Another thread in this process holds the lock; we need to wait */
+                    if (isDebugLocking()) {
+                        debugLocking("waiting for another thread to release the lock: "
+                                + getCurrentLockHolderNames(file));
+                    }
+                } else if (lockCount > 0) {
+                    int holdLocks = incrementLock(file, currentThread);
                     if (isDebugLocking()) {
                         debugLocking("reentrant lock acquired on " + file 
                             + " in " + (System.currentTimeMillis() - start) + "ms"
                             + " - hold locks = " + holdLocks);
                     }
                     return true;
-                }
-                if (locker.tryLock(file)) {
-                    if (isDebugLocking()) {
-                        debugLocking("lock acquired on " + file 
-                            + " in " + (System.currentTimeMillis() - start) + "ms");
+                } else {
+                    /* No prior lock on this file is held at all */
+                    if (locker.tryLock(file)) {
+                        if (isDebugLocking()) {
+                            debugLocking("lock acquired on " + file 
+                                + " in " + (System.currentTimeMillis() - start) + "ms");
+                        }
+                        incrementLock(file, currentThread);
+                        return true;                        
                     }
-                    incrementLock(file);
-                    return true;
                 }
             }
+            if (isDebugLocking()) {
+                debugLocking("failed to acquire lock; sleeping for retry...");
+            }
             Thread.sleep(SLEEP_TIME);
         } while (System.currentTimeMillis() - start < timeout);
         return false;
     }
 
     protected void releaseLock(File file) {
-        synchronized (this) {
-            int holdLocks = decrementLock(file);
+        Thread currentThread = Thread.currentThread();
+        if (isDebugLocking()) {
+            debugLocking("releasing lock on " + file);
+        }
+        synchronized (currentLockHolders) {
+            if (isDebugLocking()) {
+                debugLocking("entered synchronized area (unlocking)");
+            }
+            int holdLocks = decrementLock(file, currentThread);
             if (holdLocks == 0) {
                 locker.unlock(file);
                 if (isDebugLocking()) {
@@ -106,25 +142,105 @@ private static void debugLocking(String msg) {
         Message.info(Thread.currentThread() + " " + System.currentTimeMillis() + " " + msg);
     }
 
-    private boolean hasLock(File file) {
-        Integer c = (Integer) currentLockCounters.get(file);
-        return c != null && c.intValue() > 0;
+    /** Determine the state of the lockfile.
+     * 
+     * Must be called from within a synchronized block.
+     * 
+     * Three possibilities exist:
+     *  - The lock is held by the current thread (>0)
+     *  - The lock is held by one or more different threads (-1)
+     *  - The lock is not held at all (0).
+     * 
+     * @param file file to lock
+     * @param forThread thread for which lock status is being queried
+     */
+    private int hasLock(File file, Thread forThread) {
+        Map locksPerThread = (Map) currentLockHolders.get(file);
+        if (locksPerThread == null) {
+            return 0;
+        }
+        if (locksPerThread.isEmpty()) {
+            return 0;
+        }
+        Integer counterObj = (Integer) locksPerThread.get(forThread);
+        int counter = counterObj == null ? 0 : counterObj.intValue();
+        if (counter > 0) {
+            return counter;
+        } else {
+            return -1;
+        }
     }
     
-    private int incrementLock(File file) {
-        Integer c = (Integer) currentLockCounters.get(file);
-        int holdLocks = c == null ? 1 : c.intValue() + 1;
-        currentLockCounters.put(file, new Integer(holdLocks));
+    /** Record that this thread holds the lock.
+     * 
+     * Asserts that the lock has been previously grabbed by this thread.
+     * Must be called from a synchronized block in which the lock was grabbed. 
+     * 
+     * @param file file which has been locked
+     * @param forThread thread for which locking occurred
+     * @return number of times this thread has grabbed the lock
+     */
+    private int incrementLock(File file, Thread forThread) {
+        Map locksPerThread = (Map) currentLockHolders.get(file);
+        if (locksPerThread == null) {
+            locksPerThread = new ConcurrentHashMap();
+            currentLockHolders.put(file, locksPerThread);
+        }
+        Integer c = (Integer) locksPerThread.get(forThread);
+        int holdLocks = c == null ? 1 : c.intValue() + 1; 
+        locksPerThread.put(forThread, new Integer(holdLocks));
         return holdLocks;
     }
-
-    private int decrementLock(File file) {
-        Integer c = (Integer) currentLockCounters.get(file);
-        int dc = c == null ? 0 : c.intValue() - 1;
-        currentLockCounters.put(file, new Integer(dc));
-        return dc;
+    
+    /** Decrease depth of this thread's lock.
+     * 
+     * Must be called within a synchronized block.
+     * 
+     * If this returns 0, the caller is responsible for releasing the lock
+     * within that same block. 
+     * 
+     * @param file file for which lock depth is being decreased
+     * @param forThread thread for which lock depth is being decreased
+     * @return remaining depth of this lock
+     */
+    private int decrementLock(File file, Thread forThread) {
+        ConcurrentHashMap locksPerThread = (ConcurrentHashMap) currentLockHolders.get(file);
+        if (locksPerThread == null) {
+            throw new RuntimeException("Calling decrementLock on a thread which holds no locks");
+        }
+        Integer c = (Integer) locksPerThread.get(forThread);
+        int oldHeldLocks = c == null ? 0 : c.intValue();
+        if (oldHeldLocks <= 0) {
+            throw new RuntimeException("Calling decrementLock on a thread which holds no locks");
+        }
+        int newHeldLocks = oldHeldLocks - 1;
+        if (newHeldLocks > 0) {
+            locksPerThread.put(forThread, new Integer(newHeldLocks));
+        } else {
+            locksPerThread.remove(forThread);
+        }
+        return newHeldLocks;
     }
 
+    /** Return a string naming the threads which currently hold this lock.
+     */
+    protected String getCurrentLockHolderNames(File file) {
+        StringBuilder sb = new StringBuilder();
+        ConcurrentHashMap m = (ConcurrentHashMap) currentLockHolders.get(file);
+        if (m == null) {
+            return "(NULL)";
+        }
+        Enumeration threads = m.keys();
+        while (threads.hasMoreElements()) {
+            Thread t = (Thread) threads.nextElement();
+            sb.append(t.toString());
+            if (threads.hasMoreElements()) {
+                sb.append(", ");
+            }
+        }
+        return sb.toString();
+    }
+    
     public static interface FileLocker {
         boolean tryLock(File f);
         void unlock(File f);
@@ -171,7 +287,7 @@ public void unlock(File file) {
      */
     public static class NIOFileLocker implements FileLocker {
         
-        private Map locks = new HashMap();
+        private Map locks = new ConcurrentHashMap();
         private boolean debugLocking;
         
         public NIOFileLocker(boolean debugLocking) {
@@ -191,8 +307,9 @@ private static class LockData {
         public boolean tryLock(File file) {
             try {
                 if (file.getParentFile().exists() || file.getParentFile().mkdirs()) {
+                    // this must not be closed until unlock
                     RandomAccessFile raf =
-                        new RandomAccessFile(file, "rw");            
+                        new RandomAccessFile(file, "rw");
                     FileLock l = raf.getChannel().tryLock();
                     if (l != null) {
                         synchronized (this) {
diff --git a/test/java/org/apache/ivy/ant/IvyResolveTest.java b/test/java/org/apache/ivy/ant/IvyResolveTest.java
index 612d8c3b1..4dd0bcfe0 100644
--- a/test/java/org/apache/ivy/ant/IvyResolveTest.java
+++ b/test/java/org/apache/ivy/ant/IvyResolveTest.java
@@ -30,15 +30,17 @@
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Delete;
+import org.apache.tools.ant.taskdefs.Parallel;
 
 public class IvyResolveTest extends TestCase {
     private File cache;
 
+    private Project project;
     private IvyResolve resolve;
 
     protected void setUp() throws Exception {
         createCache();
-        Project project = new Project();
+        project = new Project();
         project.setProperty("ivy.settings.file", "test/repositories/ivysettings.xml");
         project.setProperty("ivy.cache.dir", cache.getAbsolutePath());
 
@@ -62,6 +64,24 @@ private void cleanCache() {
         del.execute();
     }
     
+    public void testIVY1454() throws Exception {
+        // run init in parent thread, then resolve in children
+        project.setProperty("ivy.settings.file", "test/repositories/ivysettings-with-nio.xml");
+        project.setProperty("ivy.log.locking", "true");
+        resolve.setFile(new File("test/java/org/apache/ivy/ant/ivy-simple.xml"));
+        
+        Parallel parallel = new Parallel();
+        parallel.setThreadCount(4);
+        parallel.addTask(resolve);
+        parallel.addTask(resolve);
+        parallel.addTask(resolve);
+        parallel.addTask(resolve);
+        parallel.execute();
+        
+        assertTrue(getResolvedIvyFileInCache(
+            ModuleRevisionId.newInstance("apache", "resolve-simple", "1.0")).exists());
+    }
+    
     public void testIVY779() throws Exception {
         Project project = new Project();
         project.setProperty("ivy.local.default.root", new File("test/repositories/norev").getAbsolutePath());
diff --git a/test/repositories/ivysettings-with-nio.xml b/test/repositories/ivysettings-with-nio.xml
new file mode 100644
index 000000000..7815af4ae
--- /dev/null
+++ b/test/repositories/ivysettings-with-nio.xml
@@ -0,0 +1,50 @@
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   "License"); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.    
+-->
+<ivysettings>
+	<properties file="${ivy.settings.dir}/ivysettings.properties" />
+	<settings defaultResolver="test"/>
+	<caches lockStrategy="artifact-lock-nio" defaultCacheDir="${cache.dir}" />
+	<resolvers>
+		<chain name="test">
+			<filesystem name="1">
+				<ivy pattern="${ivy.settings.dir}/1/[organisation]/[module]/ivys/ivy-[revision].xml"/>
+				<artifact pattern="${ivy.settings.dir}/1/[organisation]/[module]/[type]s/[artifact]-[revision].[ext]"/>
+			</filesystem>
+			<dual name="2">
+				<filesystem name="2-ivy">
+					<ivy pattern="${ivy.settings.dir}/2/[module]/ivy-[revision].xml"/>
+				</filesystem>
+				<filesystem name="2-artifact">
+					<artifact pattern="${ivy.settings.dir}/2/[module]/[artifact]-[revision].[ext]"/>
+					<artifact pattern="${ivy.settings.dir}/2/[module]/[artifact].[ext]"/>
+				</filesystem>
+			</dual>
+			<ibiblio name="m2" m2compatible="true" useMavenMetadata="true" 
+			         root="file:${ivy.settings.dir}/m2" />
+		</chain>
+		<filesystem name="install">
+			<ivy pattern="${ivy.basedir}/build/test/install/[organisation]/[module]/[artifact]-[revision].[ext]"/>
+			<artifact pattern="${ivy.basedir}/build/test/install/[organisation]/[module]/[artifact]-[revision].[ext]"/>
+		</filesystem>
+		<filesystem name="transactional">
+			<ivy pattern="${ivy.basedir}/build/test/transactional/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"/>
+			<artifact pattern="${ivy.basedir}/build/test/transactional/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"/>
+		</filesystem>
+	</resolvers>
+</ivysettings>
