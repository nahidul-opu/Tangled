From f83bbc1d68bd457dfccd370afb248126ce031eb6 Mon Sep 17 00:00:00 2001
From: Gilles Sadowski <erans@apache.org>
Date: Tue, 19 Mar 2013 14:51:30 +0000
Subject: [PATCH] MATH-949 Increment iteration counter. By default, the maximum
 number of iterations is "Integer.MAX_VALUE".

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1458323 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  3 +++
 .../commons/math3/optim/BaseOptimizer.java    |  2 +-
 .../NonLinearConjugateGradientOptimizer.java  |  7 +++--
 .../scalar/noderiv/CMAESOptimizer.java        |  2 ++
 .../scalar/noderiv/PowellOptimizer.java       |  5 ++--
 .../scalar/noderiv/SimplexOptimizer.java      |  5 ++--
 .../vector/jacobian/GaussNewtonOptimizer.java |  5 ++--
 .../jacobian/LevenbergMarquardtOptimizer.java |  6 ++---
 ...nLinearConjugateGradientOptimizerTest.java |  3 +++
 .../scalar/noderiv/CMAESOptimizerTest.java    |  4 ++-
 .../scalar/noderiv/PowellOptimizerTest.java   |  2 ++
 .../SimplexOptimizerMultiDirectionalTest.java | 12 +++++++++
 .../SimplexOptimizerNelderMeadTest.java       | 12 +++++++++
 ...ractLeastSquaresOptimizerAbstractTest.java | 26 +++++++++++++++++++
 14 files changed, 77 insertions(+), 17 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 43c776634c..689fa68685 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -55,6 +55,9 @@ This is a minor release: It combines bug fixes and new features.
   Changes to existing features were made in a backwards-compatible
   way such as to allow drop-in replacement of the v3.1[.1] JAR file.
 ">
+      <action dev="erans" type="fix" issue="MATH-949">
+        Increment iteration counter in optimization algorithms.
+      </action>
       <action dev="luc" type="add" issue="MATH-811" >
         Added a way to trigger only increasing or decreasing events in ODE integration.
       </action>
diff --git a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java
index 75c9757ae8..927e17f5b5 100644
--- a/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java
@@ -48,7 +48,7 @@ protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {
         this.checker = checker;
 
         evaluations = new Incrementor(0, new MaxEvalCallback());
-        iterations = new Incrementor(0, new MaxIterCallback());
+        iterations = new Incrementor(Integer.MAX_VALUE, new MaxIterCallback());
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
index e010781af1..bd12b54fc2 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
@@ -211,16 +211,15 @@ protected PointValuePair doOptimize() {
         }
 
         PointValuePair current = null;
-        int iter = 0;
         int maxEval = getMaxEvaluations();
         while (true) {
-            ++iter;
+            incrementIterationCount();
 
             final double objective = computeObjectiveValue(point);
             PointValuePair previous = current;
             current = new PointValuePair(point, objective);
             if (previous != null) {
-                if (checker.converged(iter, previous, current)) {
+                if (checker.converged(getIterations(), previous, current)) {
                     // We have found an optimum.
                     return current;
                 }
@@ -274,7 +273,7 @@ protected PointValuePair doOptimize() {
             steepestDescent = newSteepestDescent;
 
             // Compute conjugate search direction.
-            if (iter % n == 0 ||
+            if (getIterations() % n == 0 ||
                 beta < 0) {
                 // Break conjugation: reset search direction.
                 searchDirection = steepestDescent.clone();
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
index c7216f9e0b..fed67b1196 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
@@ -385,6 +385,8 @@ protected PointValuePair doOptimize() {
 
         generationLoop:
         for (iterations = 1; iterations <= maxIterations; iterations++) {
+            incrementIterationCount();
+
             // Generate and evaluate lambda offspring
             final RealMatrix arz = randn1(dimension, lambda);
             final RealMatrix arx = zeros(dimension, lambda);
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
index 9572820b2d..afe8d2f5d0 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
@@ -188,9 +188,8 @@ protected PointValuePair doOptimize() {
         double[] x = guess;
         double fVal = computeObjectiveValue(x);
         double[] x1 = x.clone();
-        int iter = 0;
         while (true) {
-            ++iter;
+            incrementIterationCount();
 
             double fX = fVal;
             double fX2 = 0;
@@ -224,7 +223,7 @@ protected PointValuePair doOptimize() {
             final PointValuePair current = new PointValuePair(x, fVal);
             if (!stop) { // User-defined stopping criteria.
                 if (checker != null) {
-                    stop = checker.converged(iter, previous, current);
+                    stop = checker.converged(getIterations(), previous, current);
                 }
             }
             if (stop) {
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
index 3d16aa8a73..0dd644e22f 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
@@ -155,7 +155,7 @@ public int compare(final PointValuePair o1,
         int iteration = 0;
         final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();
         while (true) {
-            if (iteration > 0) {
+            if (getIterations() > 0) {
                 boolean converged = true;
                 for (int i = 0; i < simplex.getSize(); i++) {
                     PointValuePair prev = previous[i];
@@ -171,7 +171,8 @@ public int compare(final PointValuePair o1,
             // We still need to search.
             previous = simplex.getPoints();
             simplex.iterate(evalFunc, comparator);
-            ++iteration;
+
+            incrementIterationCount();
         }
     }
 
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
index a2834f2278..844ed22087 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
@@ -103,9 +103,8 @@ public PointVectorValuePair doOptimize() {
 
         // iterate until convergence is reached
         PointVectorValuePair current = null;
-        int iter = 0;
         for (boolean converged = false; !converged;) {
-            ++iter;
+            incrementIterationCount();
 
             // evaluate the objective function and its jacobian
             PointVectorValuePair previous = current;
@@ -157,7 +156,7 @@ public PointVectorValuePair doOptimize() {
 
             // Check convergence.
             if (previous != null) {
-                converged = checker.converged(iter, previous, current);
+                converged = checker.converged(getIterations(), previous, current);
                 if (converged) {
                     setCost(computeCost(currentResiduals));
                     return current;
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
index ca2d1381b0..4016131e1b 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
@@ -319,10 +319,10 @@ protected PointVectorValuePair doOptimize() {
         // Outer loop.
         lmPar = 0;
         boolean firstIteration = true;
-        int iter = 0;
         final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();
         while (true) {
-            ++iter;
+            incrementIterationCount();
+
             final PointVectorValuePair previous = current;
 
             // QR decomposition of the jacobian matrix
@@ -486,7 +486,7 @@ protected PointVectorValuePair doOptimize() {
                     // tests for convergence.
                     if (checker != null) {
                         // we use the vectorial convergence checker
-                        if (checker.converged(iter, previous, current)) {
+                        if (checker.converged(getIterations(), previous, current)) {
                             setCost(currentCost);
                             return current;
                         }
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java
index 6be5da4e39..aec59bcf4d 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizerTest.java
@@ -136,6 +136,9 @@ public void testTrivial() {
                                  new InitialGuess(new double[] { 0 }));
         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);
         Assert.assertEquals(0.0, optimum.getValue(), 1.0e-10);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java
index f7a548f087..0b4cd6a977 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizerTest.java
@@ -49,7 +49,7 @@ public class CMAESOptimizerTest {
 
     static final int DIM = 13;
     static final int LAMBDA = 4 + (int)(3.*Math.log(DIM));
-   
+
     @Test(expected = NumberIsTooLargeException.class)
     public void testInitOutofbounds1() {
         double[] startPoint = point(DIM,3);
@@ -510,6 +510,8 @@ private void doTest(MultivariateFunction func,
         for (int i = 0; i < dim; i++) {
             Assert.assertEquals(expected.getPoint()[i], result.getPoint()[i], pointTol);
         }
+
+        Assert.assertTrue(optim.getIterations() > 0);
     }
 
     private static double[] point(int n, double value) {
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java
index c76c7c9445..708f77b943 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizerTest.java
@@ -262,5 +262,7 @@ private void doTest(MultivariateFunction func,
             Assert.assertEquals("found[" + i + "]=" + point[i] + " value=" + result.getValue(),
                                 optimum[i], point[i], pointTol);
         }
+
+        Assert.assertTrue(optim.getIterations() > 0);
     }
 }
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java
index c9e9009c69..931c226dab 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerMultiDirectionalTest.java
@@ -61,6 +61,9 @@ public void testMinimize1() {
         Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 8e-13);
         Assert.assertTrue(optimizer.getEvaluations() > 120);
         Assert.assertTrue(optimizer.getEvaluations() < 150);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
@@ -79,6 +82,9 @@ public void testMinimize2() {
         Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 2e-12);
         Assert.assertTrue(optimizer.getEvaluations() > 120);
         Assert.assertTrue(optimizer.getEvaluations() < 150);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
@@ -97,6 +103,9 @@ public void testMaximize1() {
         Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 2e-14);
         Assert.assertTrue(optimizer.getEvaluations() > 120);
         Assert.assertTrue(optimizer.getEvaluations() < 150);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
@@ -115,6 +124,9 @@ public void testMaximize2() {
         Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);
         Assert.assertTrue(optimizer.getEvaluations() > 180);
         Assert.assertTrue(optimizer.getEvaluations() < 220);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java
index fdc187a623..d51025d7e8 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizerNelderMeadTest.java
@@ -66,6 +66,9 @@ public void testMinimize1() {
         Assert.assertEquals(fourExtrema.valueXmYp, optimum.getValue(), 6e-12);
         Assert.assertTrue(optimizer.getEvaluations() > 60);
         Assert.assertTrue(optimizer.getEvaluations() < 90);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
@@ -84,6 +87,9 @@ public void testMinimize2() {
         Assert.assertEquals(fourExtrema.valueXpYm, optimum.getValue(), 1e-11);
         Assert.assertTrue(optimizer.getEvaluations() > 60);
         Assert.assertTrue(optimizer.getEvaluations() < 90);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
@@ -102,6 +108,9 @@ public void testMaximize1() {
         Assert.assertEquals(fourExtrema.valueXmYm, optimum.getValue(), 3e-12);
         Assert.assertTrue(optimizer.getEvaluations() > 60);
         Assert.assertTrue(optimizer.getEvaluations() < 90);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
@@ -120,6 +129,9 @@ public void testMaximize2() {
         Assert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 7e-12);
         Assert.assertTrue(optimizer.getEvaluations() > 60);
         Assert.assertTrue(optimizer.getEvaluations() < 90);
+
+        // Check that the number of iterations is updated (MATH-949).
+        Assert.assertTrue(optimizer.getIterations() > 0);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java
index cc86ae0f4e..942b472f24 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java
@@ -105,6 +105,32 @@ public abstract class AbstractLeastSquaresOptimizerAbstractTest {
 
     public abstract AbstractLeastSquaresOptimizer createOptimizer();
 
+    @Test
+    public void testGetIterations() {
+        AbstractLeastSquaresOptimizer optim = createOptimizer();
+        optim.optimize(new MaxEval(100), new Target(new double[] { 1 }),
+                       new Weight(new double[] { 1 }),
+                       new InitialGuess(new double[] { 3 }),
+                       new ModelFunction(new MultivariateVectorFunction() {
+                               @Override
+                               public double[] value(double[] point) {
+                                   return new double[] {
+                                       FastMath.pow(point[0], 4)
+                                   };
+                               }
+                           }),
+                       new ModelFunctionJacobian(new MultivariateMatrixFunction() {
+                               @Override
+                               public double[][] value(double[] point) {
+                                   return new double[][] {
+                                       { 0.25 * FastMath.pow(point[0], 3) }
+                                   };
+                               }
+                           }));
+
+        Assert.assertTrue(optim.getIterations() > 0);
+    }
+
     @Test
     public void testTrivial() {
         LinearProblem problem
