From e148346fb50e40cf4e0ba7c2b95603aeda740c29 Mon Sep 17 00:00:00 2001
From: Oliver Heger <oheger@apache.org>
Date: Mon, 13 Jul 2015 20:18:21 +0000
Subject: [PATCH] [CONFIGURATION-604] Changed construction of hierarchical
 configuration.

The conversion of a flat configuration to a hierarchical one now uses copy()
rather than append(). This causes a slightly different structure of the
resulting configuration. Because append() adds new nodes on each invocation
the property keys "x.y.z" and "x.y" processed in this order generates two y
child nodes of x. With copy() only a single node is created. This is closer to
the original structure of the flat configuration and is less dependent on the
order of configuration keys.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/configuration/trunk@1690811 13f79535-47bb-0310-9956-ffa450edef68
---
 .../configuration2/ConfigurationUtils.java    |  2 +-
 .../TestConfigurationUtils.java               | 24 ++++++++++++-
 .../tree/TestOverrideCombiner.java            | 35 +++++++++++++++++++
 3 files changed, 59 insertions(+), 2 deletions(-)

diff --git a/src/main/java/org/apache/commons/configuration2/ConfigurationUtils.java b/src/main/java/org/apache/commons/configuration2/ConfigurationUtils.java
index 33fdf50744..6132571ff4 100644
--- a/src/main/java/org/apache/commons/configuration2/ConfigurationUtils.java
+++ b/src/main/java/org/apache/commons/configuration2/ConfigurationUtils.java
@@ -262,7 +262,7 @@ public static HierarchicalConfiguration<?> convertToHierarchical(
 
             // Per default, a DisabledListDelimiterHandler is set.
             // So list delimiters in property values are not an issue.
-            hc.append(conf);
+            hc.copy(conf);
             return hc;
         }
     }
diff --git a/src/test/java/org/apache/commons/configuration2/TestConfigurationUtils.java b/src/test/java/org/apache/commons/configuration2/TestConfigurationUtils.java
index ec8a3a27ff..ebddccb23a 100644
--- a/src/test/java/org/apache/commons/configuration2/TestConfigurationUtils.java
+++ b/src/test/java/org/apache/commons/configuration2/TestConfigurationUtils.java
@@ -31,6 +31,7 @@
 import java.util.Map;
 
 import junitx.framework.ListAssert;
+
 import org.apache.commons.configuration2.builder.XMLBuilderParametersImpl;
 import org.apache.commons.configuration2.convert.DefaultListDelimiterHandler;
 import org.apache.commons.configuration2.event.ConfigurationErrorEvent;
@@ -42,6 +43,7 @@
 import org.apache.commons.configuration2.tree.DefaultExpressionEngine;
 import org.apache.commons.configuration2.tree.DefaultExpressionEngineSymbols;
 import org.apache.commons.configuration2.tree.ExpressionEngine;
+import org.apache.commons.configuration2.tree.ImmutableNode;
 import org.easymock.EasyMock;
 import org.junit.After;
 import org.junit.Before;
@@ -91,7 +93,7 @@ public void testToString()
         assertEquals("String representation of a configuration", "two=2" , ConfigurationUtils.toString(config));
 
         config.setProperty("one","1");
-        assertEquals("String representation of a configuration", "two=2" + lineSeparator + "one=1" , ConfigurationUtils.toString(config));
+        assertEquals("String representation of a configuration", "two=2" + lineSeparator + "one=1", ConfigurationUtils.toString(config));
     }
 
     @Test
@@ -280,6 +282,26 @@ public void testConvertToHierarchicalMultiValues()
         assertEquals("Wrong value 3", 3, hc.getInt("test(2)"));
     }
 
+    /**
+     * Tests that the structure of the resulting hierarchical configuration
+     * does not depend on the order of properties in the source configuration.
+     * This test is related to CONFIGURATION-604.
+     */
+    @Test
+    public void testConvertToHierarchicalOrderOfProperties()
+    {
+        PropertiesConfiguration config = new PropertiesConfiguration();
+        config.addProperty("x.y.z", true);
+        config.addProperty("x.y", true);
+        @SuppressWarnings("unchecked")
+        HierarchicalConfiguration<ImmutableNode> hc =
+                (HierarchicalConfiguration<ImmutableNode>)
+                        ConfigurationUtils.convertToHierarchical(config);
+        ImmutableNode rootNode = hc.getNodeModel().getNodeHandler().getRootNode();
+        ImmutableNode nodeX = rootNode.getChildren().get(0);
+        assertEquals("Wrong number of children of x", 1, nodeX.getChildren().size());
+    }
+
     /**
      * Tests cloning a configuration that supports this operation.
      */
diff --git a/src/test/java/org/apache/commons/configuration2/tree/TestOverrideCombiner.java b/src/test/java/org/apache/commons/configuration2/tree/TestOverrideCombiner.java
index 0023eee215..d5e76b0bd3 100644
--- a/src/test/java/org/apache/commons/configuration2/tree/TestOverrideCombiner.java
+++ b/src/test/java/org/apache/commons/configuration2/tree/TestOverrideCombiner.java
@@ -18,11 +18,14 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 import java.util.List;
 
 import org.apache.commons.configuration2.BaseHierarchicalConfiguration;
+import org.apache.commons.configuration2.CombinedConfiguration;
 import org.apache.commons.configuration2.HierarchicalConfiguration;
+import org.apache.commons.configuration2.PropertiesConfiguration;
 import org.apache.commons.configuration2.ex.ConfigurationException;
 import org.junit.Test;
 
@@ -176,4 +179,36 @@ private ImmutableNode checkTable(BaseHierarchicalConfiguration config)
         assertFalse("An attribute result", nds.get(0).isAttributeResult());
         return nds.get(0).getNode();
     }
+
+    /**
+     * Tests a combine operation of non-hierarchical properties. This test is
+     * related to CONFIGURATION-604.
+     */
+    @Test
+    public void testCombineProperties()
+    {
+        PropertiesConfiguration c1 = new PropertiesConfiguration();
+        c1.addProperty("x.y.simpleCase", false);
+        c1.addProperty("x.y.between", false);
+        c1.addProperty("x.y.isDistinctFrom",false);
+        c1.addProperty("x.y",false);
+        PropertiesConfiguration c2 = new PropertiesConfiguration();
+        c2.addProperty("x.y", true);
+        c2.addProperty("x.y.between",true);
+        c2.addProperty("x.y.comparison",true);
+        c2.addProperty("x.y.in",true);
+        c2.addProperty("x.y.isDistinctFrom",true);
+        c2.addProperty("x.y.simpleCase", true);
+
+        CombinedConfiguration config = new CombinedConfiguration(new OverrideCombiner());
+        config.addConfiguration(c1);
+        config.addConfiguration(c2);
+        assertFalse("Wrong value for x.y", config.getBoolean("x.y"));
+        assertFalse("Wrong value for x.y.between", config.getBoolean("x.y.between"));
+        assertFalse("Wrong value for x.y.isDistinctFrom", config.getBoolean("x.y.isDistinctFrom"));
+        assertFalse("Wrong value for x.y.simpleCase", config.getBoolean("x.y.simpleCase"));
+        assertTrue("Wrong value for x.y.in", config.getBoolean("x.y.in"));
+        assertTrue("Wrong value for x.y.comparison", config.getBoolean("x.y.comparison"));
+        assertEquals("Wrong size", 6, config.size());
+    }
 }
