From 3cafe820ce22f6607e64fddf046d2712766e1530 Mon Sep 17 00:00:00 2001
From: Rahul Akolkar <rahul@apache.org>
Date: Tue, 18 Nov 2008 22:32:57 +0000
Subject: [PATCH] Support for <transition> children for <parallel> states.
 Backporting r661081 from J6 branch. Adding two related tests. SCXML-82

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/scxml/trunk@718746 13f79535-47bb-0310-9956-ffa450edef68
---
 .../apache/commons/scxml/io/ModelUpdater.java |  4 +
 .../commons/scxml/io/SCXMLDigester.java       |  1 +
 .../apache/commons/scxml/io/SCXMLParser.java  |  2 +
 .../org/apache/commons/scxml/model/Path.java  | 27 +++---
 .../org/apache/commons/scxml/model/SCXML.java | 30 +++++++
 .../org/apache/commons/scxml/model/State.java | 74 ----------------
 .../commons/scxml/model/TransitionTarget.java | 74 ++++++++++++++++
 .../scxml/semantics/SCXMLSemanticsImpl.java   | 19 +++--
 .../apache/commons/scxml/SCXMLTestHelper.java |  3 +-
 .../commons/scxml/model/ParallelTest.java     | 85 +++++++++++++++++++
 .../apache/commons/scxml/model/PathTest.java  |  4 +-
 .../commons/scxml/model/parallel-01.xml       | 70 +++++++++++++++
 .../commons/scxml/model/parallel-02.xml       | 31 +++++++
 13 files changed, 326 insertions(+), 98 deletions(-)
 create mode 100644 src/test/java/org/apache/commons/scxml/model/ParallelTest.java
 create mode 100644 src/test/java/org/apache/commons/scxml/model/parallel-01.xml
 create mode 100644 src/test/java/org/apache/commons/scxml/model/parallel-02.xml

diff --git a/src/main/java/org/apache/commons/scxml/io/ModelUpdater.java b/src/main/java/org/apache/commons/scxml/io/ModelUpdater.java
index da2c6a12f..89a51f2f9 100644
--- a/src/main/java/org/apache/commons/scxml/io/ModelUpdater.java
+++ b/src/main/java/org/apache/commons/scxml/io/ModelUpdater.java
@@ -227,6 +227,10 @@ private static void updateParallel(final Parallel p, final Map targets)
         while (i.hasNext()) {
             updateState((State) i.next(), targets);
         }
+        Iterator j = p.getTransitionsList().iterator();
+        while (j.hasNext()) {
+            updateTransition((Transition) j.next(), targets);
+        }
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/scxml/io/SCXMLDigester.java b/src/main/java/org/apache/commons/scxml/io/SCXMLDigester.java
index 5dd0248bb..c64287023 100644
--- a/src/main/java/org/apache/commons/scxml/io/SCXMLDigester.java
+++ b/src/main/java/org/apache/commons/scxml/io/SCXMLDigester.java
@@ -251,6 +251,7 @@ public static SCXML digest(final URL scxmlURL,
         if (scxml != null) {
             ModelUpdater.updateSCXML(scxml);
         }
+        scxml.setLegacy(true);
 
         return scxml;
 
diff --git a/src/main/java/org/apache/commons/scxml/io/SCXMLParser.java b/src/main/java/org/apache/commons/scxml/io/SCXMLParser.java
index 6629c8947..a743cc1a3 100644
--- a/src/main/java/org/apache/commons/scxml/io/SCXMLParser.java
+++ b/src/main/java/org/apache/commons/scxml/io/SCXMLParser.java
@@ -814,6 +814,8 @@ private static void addParallelRules(final String xp,
         addSimpleRulesTuple(xp, scxmlRules, Parallel.class, null, null,
                 "addChild");
         addDatamodelRules(xp + XPF_DM, scxmlRules, scxml, pr);
+        addTransitionRules(xp + XPF_TR, scxmlRules, "addTransition",
+            pr, customActions);
         addHandlerRules(xp, scxmlRules, pr, customActions);
         scxmlRules.add(xp, new UpdateModelRule(scxml));
     }
diff --git a/src/main/java/org/apache/commons/scxml/model/Path.java b/src/main/java/org/apache/commons/scxml/model/Path.java
index b27eee787..484c87c6e 100644
--- a/src/main/java/org/apache/commons/scxml/model/Path.java
+++ b/src/main/java/org/apache/commons/scxml/model/Path.java
@@ -52,10 +52,10 @@ public class Path implements Serializable {
     private List downSeg = new ArrayList();
 
     /**
-     * &quot;Lowest&quot; state which is not being exited nor entered by
-     * the transition.
+     * &quot;Lowest&quot; transition target which is not being exited nor
+     * entered by the transition.
      */
-    private State scope = null;
+    private TransitionTarget scope = null;
 
     /**
      * Whether the path crosses region border(s).
@@ -71,18 +71,14 @@ public class Path implements Serializable {
     Path(final TransitionTarget source, final TransitionTarget target) {
         if (target == null) {
             //a local "stay" transition
-            scope = (State) source;
+            scope = source;
             //all segments remain empty
         } else {
             TransitionTarget tt = SCXMLHelper.getLCA(source, target);
             if (tt != null) {
-                if (tt instanceof State) {
-                    scope = (State) tt;
-                } else {
-                    scope = tt.getParentState();
-                }
+                scope = tt;
                 if (scope == source || scope == target) {
-                    scope = scope.getParentState();
+                    scope = scope.getParent();
                 }
             }
             tt = source;
@@ -167,13 +163,16 @@ public final List getRegionsEntered() {
      * nor entered by the transition (null if scope is document root).
      *
      * @return State scope of the transition path, null means global transition
-     *         (SCXML document level) Scope is the least state which is not
-     *         being exited nor entered by the transition.
+     *         (SCXML document level) or parent parallel. Scope is the least
+     *         state which is not being exited nor entered by the transition.
      *
      * @deprecated Use {@link #getPathScope()} instead.
      */
     public final State getScope() {
-        return scope;
+        if (scope instanceof State) {
+            return (State) scope;
+        }
+        return null;
     }
 
     /**
@@ -183,6 +182,8 @@ public final State getScope() {
      * @return Scope of the transition path, null means global transition
      *         (SCXML document level). Scope is the least transition target
      *         which is not being exited nor entered by the transition.
+     *
+     * @since 0.9
      */
     public final TransitionTarget getPathScope() {
         return scope;
diff --git a/src/main/java/org/apache/commons/scxml/model/SCXML.java b/src/main/java/org/apache/commons/scxml/model/SCXML.java
index 9b5875435..50e71571f 100644
--- a/src/main/java/org/apache/commons/scxml/model/SCXML.java
+++ b/src/main/java/org/apache/commons/scxml/model/SCXML.java
@@ -80,6 +80,12 @@ public class SCXML implements Serializable {
      */
     private Map targets;
 
+    /**
+     * Indicates whether the legacy parser
+     * ({@link org.apache.commons.scxml.io.SCXMLDigester}) was used.
+     */
+    private boolean legacy = false;
+
     /**
      * Constructor.
      */
@@ -301,5 +307,29 @@ public final void setInitial(final String initial) {
         this.initial = initial;
     }
 
+    /**
+     * Whether the legacy parser was used.
+     *
+     * @return True, if legacy parser was used.
+     *
+     * @since 0.9
+     * @deprecated Will be removed in v1.0
+     */
+    public final boolean isLegacy() {
+        return legacy;
+    }
+
+    /**
+     * Set whether the legacy parser was used.
+     *
+     * @param legacy True, if legacy parser was used.
+     *
+     * @since 0.9
+     * @deprecated Will be removed in v1.0
+     */
+    public final void setLegacy(final boolean legacy) {
+        this.legacy = legacy;
+    }
+
 }
 
diff --git a/src/main/java/org/apache/commons/scxml/model/State.java b/src/main/java/org/apache/commons/scxml/model/State.java
index 2b2176937..06f25dc8f 100644
--- a/src/main/java/org/apache/commons/scxml/model/State.java
+++ b/src/main/java/org/apache/commons/scxml/model/State.java
@@ -16,10 +16,7 @@
  */
 package org.apache.commons.scxml.model;
 
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
 
 /**
@@ -69,11 +66,6 @@ public class State extends TransitionTarget {
      */
     private Initial initial;
 
-    /**
-     * A list of outgoing Transitions from this state, by document order.
-     */
-    private List transitions;
-
     /**
      * Applies to composite states only. If one of its final children is
      * active, its parent is marked done. This property is reset upon
@@ -88,7 +80,6 @@ public class State extends TransitionTarget {
      */
     public State() {
         this.children = new LinkedHashMap();
-        this.transitions = new ArrayList();
     }
 
     /**
@@ -199,62 +190,6 @@ public final void setInitial(final Initial target) {
         target.setParent(this);
     }
 
-    /**
-     * Get the map of all outgoing transitions from this state.
-     *
-     * @return Map Returns the transitions Map.
-     * @deprecated Use {@link #getTransitionsList()} instead
-     */
-    public final Map getTransitions() {
-        Map transitionsMap = new HashMap();
-        for (int i = 0; i < transitions.size(); i++) {
-            Transition transition = (Transition) transitions.get(i);
-            String event = transition.getEvent();
-            if (!transitionsMap.containsKey(event)) {
-                List eventTransitions = new ArrayList();
-                eventTransitions.add(transition);
-                transitionsMap.put(event, eventTransitions);
-            } else {
-                ((List) transitionsMap.get(event)).add(transition);
-            }
-        }
-        return transitionsMap;
-    }
-
-    /**
-     * Get the list of all outgoing transitions from this state, that
-     * will be candidates for being fired on the given event.
-     *
-     * @param event The event
-     * @return List Returns the candidate transitions for given event
-     */
-    public final List getTransitionsList(final String event) {
-        List matchingTransitions = null; // since we returned null upto v0.6
-        for (int i = 0; i < transitions.size(); i++) {
-            Transition t = (Transition) transitions.get(i);
-            if ((event == null && t.getEvent() == null)
-                    || (event != null && event.equals(t.getEvent()))) {
-                if (matchingTransitions == null) {
-                    matchingTransitions = new ArrayList();
-                }
-                matchingTransitions.add(t);
-            }
-        }
-        return matchingTransitions;
-    }
-
-    /**
-     * Add a transition to the map of all outgoing transitions for
-     * this state.
-     *
-     * @param transition
-     *            The transitions to set.
-     */
-    public final void addTransition(final Transition transition) {
-        transitions.add(transition);
-        transition.setParent(this);
-    }
-
     /**
      * Get the map of child states (may be empty).
      *
@@ -290,15 +225,6 @@ public final void addChild(final TransitionTarget tt) {
         tt.setParent(this);
     }
 
-    /**
-     * Get the outgoing transitions for this state as a java.util.List.
-     *
-     * @return List Returns the transitions list.
-     */
-    public final List getTransitionsList() {
-        return transitions;
-    }
-
     /**
      * Check whether this is a simple (leaf) state (UML terminology).
      *
diff --git a/src/main/java/org/apache/commons/scxml/model/TransitionTarget.java b/src/main/java/org/apache/commons/scxml/model/TransitionTarget.java
index 48e62a4c0..8d088f303 100644
--- a/src/main/java/org/apache/commons/scxml/model/TransitionTarget.java
+++ b/src/main/java/org/apache/commons/scxml/model/TransitionTarget.java
@@ -18,7 +18,9 @@
 
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 /**
  * An abstract base class for elements in SCXML that can serve as a
@@ -56,6 +58,11 @@ public abstract class TransitionTarget implements Serializable {
      */
     private TransitionTarget parent;
 
+    /**
+     * A list of outgoing Transitions from this target, by document order.
+     */
+    private List transitions;
+
     /**
      * List of history states owned by a given state (applies to non-leaf
      * states).
@@ -72,6 +79,7 @@ public TransitionTarget() {
         onExit = new OnExit();   //empty defaults
         onExit.setParent(this);
         parent = null;
+        transitions = new ArrayList();
         history = new ArrayList();
     }
 
@@ -172,6 +180,7 @@ public final void setParent(final TransitionTarget parent) {
      * Get the parent State.
      *
      * @return The parent State
+     * @deprecated Will be removed in v1.0
      */
     public final State getParentState() {
         TransitionTarget tt = this.getParent();
@@ -186,6 +195,71 @@ public final State getParentState() {
         }
     }
 
+    /**
+     * Get the map of all outgoing transitions from this state.
+     *
+     * @return Map Returns the transitions Map.
+     * @deprecated Use {@link #getTransitionsList()} instead
+     */
+    public final Map getTransitions() {
+        Map transitionsMap = new HashMap();
+        for (int i = 0; i < transitions.size(); i++) {
+            Transition transition = (Transition) transitions.get(i);
+            String event = transition.getEvent();
+            if (!transitionsMap.containsKey(event)) {
+                List eventTransitions = new ArrayList();
+                eventTransitions.add(transition);
+                transitionsMap.put(event, eventTransitions);
+            } else {
+                ((List) transitionsMap.get(event)).add(transition);
+            }
+        }
+        return transitionsMap;
+    }
+
+    /**
+     * Get the list of all outgoing transitions from this target, that
+     * will be candidates for being fired on the given event.
+     *
+     * @param event The event
+     * @return List Returns the candidate transitions for given event
+     */
+    public final List getTransitionsList(final String event) {
+        List matchingTransitions = null; // TODO v1.0 we returned null <= v0.6
+        for (int i = 0; i < transitions.size(); i++) {
+            Transition t = (Transition) transitions.get(i);
+            if ((event == null && t.getEvent() == null)
+                    || (event != null && event.equals(t.getEvent()))) {
+                if (matchingTransitions == null) {
+                    matchingTransitions = new ArrayList();
+                }
+                matchingTransitions.add(t);
+            }
+        }
+        return matchingTransitions;
+    }
+
+    /**
+     * Add a transition to the map of all outgoing transitions for
+     * this transition target.
+     *
+     * @param transition
+     *            The transitions to set.
+     */
+    public final void addTransition(final Transition transition) {
+        transitions.add(transition);
+        transition.setParent(this);
+    }
+
+    /**
+     * Get the outgoing transitions for this target as a java.util.List.
+     *
+     * @return List Returns the transitions list.
+     */
+    public final List getTransitionsList() {
+        return transitions;
+    }
+
     /**
      * This method is used by XML digester.
      *
diff --git a/src/main/java/org/apache/commons/scxml/semantics/SCXMLSemanticsImpl.java b/src/main/java/org/apache/commons/scxml/semantics/SCXMLSemanticsImpl.java
index f3cb48c34..309a112be 100644
--- a/src/main/java/org/apache/commons/scxml/semantics/SCXMLSemanticsImpl.java
+++ b/src/main/java/org/apache/commons/scxml/semantics/SCXMLSemanticsImpl.java
@@ -279,11 +279,14 @@ public void executeActions(final Step step, final SCXML stateMachine,
                             te = new TriggerEvent(p.getId() + ".done",
                                         TriggerEvent.CHANGE_EVENT);
                             internalEvents.add(te);
-                            te = new TriggerEvent(p.getParent().getId()
-                                + ".done", TriggerEvent.CHANGE_EVENT);
-                            internalEvents.add(te);
-                            //this is not in the specs, but is makes sense
-                            scInstance.setDone(p.getParentState(), true);
+                            scInstance.setDone(p, true);
+                            if (stateMachine.isLegacy()) {
+                                te = new TriggerEvent(p.getParent().getId()
+                                    + ".done", TriggerEvent.CHANGE_EVENT);
+                                internalEvents.add(te);
+                                //this is not in the specs, but is makes sense
+                                scInstance.setDone(p.getParentState(), true);
+                            }
                         }
                     }
                 }
@@ -309,8 +312,8 @@ public void enumerateReachableTransitions(final SCXML stateMachine,
         // breath-first search to-do list
         LinkedList todoList = new LinkedList(stateSet);
         while (!todoList.isEmpty()) {
-            State st = (State) todoList.removeFirst();
-            for (Iterator i = st.getTransitionsList().iterator();
+            TransitionTarget tt = (TransitionTarget) todoList.removeFirst();
+            for (Iterator i = tt.getTransitionsList().iterator();
                     i.hasNext();) {
                 Transition t = (Transition) i.next();
                 if (!transSet.contains(t)) {
@@ -318,7 +321,7 @@ public void enumerateReachableTransitions(final SCXML stateMachine,
                     step.getTransitList().add(t);
                 }
             }
-            State parent = st.getParentState();
+            TransitionTarget parent = tt.getParent();
             if (parent != null && !stateSet.contains(parent)) {
                 stateSet.add(parent);
                 todoList.addLast(parent);
diff --git a/src/test/java/org/apache/commons/scxml/SCXMLTestHelper.java b/src/test/java/org/apache/commons/scxml/SCXMLTestHelper.java
index 2c98d7f03..60595821f 100644
--- a/src/test/java/org/apache/commons/scxml/SCXMLTestHelper.java
+++ b/src/test/java/org/apache/commons/scxml/SCXMLTestHelper.java
@@ -24,6 +24,7 @@
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.net.URL;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
@@ -294,7 +295,7 @@ public static void assertPostTriggerStates(SCXMLExecutor exec,
             + " on firing event " + triggerEvent + " but found "
             + currentStates.size() + " states instead.",
             n, currentStates.size());
-        List expectedStateIdList = Arrays.asList(expectedStateIds);
+        List expectedStateIdList = new ArrayList(Arrays.asList(expectedStateIds));
         Iterator iter = currentStates.iterator();
         while (iter.hasNext()) {
             String stateId = ((State) iter.next()).getId();
diff --git a/src/test/java/org/apache/commons/scxml/model/ParallelTest.java b/src/test/java/org/apache/commons/scxml/model/ParallelTest.java
new file mode 100644
index 000000000..bea2f7f9c
--- /dev/null
+++ b/src/test/java/org/apache/commons/scxml/model/ParallelTest.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.scxml.model;
+
+import java.net.URL;
+
+import org.apache.commons.scxml.SCXMLExecutor;
+import org.apache.commons.scxml.SCXMLTestHelper;
+
+import junit.framework.Test;
+import junit.framework.TestCase;
+import junit.framework.TestSuite;
+
+public class ParallelTest extends TestCase {
+
+    public ParallelTest(String testName) {
+        super(testName);
+    }
+
+    public static Test suite() {
+        return new TestSuite(ParallelTest.class);
+    }
+
+    public static void main(String args[]) {
+        String[] testCaseName = { ParallelTest.class.getName() };
+        junit.textui.TestRunner.main(testCaseName);
+    }
+
+    // Test data
+    private URL parallel01, parallel02;
+    private SCXMLExecutor exec;
+    
+    public void setUp() {
+        parallel01 = this.getClass().getClassLoader().
+            getResource("org/apache/commons/scxml/model/parallel-01.xml");
+        parallel02 = this.getClass().getClassLoader().
+            getResource("org/apache/commons/scxml/model/parallel-02.xml");
+    }
+
+    public void tearDown() {
+        parallel01 = parallel02 = null;
+        exec = null;
+    }
+
+    public void testParallel01() {
+    	SCXML scxml = SCXMLTestHelper.parse(parallel01);
+        assertNotNull(scxml);
+        exec = SCXMLTestHelper.getExecutor(scxml);
+        assertNotNull(exec);
+        try {
+            SCXMLTestHelper.assertPostTriggerState(exec, "foo", "end");
+        } catch (Exception e) {
+            fail(e.getMessage());
+        }
+    }
+
+    public void testParallel02() {
+    	SCXML scxml = SCXMLTestHelper.parse(parallel02);
+        assertNotNull(scxml);
+        exec = SCXMLTestHelper.getExecutor(scxml);
+        assertNotNull(exec);
+        try {
+        	SCXMLTestHelper.assertPostTriggerStates(exec, "dummy.event", new String[] { "state01", "state02" });
+            SCXMLTestHelper.assertPostTriggerState(exec, "event1", "state1");
+        } catch (Exception e) {
+        	e.printStackTrace();
+            fail(e.getMessage());
+        }
+    }
+
+}
diff --git a/src/test/java/org/apache/commons/scxml/model/PathTest.java b/src/test/java/org/apache/commons/scxml/model/PathTest.java
index eba4dee95..b4a37d3b1 100644
--- a/src/test/java/org/apache/commons/scxml/model/PathTest.java
+++ b/src/test/java/org/apache/commons/scxml/model/PathTest.java
@@ -157,7 +157,7 @@ public void testConstructorParentParallel() {
 
         Path path = new Path(source, target);
 
-        assertNull(path.getPathScope());
+        assertEquals("parentid", path.getPathScope().getId());
     }
     
     public void testConstructorParentParallelParent() {
@@ -180,7 +180,7 @@ public void testConstructorParentParallelParent() {
 
         Path path = new Path(source, target);
 
-        assertEquals("superParent", path.getPathScope().getId());
+        assertEquals("parentid", path.getPathScope().getId());
     }
     
     public void testGetRegionsExitedNull() {
diff --git a/src/test/java/org/apache/commons/scxml/model/parallel-01.xml b/src/test/java/org/apache/commons/scxml/model/parallel-01.xml
new file mode 100644
index 000000000..e8222857c
--- /dev/null
+++ b/src/test/java/org/apache/commons/scxml/model/parallel-01.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0"?>
+<!--
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+-->
+<!--
+    Needs SCXMLParser
+-->
+<scxml xmlns="http://www.w3.org/2005/07/scxml"
+       version="1.0"
+       initialstate="para">
+
+    <parallel id="para">
+
+        <state id="para1">
+
+            <initial>
+                <transition target="para11"/>
+            </initial>
+
+            <state id="para11">
+                <transition event="foo" target="para12"/>
+            </state>
+
+            <state id="para12">
+                <onexit>
+                    <log expr="'Exiting para12'" />
+                </onexit>
+            </state>
+
+        </state>
+
+        <state id="para2">
+
+            <initial>
+                <transition target="para21"/>
+            </initial>
+
+            <state id="para21">
+                <transition cond="In('para12')" target="para22"/>
+            </state>
+
+            <state id="para22">
+                <onexit>
+                    <log expr="'Exiting para22'" />
+                </onexit>
+
+                <transition target="end"/>
+            </state>
+
+        </state>
+
+    </parallel>
+
+    <state id="end" final="true" />
+
+</scxml>
+
diff --git a/src/test/java/org/apache/commons/scxml/model/parallel-02.xml b/src/test/java/org/apache/commons/scxml/model/parallel-02.xml
new file mode 100644
index 000000000..106fc8663
--- /dev/null
+++ b/src/test/java/org/apache/commons/scxml/model/parallel-02.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0"?>
+<!--
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+-->
+<!--
+   Needs SCXMLParser
+-->
+<scxml xmlns="http://www.w3.org/2005/07/scxml" version="1.0" initialstate="state0">
+
+    <parallel id="state0">
+        <transition event="event1" target="state1" />
+        <!-- dummy regions -->
+        <state id="state01"/>
+        <state id="state02"/>
+    </parallel>
+    <final id="state1"/>
+
+</scxml>
