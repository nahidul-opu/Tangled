From f853d15e317bba494d3ec81ee4bd0414440a6161 Mon Sep 17 00:00:00 2001
From: Maarten Coene <maartenc@apache.org>
Date: Fri, 23 Oct 2009 22:09:20 +0000
Subject: [PATCH] FIX: IvyNodeEviction.cleanEvicted has bad comparison logic
 (IVY-1118)

git-svn-id: https://svn.apache.org/repos/asf/ant/ivy/core/trunk@829259 13f79535-47bb-0310-9956-ffa450edef68
---
 CHANGES.txt                                   |   1 +
 .../ivy/core/resolve/ResolveEngine.java       | 159 ++++++++++++++----
 2 files changed, 124 insertions(+), 36 deletions(-)

diff --git a/CHANGES.txt b/CHANGES.txt
index 722e79def..5c4aed6c1 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -97,6 +97,7 @@ for detailed view of each issue, please consult http://issues.apache.org/jira/br
 - IMPROVEMENT: Trace a message when a property file referenced from the settings doesn't exixts (IVY-1074)
 - IMPROVEMENT: use defaultconf in combination with defaultconfmapping (IVY-1135) (thanks to Jon Schneider)
 
+- FIX: IvyNodeEviction.cleanEvicted has bad comparison logic (IVY-1118)
 - FIX: ChainResolver doesn't pass the specified 'checkmodified' attribute to the cache (IVY-1133)
 - FIX: Ivy couldn't handle maven POMs that depend on theirselves
 - FIX: SearchEngine.listModules returns MRID without extra attributes (IVY-1128) (thanks to Michael Scheetz)
diff --git a/src/java/org/apache/ivy/core/resolve/ResolveEngine.java b/src/java/org/apache/ivy/core/resolve/ResolveEngine.java
index c7d71528c..c4fa9852d 100644
--- a/src/java/org/apache/ivy/core/resolve/ResolveEngine.java
+++ b/src/java/org/apache/ivy/core/resolve/ResolveEngine.java
@@ -70,6 +70,8 @@
 import org.apache.ivy.util.Message;
 import org.apache.ivy.util.filter.Filter;
 
+import sun.security.krb5.internal.ccache.ar;
+
 /**
  * The resolve engine which is the core of the dependency resolution mechanism used in Ivy. It
  * features several resolve methods, some very simple, like {@link #resolve(File)} and
@@ -338,48 +340,133 @@ public void downloadArtifacts(
                 .toArray(new Artifact[report.getArtifacts().size()])));
 
         long totalSize = 0;
-        for (int i = 0; i < dependencies.length; i++) {
-            checkInterrupted();
-            // download artifacts required in all asked configurations
-            if (!dependencies[i].isCompletelyEvicted() && !dependencies[i].hasProblem()
-                    && dependencies[i].getModuleRevision() != null) {
-                DependencyResolver resolver = dependencies[i].getModuleRevision()
-                        .getArtifactResolver();
-                Artifact[] selectedArtifacts = dependencies[i].getSelectedArtifacts(artifactFilter);
-                DownloadReport dReport = resolver.download(selectedArtifacts, options);
-                ArtifactDownloadReport[] adrs = dReport.getArtifactsReports();
-                for (int j = 0; j < adrs.length; j++) {
-                    if (adrs[j].getDownloadStatus() == DownloadStatus.FAILED) {
-                        if (adrs[j].getArtifact().getExtraAttribute("ivy:merged") != null) {
-                            Message.warn("\tmerged artifact not found: " + adrs[j].getArtifact()
-                                + ". It was required in " 
-                                + adrs[j].getArtifact().getExtraAttribute("ivy:merged"));
-                        } else {
-                            Message.warn("\t" + adrs[j]);
-                            resolver.reportFailure(adrs[j].getArtifact());
+        
+        List deps = Collections.synchronizedList(new ArrayList(Arrays.asList(dependencies)));
+        
+        DownloadThread t1 = new DownloadThread(deps, report, artifactFilter, options);
+        DownloadThread t2 = new DownloadThread(deps, report, artifactFilter, options);
+        DownloadThread t3 = new DownloadThread(deps, report, artifactFilter, options);
+        DownloadThread t4 = new DownloadThread(deps, report, artifactFilter, options);
+        DownloadThread t5 = new DownloadThread(deps, report, artifactFilter, options);
+        
+        t1.start();
+        t2.start();
+        t3.start();
+        t4.start();
+        t5.start();
+        
+        while (t1.isAlive() || t2.isAlive() || t3.isAlive() || t4.isAlive() || t5.isAlive()) {
+            // wait for all threads to finish
+        }
+        
+//        for (int i = 0; i < dependencies.length; i++) {
+//            checkInterrupted();
+//            // download artifacts required in all asked configurations
+//            if (!dependencies[i].isCompletelyEvicted() && !dependencies[i].hasProblem()
+//                    && dependencies[i].getModuleRevision() != null) {
+//                DependencyResolver resolver = dependencies[i].getModuleRevision()
+//                        .getArtifactResolver();
+//                Artifact[] selectedArtifacts = dependencies[i].getSelectedArtifacts(artifactFilter);
+//                DownloadReport dReport = resolver.download(selectedArtifacts, options);
+//                ArtifactDownloadReport[] adrs = dReport.getArtifactsReports();
+//                for (int j = 0; j < adrs.length; j++) {
+//                    if (adrs[j].getDownloadStatus() == DownloadStatus.FAILED) {
+//                        if (adrs[j].getArtifact().getExtraAttribute("ivy:merged") != null) {
+//                            Message.warn("\tmerged artifact not found: " + adrs[j].getArtifact()
+//                                + ". It was required in " 
+//                                + adrs[j].getArtifact().getExtraAttribute("ivy:merged"));
+//                        } else {
+//                            Message.warn("\t" + adrs[j]);
+//                            resolver.reportFailure(adrs[j].getArtifact());
+//                        }
+//                    } else if (adrs[j].getDownloadStatus() == DownloadStatus.SUCCESSFUL) {
+//                        totalSize += adrs[j].getSize();
+//                    }
+//                }
+//                // update concerned reports
+//                String[] dconfs = dependencies[i].getRootModuleConfigurations();
+//                for (int j = 0; j < dconfs.length; j++) {
+//                    // the report itself is responsible to take into account only
+//                    // artifacts required in its corresponding configuration
+//                    // (as described by the Dependency object)
+//                    if (dependencies[i].isEvicted(dconfs[j]) 
+//                            || dependencies[i].isBlacklisted(dconfs[j])) {
+//                        report.getConfigurationReport(dconfs[j]).addDependency(dependencies[i]);
+//                    } else {
+//                        report.getConfigurationReport(dconfs[j]).addDependency(dependencies[i],
+//                            dReport);
+//                    }
+//                }
+//            }
+//        }
+        report.setDownloadTime(System.currentTimeMillis() - start);
+        report.setDownloadSize(totalSize);
+    }
+    
+    private static class DownloadThread extends Thread {
+        
+        private List artifactsToDownload;
+        private ResolveReport report;
+        private Filter artifactFilter;
+        private DownloadOptions options;
+        
+        private boolean finished;
+        
+        public DownloadThread(List artifactsToDownload, ResolveReport report, Filter artifactFilter, DownloadOptions options) {
+            this.artifactsToDownload = artifactsToDownload;
+            this.report = report;
+            this.artifactFilter = artifactFilter;
+            this.options = options;
+        }
+        
+        public void run() {
+            while (!artifactsToDownload.isEmpty()) {
+                IvyNode dependency = (IvyNode) artifactsToDownload.remove(0);
+                
+//                System.out.println(Thread.currentThread() + "downloading " + dependency);
+
+                if (!dependency.isCompletelyEvicted() && !dependency.hasProblem()
+                        && dependency.getModuleRevision() != null) {
+                    System.out.println(Thread.currentThread() + "downloading " + dependency);
+                    DependencyResolver resolver = dependency.getModuleRevision()
+                            .getArtifactResolver();
+                    Artifact[] selectedArtifacts = dependency.getSelectedArtifacts(artifactFilter);
+                    DownloadReport dReport = resolver.download(selectedArtifacts, options);
+                    ArtifactDownloadReport[] adrs = dReport.getArtifactsReports();
+                    for (int j = 0; j < adrs.length; j++) {
+                        System.out.println(adrs[j]);
+                        if (adrs[j].getDownloadStatus() == DownloadStatus.FAILED) {
+                            if (adrs[j].getArtifact().getExtraAttribute("ivy:merged") != null) {
+                                Message.warn("\tmerged artifact not found: " + adrs[j].getArtifact()
+                                    + ". It was required in " 
+                                    + adrs[j].getArtifact().getExtraAttribute("ivy:merged"));
+                            } else {
+                                Message.warn("\t" + adrs[j]);
+                                resolver.reportFailure(adrs[j].getArtifact());
+                            }
+                        } else if (adrs[j].getDownloadStatus() == DownloadStatus.SUCCESSFUL) {
+//                            totalSize += adrs[j].getSize();
                         }
-                    } else if (adrs[j].getDownloadStatus() == DownloadStatus.SUCCESSFUL) {
-                        totalSize += adrs[j].getSize();
                     }
-                }
-                // update concerned reports
-                String[] dconfs = dependencies[i].getRootModuleConfigurations();
-                for (int j = 0; j < dconfs.length; j++) {
-                    // the report itself is responsible to take into account only
-                    // artifacts required in its corresponding configuration
-                    // (as described by the Dependency object)
-                    if (dependencies[i].isEvicted(dconfs[j]) 
-                            || dependencies[i].isBlacklisted(dconfs[j])) {
-                        report.getConfigurationReport(dconfs[j]).addDependency(dependencies[i]);
-                    } else {
-                        report.getConfigurationReport(dconfs[j]).addDependency(dependencies[i],
-                            dReport);
+                    // update concerned reports
+                    String[] dconfs = dependency.getRootModuleConfigurations();
+                    for (int j = 0; j < dconfs.length; j++) {
+                        // the report itself is responsible to take into account only
+                        // artifacts required in its corresponding configuration
+                        // (as described by the Dependency object)
+                        if (dependency.isEvicted(dconfs[j]) 
+                                || dependency.isBlacklisted(dconfs[j])) {
+                            report.getConfigurationReport(dconfs[j]).addDependency(dependency);
+                        } else {
+                            report.getConfigurationReport(dconfs[j]).addDependency(dependency,
+                                dReport);
+                        }
                     }
                 }
+
+                
             }
         }
-        report.setDownloadTime(System.currentTimeMillis() - start);
-        report.setDownloadSize(totalSize);
     }
 
     /**
