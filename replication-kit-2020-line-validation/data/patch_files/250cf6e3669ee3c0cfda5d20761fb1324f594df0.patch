From 250cf6e3669ee3c0cfda5d20761fb1324f594df0 Mon Sep 17 00:00:00 2001
From: Luc Maisonobe <luc@apache.org>
Date: Fri, 28 Dec 2012 20:16:38 +0000
Subject: [PATCH] Added vector-only weights for multivariate vector optimizers.

JIRA: MATH-924

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1426616 13f79535-47bb-0310-9956-ffa450edef68
---
 pom.xml                                       |  4 +-
 src/changes/changes.xml                       |  7 ++
 .../commons/math3/fitting/CurveFitter.java    | 11 +--
 ...MultiStartMultivariateVectorOptimizer.java | 19 +++--
 .../vector/MultivariateVectorOptimizer.java   | 62 ++++++++++++---
 .../nonlinear/vector/NonCorrelatedWeight.java | 53 +++++++++++++
 .../math3/optim/nonlinear/vector/Weight.java  | 18 ++---
 .../AbstractLeastSquaresOptimizer.java        | 75 +++++++++++++------
 .../vector/jacobian/GaussNewtonOptimizer.java |  9 +--
 .../jacobian/LevenbergMarquardtOptimizer.java | 14 ++--
 .../math3/fitting/PolynomialFitterTest.java   | 27 +++++++
 ...iStartMultivariateVectorOptimizerTest.java |  9 +--
 ...ractLeastSquaresOptimizerAbstractTest.java | 53 +++++++------
 .../AbstractLeastSquaresOptimizerTest.java    | 13 ++--
 ...ctLeastSquaresOptimizerTestValidation.java | 17 +++--
 .../jacobian/GaussNewtonOptimizerTest.java    |  9 +--
 .../LevenbergMarquardtOptimizerTest.java      | 28 ++++---
 .../vector/jacobian/MinpackTest.java          | 14 ++--
 18 files changed, 297 insertions(+), 145 deletions(-)
 create mode 100644 src/main/java/org/apache/commons/math3/optim/nonlinear/vector/NonCorrelatedWeight.java

diff --git a/pom.xml b/pom.xml
index 430e23d186..2ccae6c1de 100644
--- a/pom.xml
+++ b/pom.xml
@@ -24,7 +24,7 @@
   <modelVersion>4.0.0</modelVersion>
   <groupId>org.apache.commons</groupId>
   <artifactId>commons-math3</artifactId>
-  <version>3.2-SNAPSHOT</version>
+  <version>3.1.1-SNAPSHOT</version>
   <name>Commons Math</name>
 
   <inceptionYear>2003</inceptionYear>
@@ -293,7 +293,7 @@
   <properties>
     <commons.componentid>math3</commons.componentid>
     <!-- do not use snapshot suffix here -->
-    <commons.release.version>3.2</commons.release.version>
+    <commons.release.version>3.1.1</commons.release.version>
     <commons.release.desc>(requires Java 1.5+)</commons.release.desc>
     <!-- <commons.rc.version>RC1</commons.rc.version> -->
     <commons.binary.suffix>-bin</commons.binary.suffix>
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 1941f1c2d4..56216536d8 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -50,6 +50,13 @@ If the output is not quite correct, check for invisible trailing spaces!
     <title>Commons Math Release Notes</title>
   </properties>
   <body>
+    <release version="3.1.1" date="TBD" description="
+This is a micro release: It only contains bug fixes bug fixes.
+">
+      <action dev="luc" type="fix" issue="MATH-924">
+        Fix handling of large number of weights in the new optimizers API.
+      </action>
+    </release>
     <release version="3.1" date="2012-12-23" description="
 This is a minor release: It combines bug fixes and new features.
   Changes to existing features were made in a backwards-compatible
diff --git a/src/main/java/org/apache/commons/math3/fitting/CurveFitter.java b/src/main/java/org/apache/commons/math3/fitting/CurveFitter.java
index e5c202473d..42274f3de9 100644
--- a/src/main/java/org/apache/commons/math3/fitting/CurveFitter.java
+++ b/src/main/java/org/apache/commons/math3/fitting/CurveFitter.java
@@ -18,17 +18,18 @@
 
 import java.util.ArrayList;
 import java.util.List;
-import org.apache.commons.math3.analysis.MultivariateVectorFunction;
+
 import org.apache.commons.math3.analysis.MultivariateMatrixFunction;
+import org.apache.commons.math3.analysis.MultivariateVectorFunction;
 import org.apache.commons.math3.analysis.ParametricUnivariateFunction;
-import org.apache.commons.math3.optim.MaxEval;
 import org.apache.commons.math3.optim.InitialGuess;
+import org.apache.commons.math3.optim.MaxEval;
 import org.apache.commons.math3.optim.PointVectorValuePair;
-import org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer;
 import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;
 import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;
+import org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer;
 import org.apache.commons.math3.optim.nonlinear.vector.Target;
-import org.apache.commons.math3.optim.nonlinear.vector.Weight;
+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;
 
 /**
  * Fitter for parametric univariate real functions y = f(x).
@@ -174,7 +175,7 @@ public double[] fit(int maxEval, T f,
                                  model.getModelFunction(),
                                  model.getModelFunctionJacobian(),
                                  new Target(target),
-                                 new Weight(weights),
+                                 new NonCorrelatedWeight(weights),
                                  new InitialGuess(initialGuess));
         // Extract the coefficients.
         return optimum.getPointRef();
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizer.java
index c90a5b3731..465c6ee9d2 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizer.java
@@ -16,18 +16,18 @@
  */
 package org.apache.commons.math3.optim.nonlinear.vector;
 
-import java.util.Collections;
-import java.util.List;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Comparator;
+import java.util.List;
+
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.exception.NullArgumentException;
-import org.apache.commons.math3.linear.RealMatrix;
-import org.apache.commons.math3.linear.RealVector;
 import org.apache.commons.math3.linear.ArrayRealVector;
-import org.apache.commons.math3.random.RandomVectorGenerator;
+import org.apache.commons.math3.linear.RealVector;
 import org.apache.commons.math3.optim.BaseMultiStartMultivariateOptimizer;
 import org.apache.commons.math3.optim.PointVectorValuePair;
+import org.apache.commons.math3.random.RandomVectorGenerator;
 
 /**
  * Multi-start optimizer for a (vector) model function.
@@ -98,7 +98,7 @@ protected void clear() {
     private Comparator<PointVectorValuePair> getPairComparator() {
         return new Comparator<PointVectorValuePair>() {
             private final RealVector target = new ArrayRealVector(optimizer.getTarget(), false);
-            private final RealMatrix weight = optimizer.getWeight();
+            private final double[] weight   = optimizer.getNonCorrelatedWeight();
 
             public int compare(final PointVectorValuePair o1,
                                final PointVectorValuePair o2) {
@@ -114,7 +114,12 @@ public int compare(final PointVectorValuePair o1,
             private double weightedResidual(final PointVectorValuePair pv) {
                 final RealVector v = new ArrayRealVector(pv.getValueRef(), false);
                 final RealVector r = target.subtract(v);
-                return r.dotProduct(weight.operate(r));
+                double sum = 0;
+                for (int i = 0; i < r.getDimension(); ++i) {
+                    final double ri = r.getEntry(i);
+                    sum += ri * weight[i] * ri;
+                }
+                return sum;
             }
         };
     }
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java
index f43d387e9e..3a4b175176 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/MultivariateVectorOptimizer.java
@@ -17,14 +17,15 @@
 
 package org.apache.commons.math3.optim.nonlinear.vector;
 
-import org.apache.commons.math3.exception.TooManyEvaluationsException;
-import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.analysis.MultivariateVectorFunction;
-import org.apache.commons.math3.optim.OptimizationData;
+import org.apache.commons.math3.exception.DimensionMismatchException;
+import org.apache.commons.math3.exception.TooManyEvaluationsException;
+import org.apache.commons.math3.linear.RealMatrix;
 import org.apache.commons.math3.optim.BaseMultivariateOptimizer;
 import org.apache.commons.math3.optim.ConvergenceChecker;
+import org.apache.commons.math3.optim.OptimizationData;
 import org.apache.commons.math3.optim.PointVectorValuePair;
-import org.apache.commons.math3.linear.RealMatrix;
+import org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer;
 
 /**
  * Base class for a multivariate vector function optimizer.
@@ -36,8 +37,13 @@ public abstract class MultivariateVectorOptimizer
     extends BaseMultivariateOptimizer<PointVectorValuePair> {
     /** Target values for the model function at optimum. */
     private double[] target;
-    /** Weight matrix. */
+    /** Weight matrix.
+     * @deprecated as of 3.1.1, replaced by weight
+     */
+    @Deprecated
     private RealMatrix weightMatrix;
+    /** Weight vector. */
+    private double[] weight;
     /** Model function. */
     private MultivariateVectorFunction model;
 
@@ -65,14 +71,25 @@ protected double[] computeObjectiveValue(double[] params) {
 
     /**
      * {@inheritDoc}
-     *
+     * <p>
+     * Note that for version 3.1 of Apache Commons Math, a general <code>Weight</code>
+     * data was looked for, which could hold arbitrary square matrices and not only
+     * vector as the current {@link NonCorrelatedWeight} does. This was flawed as some
+     * optimizers like {@link GaussNewtonOptimizer} only considered the diagonal elements.
+     * This feature was deprecated. If users need non-diagonal weights to handle correlated
+     * observations, they will have to implement it by themselves using pre-multiplication
+     * by a matrix in both their function implementation and observation vectors. There is
+     * no direct support for this anymore in the Apache Commons Math library. The only
+     * feature that is supported here is a convenience feature for non-correlated observations,
+     * with vector only weights (i.e. weight[i] is the weight for observation i).
+     * </p>
      * @param optData Optimization data. The following data will be looked for:
      * <ul>
      *  <li>{@link org.apache.commons.math3.optim.MaxEval}</li>
      *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>
      *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>
      *  <li>{@link Target}</li>
-     *  <li>{@link Weight}</li>
+     *  <li>{@link NonCorrelatedWeight}</li>
      *  <li>{@link ModelFunction}</li>
      * </ul>
      * @return {@inheritDoc}
@@ -96,10 +113,22 @@ public PointVectorValuePair optimize(OptimizationData... optData)
      * Gets the weight matrix of the observations.
      *
      * @return the weight matrix.
+     * @deprecated as of 3.1.1, replaced by {@link #getNonCorrelatedWeight()}
      */
+    @Deprecated
     public RealMatrix getWeight() {
         return weightMatrix.copy();
     }
+
+    /**
+     * Gets the weights of the observations.
+     *
+     * @return the weights.
+     * @since 3.1.1
+     */
+    public double[] getNonCorrelatedWeight() {
+        return weight.clone();
+    }
     /**
      * Gets the observed values to be matched by the objective vector
      * function.
@@ -126,7 +155,7 @@ public int getTargetSize() {
      * @param optData Optimization data. The following data will be looked for:
      * <ul>
      *  <li>{@link Target}</li>
-     *  <li>{@link Weight}</li>
+     *  <li>{@link NonCorrelatedWeight}</li>
      *  <li>{@link ModelFunction}</li>
      * </ul>
      */
@@ -142,8 +171,18 @@ private void parseOptimizationData(OptimizationData... optData) {
                 target = ((Target) data).getTarget();
                 continue;
             }
+            if (data instanceof NonCorrelatedWeight) {
+                weight = ((NonCorrelatedWeight) data).getWeight();
+                continue;
+            }
+            // TODO: remove this for 4.0, when the Weight class will be removed
             if (data instanceof Weight) {
                 weightMatrix = ((Weight) data).getWeight();
+                weight = new double[weightMatrix.getColumnDimension()];
+                for (int i = 0; i < weight.length; ++i) {
+                    // extract the diagonal of the matrix
+                    weight[i] = weightMatrix.getEntry(i, i);
+                }
                 continue;
             }
         }
@@ -153,12 +192,11 @@ private void parseOptimizationData(OptimizationData... optData) {
      * Check parameters consistency.
      *
      * @throws DimensionMismatchException if {@link #target} and
-     * {@link #weightMatrix} have inconsistent dimensions.
+     * {@link #weight} have inconsistent dimensions.
      */
     private void checkParameters() {
-        if (target.length != weightMatrix.getColumnDimension()) {
-            throw new DimensionMismatchException(target.length,
-                                                 weightMatrix.getColumnDimension());
+        if (target.length != weight.length) {
+            throw new DimensionMismatchException(target.length, weight.length);
         }
     }
 }
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/NonCorrelatedWeight.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/NonCorrelatedWeight.java
new file mode 100644
index 0000000000..e23329c4cd
--- /dev/null
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/NonCorrelatedWeight.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.math3.optim.nonlinear.vector;
+
+import org.apache.commons.math3.optim.OptimizationData;
+
+/**
+ * Weight of the residuals between model and observations, when
+ * observations are non-correlated.
+ * <br/>
+ * Immutable class.
+ *
+ * @version $Id$
+ * @since 3.1.1
+ */
+public class NonCorrelatedWeight implements OptimizationData {
+
+    /** Weight. */
+    private final double[] weight;
+
+    /**
+     * Creates a weight vector.
+     *
+     * @param weight weight of the observations
+     */
+    public NonCorrelatedWeight(final double[] weight) {
+        this.weight = weight.clone();
+    }
+
+    /**
+     * Gets the weight.
+     *
+     * @return a fresh copy of the weight.
+     */
+    public double[] getWeight() {
+        return weight.clone();
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java
index 789bc256d4..1b58d81a3e 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java
@@ -28,22 +28,20 @@
  *
  * @version $Id: Weight.java 1416643 2012-12-03 19:37:14Z tn $
  * @since 3.1
+ * @deprecated as of 3.1.1, replaced by {@link NonCorrelatedWeight}
  */
+@Deprecated
 public class Weight implements OptimizationData {
     /** Weight matrix. */
     private final RealMatrix weightMatrix;
 
     /**
-     * Creates a diagonal weight matrix.
+     * Creates a weight matrix.
      *
-     * @param weight List of the values of the diagonal.
+     * @param weight matrix elements.
      */
-    public Weight(double[] weight) {
-        final int dim = weight.length;
-        weightMatrix = MatrixUtils.createRealMatrix(dim, dim);
-        for (int i = 0; i < dim; i++) {
-            weightMatrix.setEntry(i, i, weight[i]);
-        }
+    public Weight(double[][] weight) {
+        weightMatrix = MatrixUtils.createRealMatrix(weight);
     }
 
     /**
@@ -61,9 +59,9 @@ public Weight(RealMatrix weight) {
     }
 
     /**
-     * Gets the initial guess.
+     * Gets the weight.
      *
-     * @return the initial guess.
+     * @return a fresh copy of the weight.
      */
     public RealMatrix getWeight() {
         return weightMatrix.copy();
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java
index b7bb6f575f..7b2c6b51ed 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java
@@ -19,16 +19,18 @@
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.TooManyEvaluationsException;
 import org.apache.commons.math3.linear.ArrayRealVector;
-import org.apache.commons.math3.linear.RealMatrix;
 import org.apache.commons.math3.linear.DecompositionSolver;
+import org.apache.commons.math3.linear.EigenDecomposition;
 import org.apache.commons.math3.linear.MatrixUtils;
 import org.apache.commons.math3.linear.QRDecomposition;
-import org.apache.commons.math3.linear.EigenDecomposition;
-import org.apache.commons.math3.optim.OptimizationData;
+import org.apache.commons.math3.linear.RealMatrix;
 import org.apache.commons.math3.optim.ConvergenceChecker;
+import org.apache.commons.math3.optim.OptimizationData;
 import org.apache.commons.math3.optim.PointVectorValuePair;
-import org.apache.commons.math3.optim.nonlinear.vector.Weight;
 import org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer;
+import org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer;
+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;
+import org.apache.commons.math3.optim.nonlinear.vector.Weight;
 import org.apache.commons.math3.util.FastMath;
 
 /**
@@ -40,8 +42,13 @@
  */
 public abstract class AbstractLeastSquaresOptimizer
     extends JacobianMultivariateVectorOptimizer {
-    /** Square-root of the weight matrix. */
+    /** Square-root of the weight matrix.
+     * @deprecated as of 3.1.1, replaced by {@link #weight}
+     */
+    @Deprecated
     private RealMatrix weightMatrixSqrt;
+    /** Square-root of the weight vector. */
+    private double[] weightSquareRoot;
     /** Cost value (square root of the sum of the residuals). */
     private double cost;
 
@@ -61,7 +68,23 @@ protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair>
      * match problem dimension.
      */
     protected RealMatrix computeWeightedJacobian(double[] params) {
-        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));
+
+        final double[][] jacobian = computeJacobian(params);
+
+        if (weightSquareRoot != null) {
+            for (int i = 0; i < jacobian.length; ++i) {
+                final double wi = weightSquareRoot[i];
+                final double[] row = jacobian[i];
+                for (int j = 0; j < row.length; ++j) {
+                    row[j] *= wi;
+                }
+            }
+            return MatrixUtils.createRealMatrix(jacobian);
+        } else {
+            // TODO: remove for 4.0, when the {@link Weight} class will be removed
+            return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(jacobian));
+        }
+
     }
 
     /**
@@ -73,7 +96,13 @@ protected RealMatrix computeWeightedJacobian(double[] params) {
      */
     protected double computeCost(double[] residuals) {
         final ArrayRealVector r = new ArrayRealVector(residuals);
-        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));
+        final double[] weight = getNonCorrelatedWeight();
+        double sum = 0;
+        for (int i = 0; i < r.getDimension(); ++i) {
+            final double ri = r.getEntry(i);
+            sum += ri * weight[i] * ri;
+        }
+        return FastMath.sqrt(sum);
     }
 
     /**
@@ -105,7 +134,9 @@ public double getChiSquare() {
      * Gets the square-root of the weight matrix.
      *
      * @return the square-root of the weight matrix.
+     * @deprecated as of 3.1.1, replaced with {@link MultivariateVectorOptimizer#getNonCorrelatedWeight()}
      */
+    @Deprecated
     public RealMatrix getWeightSquareRoot() {
         return weightMatrixSqrt.copy();
     }
@@ -183,7 +214,7 @@ public double[] computeSigma(double[] params,
      *  <li>{@link org.apache.commons.math3.optim.InitialGuess}</li>
      *  <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li>
      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Target}</li>
-     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li>
+     *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight}</li>
      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunction}</li>
      *  <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian}</li>
      * </ul>
@@ -235,8 +266,7 @@ protected double[] computeResiduals(double[] objectiveValue) {
     /**
      * Scans the list of (required and optional) optimization data that
      * characterize the problem.
-     * If the weight matrix is specified, the {@link #weightMatrixSqrt}
-     * field is recomputed.
+     * If the weight is specified, the {@link #weightSquareRoot} field is recomputed.
      *
      * @param optData Optimization data. The following data will be looked for:
      * <ul>
@@ -248,22 +278,19 @@ private void parseOptimizationData(OptimizationData... optData) {
         // not provided in the argument list.
         for (OptimizationData data : optData) {
             if (data instanceof Weight) {
-                weightMatrixSqrt = squareRoot(((Weight) data).getWeight());
-                // If more data must be parsed, this statement _must_ be
-                // changed to "continue".
-                break;
+                // TODO: remove for 4.0, when the {@link Weight} class will be removed
+                weightSquareRoot = null;
+                final RealMatrix w = ((Weight) data).getWeight();
+                final EigenDecomposition dec = new EigenDecomposition(w);
+                weightMatrixSqrt = dec.getSquareRoot();
+            } else if (data instanceof NonCorrelatedWeight) {
+                weightSquareRoot = ((NonCorrelatedWeight) data).getWeight();
+                for (int i = 0; i < weightSquareRoot.length; ++i) {
+                    weightSquareRoot[i] = FastMath.sqrt(weightSquareRoot[i]);
+                }
+                weightMatrixSqrt = null;
             }
         }
     }
 
-    /**
-     * Computes the square-root of the weight matrix.
-     *
-     * @param m Symmetric, positive-definite (weight) matrix.
-     * @return the square-root of the weight matrix.
-     */
-    private RealMatrix squareRoot(RealMatrix m) {
-        final EigenDecomposition dec = new EigenDecomposition(m);
-        return dec.getSquareRoot();
-    }
 }
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
index 6aa684dd54..bb6cc8f974 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
@@ -17,8 +17,8 @@
 package org.apache.commons.math3.optim.nonlinear.vector.jacobian;
 
 import org.apache.commons.math3.exception.ConvergenceException;
-import org.apache.commons.math3.exception.NullArgumentException;
 import org.apache.commons.math3.exception.MathInternalError;
+import org.apache.commons.math3.exception.NullArgumentException;
 import org.apache.commons.math3.exception.util.LocalizedFormats;
 import org.apache.commons.math3.linear.ArrayRealVector;
 import org.apache.commons.math3.linear.BlockRealMatrix;
@@ -83,12 +83,7 @@ public PointVectorValuePair doOptimize() {
         final double[] targetValues = getTarget();
         final int nR = targetValues.length; // Number of observed data.
 
-        final RealMatrix weightMatrix = getWeight();
-        // Diagonal of the weight matrix.
-        final double[] residualsWeights = new double[nR];
-        for (int i = 0; i < nR; i++) {
-            residualsWeights[i] = weightMatrix.getEntry(i, i);
-        }
+        final double[] residualsWeights = getNonCorrelatedWeight();
 
         final double[] currentPoint = getStartPoint();
         final int nC = currentPoint.length;
diff --git a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
index e3b2a3fa5a..e9cb6923ae 100644
--- a/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
@@ -17,13 +17,14 @@
 package org.apache.commons.math3.optim.nonlinear.vector.jacobian;
 
 import java.util.Arrays;
+
 import org.apache.commons.math3.exception.ConvergenceException;
 import org.apache.commons.math3.exception.util.LocalizedFormats;
-import org.apache.commons.math3.optim.PointVectorValuePair;
-import org.apache.commons.math3.optim.ConvergenceChecker;
 import org.apache.commons.math3.linear.RealMatrix;
-import org.apache.commons.math3.util.Precision;
+import org.apache.commons.math3.optim.ConvergenceChecker;
+import org.apache.commons.math3.optim.PointVectorValuePair;
 import org.apache.commons.math3.util.FastMath;
+import org.apache.commons.math3.util.Precision;
 
 
 /**
@@ -300,7 +301,7 @@ protected PointVectorValuePair doOptimize() {
         double[] work2   = new double[nC];
         double[] work3   = new double[nC];
 
-        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();
+        final double[] weight = getNonCorrelatedWeight();
 
         // Evaluate the function at the starting point and calculate its norm.
         double[] currentObjective = computeObjectiveValue(currentPoint);
@@ -320,7 +321,10 @@ protected PointVectorValuePair doOptimize() {
             // QR decomposition of the jacobian matrix
             qrDecomposition(computeWeightedJacobian(currentPoint));
 
-            weightedResidual = weightMatrixSqrt.operate(currentResiduals);
+            weightedResidual = new double[currentResiduals.length];
+            for (int i = 0; i < weightedResidual.length; ++i) {
+                weightedResidual[i] = FastMath.sqrt(weight[i]) * currentResiduals[i];
+            }
             for (int i = 0; i < nR; i++) {
                 qtf[i] = weightedResidual[i];
             }
diff --git a/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java b/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java
index b695ee63ed..73603cdb9f 100644
--- a/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java
+++ b/src/test/java/org/apache/commons/math3/fitting/PolynomialFitterTest.java
@@ -220,6 +220,33 @@ public void testRedundantUnsolvable() {
         checkUnsolvableProblem(new GaussNewtonOptimizer(true, new SimpleVectorValueChecker(1e-15, 1e-15)), false);
     }
 
+    @Test
+    public void testLargeSample() {
+        Random randomizer = new Random(0x5551480dca5b369bl);
+        double maxError = 0;
+        for (int degree = 0; degree < 10; ++degree) {
+            PolynomialFunction p = buildRandomPolynomial(degree, randomizer);
+
+            PolynomialFitter fitter = new PolynomialFitter(new LevenbergMarquardtOptimizer());
+            for (int i = 0; i < 40000; ++i) {
+                double x = -1.0 + i / 20000.0;
+                fitter.addObservedPoint(1.0, x,
+                                        p.value(x) + 0.1 * randomizer.nextGaussian());
+            }
+
+            final double[] init = new double[degree + 1];
+            PolynomialFunction fitted = new PolynomialFunction(fitter.fit(init));
+
+            for (double x = -1.0; x < 1.0; x += 0.01) {
+                double error = FastMath.abs(p.value(x) - fitted.value(x)) /
+                              (1.0 + FastMath.abs(p.value(x)));
+                maxError = FastMath.max(maxError, error);
+                Assert.assertTrue(FastMath.abs(error) < 0.01);
+            }
+        }
+        Assert.assertTrue(maxError > 0.001);
+    }
+
     private void checkUnsolvableProblem(MultivariateVectorOptimizer optimizer,
                                         boolean solvable) {
         Random randomizer = new Random(1248788532l);
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java
index e92091f273..93cbe80b08 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/MultiStartMultivariateVectorOptimizerTest.java
@@ -16,13 +16,12 @@
  */
 package org.apache.commons.math3.optim.nonlinear.vector;
 
-import org.apache.commons.math3.analysis.MultivariateVectorFunction;
 import org.apache.commons.math3.analysis.MultivariateMatrixFunction;
-import org.apache.commons.math3.exception.MathIllegalStateException;
+import org.apache.commons.math3.analysis.MultivariateVectorFunction;
 import org.apache.commons.math3.linear.BlockRealMatrix;
 import org.apache.commons.math3.linear.RealMatrix;
-import org.apache.commons.math3.optim.MaxEval;
 import org.apache.commons.math3.optim.InitialGuess;
+import org.apache.commons.math3.optim.MaxEval;
 import org.apache.commons.math3.optim.PointVectorValuePair;
 import org.apache.commons.math3.optim.SimpleVectorValueChecker;
 import org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer;
@@ -130,7 +129,7 @@ public void testTrivial() {
                                  problem.getModelFunction(),
                                  problem.getModelFunctionJacobian(),
                                  problem.getTarget(),
-                                 new Weight(new double[] { 1 }),
+                                 new NonCorrelatedWeight(new double[] { 1 }),
                                  new InitialGuess(new double[] { 0 }));
         Assert.assertEquals(1.5, optimum.getPoint()[0], 1e-10);
         Assert.assertEquals(3.0, optimum.getValue()[0], 1e-10);
@@ -161,7 +160,7 @@ public void testNoOptimum() {
             = new MultiStartMultivariateVectorOptimizer(underlyingOptimizer, 10, generator);
         optimizer.optimize(new MaxEval(100),
                            new Target(new double[] { 0 }),
-                           new Weight(new double[] { 1 }),
+                           new NonCorrelatedWeight(new double[] { 1 }),
                            new InitialGuess(new double[] { 0 }),
                            new ModelFunction(new MultivariateVectorFunction() {
                                    public double[] value(double[] point) {
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java
index cc86ae0f4e..6f62df49c6 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerAbstractTest.java
@@ -17,23 +17,22 @@
 package org.apache.commons.math3.optim.nonlinear.vector.jacobian;
 
 import java.io.IOException;
-import java.io.Serializable;
 import java.util.Arrays;
-import org.apache.commons.math3.analysis.MultivariateVectorFunction;
+
 import org.apache.commons.math3.analysis.MultivariateMatrixFunction;
+import org.apache.commons.math3.analysis.MultivariateVectorFunction;
 import org.apache.commons.math3.exception.ConvergenceException;
 import org.apache.commons.math3.exception.DimensionMismatchException;
-import org.apache.commons.math3.exception.NumberIsTooSmallException;
 import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
 import org.apache.commons.math3.linear.BlockRealMatrix;
 import org.apache.commons.math3.linear.RealMatrix;
-import org.apache.commons.math3.optim.PointVectorValuePair;
 import org.apache.commons.math3.optim.InitialGuess;
 import org.apache.commons.math3.optim.MaxEval;
-import org.apache.commons.math3.optim.nonlinear.vector.Target;
-import org.apache.commons.math3.optim.nonlinear.vector.Weight;
+import org.apache.commons.math3.optim.PointVectorValuePair;
 import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;
 import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;
+import org.apache.commons.math3.optim.nonlinear.vector.Target;
+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;
 import org.apache.commons.math3.util.FastMath;
 import org.junit.Assert;
 import org.junit.Test;
@@ -115,7 +114,7 @@ public void testTrivial() {
                                problem.getModelFunction(),
                                problem.getModelFunctionJacobian(),
                                problem.getTarget(),
-                               new Weight(new double[] { 1 }),
+                               new NonCorrelatedWeight(new double[] { 1 }),
                                new InitialGuess(new double[] { 0 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(1.5, optimum.getPoint()[0], 1e-10);
@@ -135,7 +134,7 @@ public void testQRColumnsPermutation() {
                                problem.getModelFunction(),
                                problem.getModelFunctionJacobian(),
                                problem.getTarget(),
-                               new Weight(new double[] { 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1 }),
                                new InitialGuess(new double[] { 0, 0 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(7, optimum.getPoint()[0], 1e-10);
@@ -161,7 +160,7 @@ public void testNoDependency() {
                                problem.getModelFunction(),
                                problem.getModelFunctionJacobian(),
                                problem.getTarget(),
-                               new Weight(new double[] { 1, 1, 1, 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1, 1 }),
                                new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         for (int i = 0; i < problem.target.length; ++i) {
@@ -183,7 +182,7 @@ public void testOneSet() {
                                problem.getModelFunction(),
                                problem.getModelFunctionJacobian(),
                                problem.getTarget(),
-                               new Weight(new double[] { 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1 }),
                                new InitialGuess(new double[] { 0, 0, 0 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(1, optimum.getPoint()[0], 1e-10);
@@ -209,7 +208,7 @@ public void testTwoSets() {
                                problem.getModelFunction(),
                                problem.getModelFunctionJacobian(),
                                problem.getTarget(),
-                               new Weight(new double[] { 1, 1, 1, 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1, 1 }),
                                new InitialGuess(new double[] { 0, 0, 0, 0, 0, 0 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(3, optimum.getPoint()[0], 1e-10);
@@ -235,7 +234,7 @@ public void testNonInvertible() throws Exception {
                            problem.getModelFunction(),
                            problem.getModelFunctionJacobian(),
                            problem.getTarget(),
-                           new Weight(new double[] { 1, 1, 1 }),
+                           new NonCorrelatedWeight(new double[] { 1, 1, 1 }),
                            new InitialGuess(new double[] { 0, 0, 0 }));
     }
 
@@ -253,7 +252,7 @@ public void testIllConditioned() {
                                problem1.getModelFunction(),
                                problem1.getModelFunctionJacobian(),
                                problem1.getTarget(),
-                               new Weight(new double[] { 1, 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1 }),
                                new InitialGuess(new double[] { 0, 1, 2, 3 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(1, optimum1.getPoint()[0], 1e-10);
@@ -272,7 +271,7 @@ public void testIllConditioned() {
                                problem2.getModelFunction(),
                                problem2.getModelFunctionJacobian(),
                                problem2.getTarget(), 
-                               new Weight(new double[] { 1, 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1 }),
                                new InitialGuess(new double[] { 0, 1, 2, 3 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(-81, optimum2.getPoint()[0], 1e-8);
@@ -295,7 +294,7 @@ public void testMoreEstimatedParametersSimple() {
                            problem.getModelFunction(),
                            problem.getModelFunctionJacobian(),
                            problem.getTarget(),
-                           new Weight(new double[] { 1, 1, 1 }),
+                           new NonCorrelatedWeight(new double[] { 1, 1, 1 }),
                            new InitialGuess(new double[] { 7, 6, 5, 4 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
     }
@@ -316,7 +315,7 @@ public void testMoreEstimatedParametersUnsorted() {
                                problem.getModelFunction(),
                                problem.getModelFunctionJacobian(),
                                problem.getTarget(),
-                               new Weight(new double[] { 1, 1, 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1 }),
                                new InitialGuess(new double[] { 2, 2, 2, 2, 2, 2 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(3, optimum.getPointRef()[2], 1e-10);
@@ -339,7 +338,7 @@ public void testRedundantEquations() {
                                problem.getModelFunction(),
                                problem.getModelFunctionJacobian(),
                                problem.getTarget(),
-                               new Weight(new double[] { 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1 }),
                                new InitialGuess(new double[] { 1, 1 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(2, optimum.getPointRef()[0], 1e-10);
@@ -359,7 +358,7 @@ public void testInconsistentEquations() {
                            problem.getModelFunction(),
                            problem.getModelFunctionJacobian(),
                            problem.getTarget(),
-                           new Weight(new double[] { 1, 1, 1 }),
+                           new NonCorrelatedWeight(new double[] { 1, 1, 1 }),
                            new InitialGuess(new double[] { 1, 1 }));
         Assert.assertTrue(optimizer.getRMS() > 0.1);
     }
@@ -375,7 +374,7 @@ public void testInconsistentSizes1() {
                                problem.getModelFunction(),
                                problem.getModelFunctionJacobian(),
                                problem.getTarget(),
-                               new Weight(new double[] { 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1 }),
                                new InitialGuess(new double[] { 0, 0 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(-1, optimum.getPoint()[0], 1e-10);
@@ -385,7 +384,7 @@ public void testInconsistentSizes1() {
                            problem.getModelFunction(),
                            problem.getModelFunctionJacobian(),
                            problem.getTarget(),
-                           new Weight(new double[] { 1 }),
+                           new NonCorrelatedWeight(new double[] { 1 }),
                            new InitialGuess(new double[] { 0, 0 }));
     }
 
@@ -400,7 +399,7 @@ public void testInconsistentSizes2() {
                                  problem.getModelFunction(),
                                  problem.getModelFunctionJacobian(),
                                  problem.getTarget(),
-                                 new Weight(new double[] { 1, 1 }),
+                                 new NonCorrelatedWeight(new double[] { 1, 1 }),
                                  new InitialGuess(new double[] { 0, 0 }));
         Assert.assertEquals(0, optimizer.getRMS(), 1e-10);
         Assert.assertEquals(-1, optimum.getPoint()[0], 1e-10);
@@ -410,7 +409,7 @@ public void testInconsistentSizes2() {
                            problem.getModelFunction(),
                            problem.getModelFunctionJacobian(),
                            new Target(new double[] { 1 }),
-                           new Weight(new double[] { 1 }),
+                           new NonCorrelatedWeight(new double[] { 1 }),
                            new InitialGuess(new double[] { 0, 0 }));
     }
 
@@ -428,7 +427,7 @@ public void testCircleFitting() {
                                  circle.getModelFunction(),
                                  circle.getModelFunctionJacobian(),
                                  new Target(new double[] { 0, 0, 0, 0, 0 }),
-                                 new Weight(new double[] { 1, 1, 1, 1, 1 }),
+                                 new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1 }),
                                  new InitialGuess(new double[] { 98.680, 47.345 }));
         Assert.assertTrue(optimizer.getEvaluations() < 10);
         double rms = optimizer.getRMS();
@@ -456,7 +455,7 @@ public void testCircleFitting() {
                                      circle.getModelFunction(),
                                      circle.getModelFunctionJacobian(),
                                      new Target(target),
-                                     new Weight(weights),
+                                     new NonCorrelatedWeight(weights),
                                      new InitialGuess(new double[] { 98.680, 47.345 }));
         cov = optimizer.computeCovariances(optimum.getPoint(), 1e-14);
         Assert.assertEquals(0.0016, cov[0][0], 0.001);
@@ -482,7 +481,7 @@ public void testCircleFittingBadInit() {
                                  circle.getModelFunction(),
                                  circle.getModelFunctionJacobian(),
                                  new Target(target),
-                                 new Weight(weights),
+                                 new NonCorrelatedWeight(weights),
                                  new InitialGuess(new double[] { -12, -12 }));
         Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]);
         Assert.assertTrue(optimizer.getEvaluations() < 25);
@@ -509,7 +508,7 @@ public void testCircleFittingGoodInit() {
                                circle.getModelFunction(),
                                circle.getModelFunctionJacobian(),
                                new Target(target),
-                               new Weight(weights),
+                               new NonCorrelatedWeight(weights),
                                new InitialGuess(new double[] { 0, 0 }));
         Assert.assertEquals(-0.1517383071957963, optimum.getPointRef()[0], 1e-6);
         Assert.assertEquals(0.2074999736353867,  optimum.getPointRef()[1], 1e-6);
@@ -563,7 +562,7 @@ public void doTestStRD(final StatisticalReferenceDataset dataset,
                                  problem.getModelFunction(),
                                  problem.getModelFunctionJacobian(),
                                  new Target(data[1]),
-                                 new Weight(w),
+                                 new NonCorrelatedWeight(w),
                                  new InitialGuess(initial));
 
         final double[] actual = optimum.getPoint();
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTest.java
index 7197616315..5b7f9ec5e3 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTest.java
@@ -15,14 +15,15 @@
 
 import java.io.IOException;
 import java.util.Arrays;
-import org.apache.commons.math3.optim.PointVectorValuePair;
+
 import org.apache.commons.math3.optim.InitialGuess;
 import org.apache.commons.math3.optim.MaxEval;
+import org.apache.commons.math3.optim.PointVectorValuePair;
 import org.apache.commons.math3.optim.nonlinear.vector.Target;
-import org.apache.commons.math3.optim.nonlinear.vector.Weight;
+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;
 import org.apache.commons.math3.util.FastMath;
-import org.junit.Test;
 import org.junit.Assert;
+import org.junit.Test;
 
 public class AbstractLeastSquaresOptimizerTest {
 
@@ -56,7 +57,7 @@ public void testGetChiSquare() throws IOException {
                            problem.getModelFunction(),
                            problem.getModelFunctionJacobian(),
                            new Target(y),
-                           new Weight(w),
+                           new NonCorrelatedWeight(w),
                            new InitialGuess(a));
         final double expected = dataset.getResidualSumOfSquares();
         final double actual = optimizer.getChiSquare();
@@ -81,7 +82,7 @@ public void testGetRMS() throws IOException {
                            problem.getModelFunction(),
                            problem.getModelFunctionJacobian(),
                            new Target(y),
-                           new Weight(w),
+                           new NonCorrelatedWeight(w),
                            new InitialGuess(a));
 
         final double expected = FastMath
@@ -110,7 +111,7 @@ public void testComputeSigma() throws IOException {
                                  problem.getModelFunction(),
                                  problem.getModelFunctionJacobian(),
                                  new Target(y),
-                                 new Weight(w),
+                                 new NonCorrelatedWeight(w),
                                  new InitialGuess(a));
 
         final double[] sig = optimizer.computeSigma(optimum.getPoint(), 1e-14);
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTestValidation.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTestValidation.java
index d9aa76141b..33f91c5bd4 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTestValidation.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizerTestValidation.java
@@ -13,20 +13,21 @@
  */
 package org.apache.commons.math3.optim.nonlinear.vector.jacobian;
 
+import java.awt.geom.Point2D;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
-import java.util.ArrayList;
-import java.awt.geom.Point2D;
-import org.apache.commons.math3.optim.PointVectorValuePair;
+
 import org.apache.commons.math3.optim.InitialGuess;
 import org.apache.commons.math3.optim.MaxEval;
+import org.apache.commons.math3.optim.PointVectorValuePair;
 import org.apache.commons.math3.optim.nonlinear.vector.Target;
-import org.apache.commons.math3.optim.nonlinear.vector.Weight;
-import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;
 import org.apache.commons.math3.stat.descriptive.StatisticalSummary;
+import org.apache.commons.math3.stat.descriptive.SummaryStatistics;
 import org.apache.commons.math3.util.FastMath;
-import org.junit.Test;
 import org.junit.Assert;
+import org.junit.Test;
 
 /**
  * This class demonstrates the main functionality of the
@@ -124,7 +125,7 @@ public void testParametersErrorMonteCarloObservations() {
                                  problem.getModelFunction(),
                                  problem.getModelFunctionJacobian(),
                                  new Target(problem.target()),
-                                 new Weight(problem.weight()),
+                                 new NonCorrelatedWeight(problem.weight()),
                                  new InitialGuess(init));
             final double[] sigma = optim.computeSigma(optimum.getPoint(), 1e-14);
 
@@ -305,7 +306,7 @@ private double getChi2N(AbstractLeastSquaresOptimizer optim,
                        problem.getModelFunction(),
                        problem.getModelFunctionJacobian(),
                        new Target(t),
-                       new Weight(w),
+                       new NonCorrelatedWeight(w),
                        new InitialGuess(params));
 
         return optim.getChiSquare() / (t.length - params.length);
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizerTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizerTest.java
index af23e3f881..0465c3a11d 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizerTest.java
@@ -18,15 +18,14 @@
 package org.apache.commons.math3.optim.nonlinear.vector.jacobian;
 
 import java.io.IOException;
+
 import org.apache.commons.math3.exception.ConvergenceException;
 import org.apache.commons.math3.exception.TooManyEvaluationsException;
-import org.apache.commons.math3.optim.SimpleVectorValueChecker;
 import org.apache.commons.math3.optim.InitialGuess;
 import org.apache.commons.math3.optim.MaxEval;
+import org.apache.commons.math3.optim.SimpleVectorValueChecker;
 import org.apache.commons.math3.optim.nonlinear.vector.Target;
-import org.apache.commons.math3.optim.nonlinear.vector.Weight;
-import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;
-import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;
+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;
 import org.junit.Test;
 
 /**
@@ -133,7 +132,7 @@ public void testMaxEvaluations() throws Exception {
                            circle.getModelFunction(),
                            circle.getModelFunctionJacobian(),
                            new Target(new double[] { 0, 0, 0, 0, 0 }),
-                           new Weight(new double[] { 1, 1, 1, 1, 1 }),
+                           new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1 }),
                            new InitialGuess(new double[] { 98.680, 47.345 }));
     }
 
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizerTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizerTest.java
index 20a81ffb2e..4e1a222260 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizerTest.java
@@ -17,28 +17,26 @@
 
 package org.apache.commons.math3.optim.nonlinear.vector.jacobian;
 
-import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
-import org.apache.commons.math3.optim.PointVectorValuePair;
-import org.apache.commons.math3.optim.InitialGuess;
-import org.apache.commons.math3.optim.MaxEval;
-import org.apache.commons.math3.optim.nonlinear.vector.Target;
-import org.apache.commons.math3.optim.nonlinear.vector.Weight;
-import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;
-import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;
-import org.apache.commons.math3.analysis.MultivariateVectorFunction;
+
 import org.apache.commons.math3.analysis.MultivariateMatrixFunction;
-import org.apache.commons.math3.exception.ConvergenceException;
+import org.apache.commons.math3.analysis.MultivariateVectorFunction;
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.TooManyEvaluationsException;
 import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
 import org.apache.commons.math3.linear.SingularMatrixException;
+import org.apache.commons.math3.optim.InitialGuess;
+import org.apache.commons.math3.optim.MaxEval;
+import org.apache.commons.math3.optim.PointVectorValuePair;
+import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;
+import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;
+import org.apache.commons.math3.optim.nonlinear.vector.Target;
+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;
 import org.apache.commons.math3.util.FastMath;
 import org.apache.commons.math3.util.Precision;
 import org.junit.Assert;
 import org.junit.Test;
-import org.junit.Ignore;
 
 /**
  * <p>Some of the unit tests are re-implementations of the MINPACK <a
@@ -128,7 +126,7 @@ public void testNonInvertible() {
                                  problem.getModelFunction(),
                                  problem.getModelFunctionJacobian(),
                                  problem.getTarget(),
-                                 new Weight(new double[] { 1, 1, 1 }),
+                                 new NonCorrelatedWeight(new double[] { 1, 1, 1 }),
                                  new InitialGuess(new double[] { 0, 0, 0 }));
         Assert.assertTrue(FastMath.sqrt(optimizer.getTargetSize()) * optimizer.getRMS() > 0.6);
 
@@ -174,7 +172,7 @@ private void checkEstimate(ModelFunction problem,
                                problem,
                                problemJacobian,
                                new Target(new double[] { 0, 0, 0, 0, 0 }),
-                               new Weight(new double[] { 1, 1, 1, 1, 1 }),
+                               new NonCorrelatedWeight(new double[] { 1, 1, 1, 1, 1 }),
                                new InitialGuess(new double[] { 98.680, 47.345 }));
             Assert.assertTrue(!shouldFail);
         } catch (DimensionMismatchException ee) {
@@ -229,7 +227,7 @@ public void testBevington() {
                                  problem.getModelFunction(),
                                  problem.getModelFunctionJacobian(),
                                  new Target(dataPoints[1]),
-                                 new Weight(weights),
+                                 new NonCorrelatedWeight(weights),
                                  new InitialGuess(new double[] { 10, 900, 80, 27, 225 }));
 
         final double[] solution = optimum.getPoint();
@@ -293,7 +291,7 @@ public void testCircleFitting2() {
                                                                 circle.getModelFunction(),
                                                                 circle.getModelFunctionJacobian(),
                                                                 new Target(circle.target()),
-                                                                new Weight(circle.weight()),
+                                                                new NonCorrelatedWeight(circle.weight()),
                                                                 new InitialGuess(init));
 
         final double[] paramFound = optimum.getPoint();
diff --git a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/MinpackTest.java b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/MinpackTest.java
index 18e1ac6f52..ae8eb72ba8 100644
--- a/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/MinpackTest.java
+++ b/src/test/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/MinpackTest.java
@@ -17,18 +17,18 @@
 
 package org.apache.commons.math3.optim.nonlinear.vector.jacobian;
 
-import java.io.Serializable;
 import java.util.Arrays;
-import org.apache.commons.math3.exception.TooManyEvaluationsException;
-import org.apache.commons.math3.analysis.MultivariateVectorFunction;
+
 import org.apache.commons.math3.analysis.MultivariateMatrixFunction;
-import org.apache.commons.math3.optim.PointVectorValuePair;
+import org.apache.commons.math3.analysis.MultivariateVectorFunction;
+import org.apache.commons.math3.exception.TooManyEvaluationsException;
 import org.apache.commons.math3.optim.InitialGuess;
 import org.apache.commons.math3.optim.MaxEval;
-import org.apache.commons.math3.optim.nonlinear.vector.Target;
-import org.apache.commons.math3.optim.nonlinear.vector.Weight;
+import org.apache.commons.math3.optim.PointVectorValuePair;
 import org.apache.commons.math3.optim.nonlinear.vector.ModelFunction;
 import org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian;
+import org.apache.commons.math3.optim.nonlinear.vector.Target;
+import org.apache.commons.math3.optim.nonlinear.vector.NonCorrelatedWeight;
 import org.apache.commons.math3.util.FastMath;
 import org.junit.Assert;
 import org.junit.Test;
@@ -512,7 +512,7 @@ private void minpackTest(MinpackFunction function, boolean exceptionExpected) {
                                      function.getModelFunction(),
                                      function.getModelFunctionJacobian(),
                                      new Target(function.getTarget()),
-                                     new Weight(function.getWeight()),
+                                     new NonCorrelatedWeight(function.getWeight()),
                                      new InitialGuess(function.getStartPoint()));
             Assert.assertFalse(exceptionExpected);
             function.checkTheoreticalMinCost(optimizer.getRMS());
