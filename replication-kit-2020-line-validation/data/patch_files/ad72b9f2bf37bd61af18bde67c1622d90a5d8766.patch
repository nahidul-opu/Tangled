From ad72b9f2bf37bd61af18bde67c1622d90a5d8766 Mon Sep 17 00:00:00 2001
From: Sebastian Bazley <sebb@apache.org>
Date: Thu, 27 Sep 2012 00:09:15 +0000
Subject: [PATCH] LANG-831 FastDateParser does not handle white-space properly

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1390779 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  1 +
 .../commons/lang3/time/FastDateParser.java    |  9 ----
 .../lang3/time/FastDateParserTest.java        | 46 +++++++++++++++++++
 3 files changed, 47 insertions(+), 9 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 82b036ae3f9..b0244500ce3 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -22,6 +22,7 @@
   <body>
 
   <release version="3.2" date="TBA" description="Next release">
+    <action issue="LANG-831" type="fix">FastDateParser does not handle white-space properly</action>
     <action issue="LANG-828" type="fix">FastDateParser does not handle non-Gregorian calendars properly</action>
     <action issue="LANG-826" type="fix">FastDateParser does not handle non-ASCII digits correctly</action>
     <action issue="LANG-825" type="add">Create StrBuilder APIs similar to String.format(String, Object...)</action>
diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
index a01159bdbc4..8df302f9cf1 100644
--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
@@ -301,17 +301,8 @@ public Date parse(String source, ParsePosition pos) {
      * @return The <code>StringBuilder</code>
      */
     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {
-        boolean wasWhite= false;
         for(int i= 0; i<value.length(); ++i) {
             char c= value.charAt(i);
-            if(Character.isWhitespace(c)) {
-                if(!wasWhite) {
-                    wasWhite= true;
-                    regex.append("\\s*+");
-                }
-                continue;
-            }
-            wasWhite= false;
             switch(c) {
             case '\'':
                 if(unquote) {
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
index 5bbbfbedf27..ee5a5008b5f 100644
--- a/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java
@@ -333,6 +333,52 @@ public void testQuotes() throws ParseException {
         assertEquals(cal.getTime(), fdf.parse("'20030210A'B153320989'"));
     }
 
+
+    @Test
+    public void testLANG_831() throws Exception {
+        testSdfAndFdp("M E","3  Tue", true);
+    }
+
+    private void testSdfAndFdp(String format, String date, boolean shouldFail)
+            throws Exception {
+        Date dfdp = null;
+        Date dsdf = null;
+        Throwable f = null;
+        Throwable s = null;
+
+        try {
+            SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);
+            sdf.setTimeZone(NEW_YORK);
+            dsdf = sdf.parse(date);
+            if (shouldFail) {
+                Assert.fail("Expected SDF failure, but got " + dsdf + " for ["+format+","+date+"]");
+            }
+        } catch (Exception e) {
+            s = e;
+            if (!shouldFail) {
+                throw e;
+            }
+//            System.out.println("sdf:"+format+"/"+date+"=>"+e);
+        }
+
+        try {
+            DateParser fdp = getInstance(format, NEW_YORK, Locale.US);
+            dfdp = fdp.parse(date);
+            if (shouldFail) {
+                Assert.fail("Expected FDF failure, but got " + dfdp + " for ["+format+","+date+"] using "+((FastDateParser)fdp).getParsePattern());
+            }
+        } catch (Exception e) {
+            f = e;
+            if (!shouldFail) {
+                throw e;
+            }
+//            System.out.println("fdf:"+format+"/"+date+"=>"+e);
+        }
+        // SDF and FDF should produce equivalent results
+        assertTrue("Should both or neither throw Exceptions", (f==null)==(s==null));
+        assertEquals("Parsed dates should be equal", dsdf, dfdp);
+    }
+
     @Test
     public void testDayOf() throws ParseException {
         Calendar cal= Calendar.getInstance(NEW_YORK, Locale.US);
