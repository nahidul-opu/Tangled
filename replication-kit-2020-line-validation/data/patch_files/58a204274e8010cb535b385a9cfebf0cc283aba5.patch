From 58a204274e8010cb535b385a9cfebf0cc283aba5 Mon Sep 17 00:00:00 2001
From: Gilles Sadowski <erans@apache.org>
Date: Wed, 25 Apr 2012 14:49:44 +0000
Subject: [PATCH] MATH-782 Moved incorrectly placed block of code (user-defined
 stopping criterion). Added unit test. New utility class for simple stopping
 criterion based on (univariate) function values.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1330321 13f79535-47bb-0310-9956-ffa450edef68
---
 .../univariate/BrentOptimizer.java            | 20 ++---
 .../SimpleUnivariateValueChecker.java         | 84 +++++++++++++++++++
 .../univariate/BrentOptimizerTest.java        | 13 +++
 3 files changed, 107 insertions(+), 10 deletions(-)
 create mode 100644 src/main/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueChecker.java

diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
index 405eda570f..15a498c525 100644
--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
@@ -233,6 +233,16 @@ protected UnivariatePointValuePair doOptimize() {
                     fw = fx;
                     x = u;
                     fx = fu;
+
+                    // User-defined convergence checker.
+                    previous = current;
+                    current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
+
+                    if (checker != null) {
+                        if (checker.converged(iter, previous, current)) {
+                            return current;
+                        }
+                    }
                 } else {
                     if (u < x) {
                         a = u;
@@ -252,16 +262,6 @@ protected UnivariatePointValuePair doOptimize() {
                         fv = fu;
                     }
                 }
-
-                previous = current;
-                current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);
-
-                // User-defined convergence checker.
-                if (checker != null) {
-                    if (checker.converged(iter, previous, current)) {
-                        return current;
-                    }
-                }
             } else { // Default termination (Brent's criterion).
                 return current;
             }
diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueChecker.java b/src/main/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueChecker.java
new file mode 100644
index 0000000000..18949e0f5f
--- /dev/null
+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/SimpleUnivariateValueChecker.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.math3.optimization.univariate;
+
+import org.apache.commons.math3.util.FastMath;
+import org.apache.commons.math3.optimization.AbstractConvergenceChecker;
+
+/**
+ * Simple implementation of the
+ * {@link org.apache.commons.math3.optimization.ConvergenceChecker} interface
+ * that uses only objective function values.
+ *
+ * Convergence is considered to have been reached if either the relative
+ * difference between the objective function values is smaller than a
+ * threshold or if either the absolute difference between the objective
+ * function values is smaller than another threshold.
+ *
+ * @version $Id$
+ * @since 3.1
+ */
+public class SimpleUnivariateValueChecker
+    extends AbstractConvergenceChecker<UnivariatePointValuePair> {
+    /**
+     * Build an instance with default thresholds.
+     */
+    public SimpleUnivariateValueChecker() {}
+
+    /** Build an instance with specified thresholds.
+     *
+     * In order to perform only relative checks, the absolute tolerance
+     * must be set to a negative value. In order to perform only absolute
+     * checks, the relative tolerance must be set to a negative value.
+     *
+     * @param relativeThreshold relative tolerance threshold
+     * @param absoluteThreshold absolute tolerance threshold
+     */
+    public SimpleUnivariateValueChecker(final double relativeThreshold,
+                                        final double absoluteThreshold) {
+        super(relativeThreshold, absoluteThreshold);
+    }
+
+    /**
+     * Check if the optimization algorithm has converged considering the
+     * last two points.
+     * This method may be called several time from the same algorithm
+     * iteration with different points. This can be detected by checking the
+     * iteration number at each call if needed. Each time this method is
+     * called, the previous and current point correspond to points with the
+     * same role at each iteration, so they can be compared. As an example,
+     * simplex-based algorithms call this method for all points of the simplex,
+     * not only for the best or worst ones.
+     *
+     * @param iteration Index of current iteration
+     * @param previous Best point in the previous iteration.
+     * @param current Best point in the current iteration.
+     * @return {@code true} if the algorithm has converged.
+     */
+    @Override
+    public boolean converged(final int iteration,
+                             final UnivariatePointValuePair previous,
+                             final UnivariatePointValuePair current) {
+        final double p = previous.getValue();
+        final double c = current.getValue();
+        final double difference = FastMath.abs(p - c);
+        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));
+        return difference <= size * getRelativeThreshold() ||
+            difference <= getAbsoluteThreshold();
+    }
+}
diff --git a/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java b/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java
index d9d11a39ac..bf59e02bb8 100644
--- a/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math3/optimization/univariate/BrentOptimizerTest.java
@@ -24,6 +24,7 @@
 import org.apache.commons.math3.analysis.SinFunction;
 import org.apache.commons.math3.analysis.UnivariateFunction;
 import org.apache.commons.math3.optimization.GoalType;
+import org.apache.commons.math3.optimization.ConvergenceChecker;
 import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
 import org.junit.Assert;
 import org.junit.Test;
@@ -51,6 +52,18 @@ public void testSinMin() {
         }
     }
 
+    @Test
+    public void testSinMinWithValueChecker() {
+        final UnivariateFunction f = new SinFunction();
+        final ConvergenceChecker checker = new SimpleUnivariateValueChecker(1e-5, 1e-14);
+        // The default stopping criterion of Brent's algorithm should not
+        // pass, but the search will stop at the given relative tolerance
+        // for the function value.
+        final UnivariateOptimizer optimizer = new BrentOptimizer(1e-10, 1e-14, checker);
+        final UnivariatePointValuePair result = optimizer.optimize(200, f, GoalType.MINIMIZE, 4, 5);
+        Assert.assertEquals(3 * Math.PI / 2, result.getPoint(), 1e-3);
+    }
+
     @Test
     public void testBoundaries() {
         final double lower = -1.0;
