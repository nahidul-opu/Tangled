From 4080feff61e8dc1cd4af2361990c33c9f1014147 Mon Sep 17 00:00:00 2001
From: Thomas Neidhart <thomas.neidhart@gmail.com>
Date: Mon, 29 Sep 2014 18:25:54 +0200
Subject: [PATCH] [MATH-1148] Fix MonotoneChain with collinear points as input:
 take tolerance factor into account when initially sorting the input points.
 Thanks to Guillaume Marceau for the report.

---
 src/changes/changes.xml                       |  5 ++
 .../euclidean/twod/hull/ConvexHull2D.java     | 18 +++---
 .../euclidean/twod/hull/MonotoneChain.java    |  8 ++-
 .../ConvexHullGenerator2DAbstractTest.java    | 63 ++++++++++++++++---
 .../twod/hull/MonotoneChainTest.java          |  2 +-
 5 files changed, 78 insertions(+), 18 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index e25f90e95f..c64fb58792 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -73,6 +73,11 @@ Users are encouraged to upgrade to this version as this release not
   2. A few methods in the FastMath class are in fact slower that their
   counterpart in either Math or StrictMath (cf. MATH-740 and MATH-901).
 ">
+      <action dev="tn" type="fix" issue="MATH-1148" due-to="Guillaume Marceau">
+        "MonotoneChain" did not take the tolerance factor into account when
+        sorting the input points. In case of collinear points this could result
+        in a "ConvergenceException" when computing the hull.
+      </action>
       <action dev="erans" type="fix" issue="MATH-1151">
         Interface "ValueAndJacobianFunction" is a precondition for lazy
         evaluation (in "o.a.c.m.fitting.leastsquares").
diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java
index 1e0eec386f..5d9734b3b9 100644
--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java
+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHull2D.java
@@ -28,8 +28,8 @@
 import org.apache.commons.math3.geometry.hull.ConvexHull;
 import org.apache.commons.math3.geometry.partitioning.Region;
 import org.apache.commons.math3.geometry.partitioning.RegionFactory;
-import org.apache.commons.math3.util.FastMath;
 import org.apache.commons.math3.util.MathArrays;
+import org.apache.commons.math3.util.Precision;
 
 /**
  * This class represents a convex hull in an two-dimensional euclidean space.
@@ -62,12 +62,14 @@ public class ConvexHull2D implements ConvexHull<Euclidean2D, Vector2D>, Serializ
     public ConvexHull2D(final Vector2D[] vertices, final double tolerance)
         throws MathIllegalArgumentException {
 
+        // assign tolerance as it will be used by the isConvex method
+        this.tolerance = tolerance;
+
         if (!isConvex(vertices)) {
             throw new MathIllegalArgumentException(LocalizedFormats.NOT_CONVEX);
         }
 
         this.vertices = vertices.clone();
-        this.tolerance = tolerance;
     }
 
     /**
@@ -80,7 +82,7 @@ private boolean isConvex(final Vector2D[] hullVertices) {
             return true;
         }
 
-        double sign = 0.0;
+        int sign = 0;
         for (int i = 0; i < hullVertices.length; i++) {
             final Vector2D p1 = hullVertices[i == 0 ? hullVertices.length - 1 : i - 1];
             final Vector2D p2 = hullVertices[i];
@@ -89,14 +91,14 @@ private boolean isConvex(final Vector2D[] hullVertices) {
             final Vector2D d1 = p2.subtract(p1);
             final Vector2D d2 = p3.subtract(p2);
 
-            final double cross = FastMath.signum(MathArrays.linearCombination( d1.getX(), d2.getY(),
-                                                                              -d1.getY(), d2.getX()));
+            final double crossProduct = MathArrays.linearCombination(d1.getX(), d2.getY(), -d1.getY(), d2.getX());
+            final int cmp = Precision.compareTo(crossProduct, 0.0, tolerance);
             // in case of collinear points the cross product will be zero
-            if (cross != 0.0) {
-                if (sign != 0.0 && cross != sign) {
+            if (cmp != 0.0) {
+                if (sign != 0.0 && cmp != sign) {
                     return false;
                 }
-                sign = cross;
+                sign = cmp;
             }
         }
 
diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java
index 6e56fc634f..a811ddaceb 100644
--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java
+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChain.java
@@ -25,6 +25,7 @@
 import org.apache.commons.math3.geometry.euclidean.twod.Line;
 import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
 import org.apache.commons.math3.util.FastMath;
+import org.apache.commons.math3.util.Precision;
 
 /**
  * Implements Andrew's monotone chain method to generate the convex hull of a finite set of
@@ -80,9 +81,12 @@ public Collection<Vector2D> findHullVertices(final Collection<Vector2D> points)
         // sort the points in increasing order on the x-axis
         Collections.sort(pointsSortedByXAxis, new Comparator<Vector2D>() {
             public int compare(final Vector2D o1, final Vector2D o2) {
-                final int diff = (int) FastMath.signum(o1.getX() - o2.getX());
+                final double tolerance = getTolerance();
+                // need to take the tolerance value into account, otherwise collinear points
+                // will not be handled correctly when building the upper/lower hull
+                final int diff = Precision.compareTo(o1.getX(), o2.getX(), tolerance);
                 if (diff == 0) {
-                    return (int) FastMath.signum(o1.getY() - o2.getY());
+                    return Precision.compareTo(o1.getY(), o2.getY(), tolerance);
                 } else {
                     return diff;
                 }
diff --git a/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java b/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java
index 3e1552db17..0c52550cda 100644
--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java
+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/ConvexHullGenerator2DAbstractTest.java
@@ -30,6 +30,8 @@
 import org.apache.commons.math3.random.MersenneTwister;
 import org.apache.commons.math3.random.RandomGenerator;
 import org.apache.commons.math3.util.FastMath;
+import org.apache.commons.math3.util.MathArrays;
+import org.apache.commons.math3.util.Precision;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
@@ -223,6 +225,46 @@ public void testCollinearPointOnExistingBoundary() {
         checkConvexHull(points, hull);
     }
 
+    @Test
+    public void testCollinearPointsInAnyOrder() {
+        // MATH-1148: collinear points on the hull might be in any order
+        //            make sure that they are processed in the proper order
+        //            for each algorithm.
+
+        List<Vector2D> points = new ArrayList<Vector2D>();
+
+        // first case: 3 points are collinear
+        points.add(new Vector2D(16.078200000000184, -36.52519999989808));
+        points.add(new Vector2D(19.164300000000186, -36.52519999989808));
+        points.add(new Vector2D(19.1643, -25.28136477910407));
+        points.add(new Vector2D(19.1643, -17.678400000004157));
+
+        ConvexHull2D hull = createConvexHullGenerator(false).generate(points);
+        checkConvexHull(points, hull);
+
+        hull = createConvexHullGenerator(true).generate(points);
+        checkConvexHull(points, hull, true);
+        
+        points.clear();
+        
+        // second case: multiple points are collinear
+        points.add(new Vector2D(0, -29.959696875));
+        points.add(new Vector2D(0, -31.621809375));
+        points.add(new Vector2D(0, -28.435696875));
+        points.add(new Vector2D(0, -33.145809375));
+        points.add(new Vector2D(3.048, -33.145809375));
+        points.add(new Vector2D(3.048, -31.621809375));
+        points.add(new Vector2D(3.048, -29.959696875));
+        points.add(new Vector2D(4.572, -33.145809375));
+        points.add(new Vector2D(4.572, -28.435696875));
+
+        hull = createConvexHullGenerator(false).generate(points);
+        checkConvexHull(points, hull);
+
+        hull = createConvexHullGenerator(true).generate(points);
+        checkConvexHull(points, hull, true);
+    }
+
     @Test
     public void testIssue1123() {
 
@@ -337,16 +379,22 @@ protected final void checkConvexHull(final Collection<Vector2D> points, final Co
 
     protected final void checkConvexHull(final Collection<Vector2D> points, final ConvexHull2D hull,
                                          final boolean includesCollinearPoints) {
+        checkConvexHull(points, hull, includesCollinearPoints, 1e-10);
+    }
+
+    protected final void checkConvexHull(final Collection<Vector2D> points, final ConvexHull2D hull,
+                                         final boolean includesCollinearPoints, final double tolerance) {
         Assert.assertNotNull(hull);
-        Assert.assertTrue(isConvex(hull, includesCollinearPoints));
+        Assert.assertTrue(isConvex(hull, includesCollinearPoints, tolerance));
         checkPointsInsideHullRegion(points, hull, includesCollinearPoints);
     }
 
     // verify that the constructed hull is really convex
-    protected final boolean isConvex(final ConvexHull2D hull, final boolean includesCollinearPoints) {
-        double sign = 0.0;
+    protected final boolean isConvex(final ConvexHull2D hull, final boolean includesCollinearPoints,
+                                     final double tolerance) {
 
         final Vector2D[] points = hull.getVertices();
+        int sign = 0;
 
         for (int i = 0; i < points.length; i++) {
             Vector2D p1 = points[i == 0 ? points.length - 1 : i - 1];
@@ -359,17 +407,18 @@ protected final boolean isConvex(final ConvexHull2D hull, final boolean includes
             Assert.assertTrue(d1.getNorm() > 1e-10);
             Assert.assertTrue(d2.getNorm() > 1e-10);
 
-            double cross = FastMath.signum(d1.getX() * d2.getY() - d1.getY() * d2.getX());
+            final double cross = MathArrays.linearCombination(d1.getX(), d2.getY(), -d1.getY(), d2.getX());
+            final int cmp = Precision.compareTo(cross, 0.0, tolerance);
 
-            if (sign != 0.0 && cross != sign) {
-                if (includesCollinearPoints && cross == 0.0) {
+            if (sign != 0 && cmp != sign) {
+                if (includesCollinearPoints && cmp == 0) {
                     // in case of collinear points the cross product will be zero
                 } else {
                     return false;
                 }
             }
             
-            sign = cross;
+            sign = cmp;
         }
         
         return true;
diff --git a/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChainTest.java b/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChainTest.java
index d39ed4a06e..fb85f53e87 100644
--- a/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChainTest.java
+++ b/src/test/java/org/apache/commons/math3/geometry/euclidean/twod/hull/MonotoneChainTest.java
@@ -49,7 +49,7 @@ public void testConvergenceException() {
         points.add(new Vector2D(40, 1));
 
         @SuppressWarnings("unused")
-        final ConvexHull2D hull = new MonotoneChain(true, 1).generate(points);
+        final ConvexHull2D hull = new MonotoneChain(true, 2).generate(points);
     }
 
 }
