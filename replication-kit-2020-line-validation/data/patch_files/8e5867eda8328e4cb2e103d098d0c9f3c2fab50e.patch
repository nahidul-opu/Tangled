From 8e5867eda8328e4cb2e103d098d0c9f3c2fab50e Mon Sep 17 00:00:00 2001
From: Thomas Neidhart <tn@apache.org>
Date: Tue, 3 Dec 2013 23:50:14 +0000
Subject: [PATCH] [MATH-1070] Fix Precision.round(float, int, int) for
 RoundingMode ROUND_UP. Thanks to  Oleksandr Muliarevych.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1547649 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                                   | 4 ++++
 .../java/org/apache/commons/math3/util/Precision.java     | 8 +++++---
 .../java/org/apache/commons/math3/util/PrecisionTest.java | 7 +++++++
 3 files changed, 16 insertions(+), 3 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 0678654236..f3dd93dab2 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -51,6 +51,10 @@ If the output is not quite correct, check for invisible trailing spaces!
   </properties>
   <body>
     <release version="3.3" date="TBD" description="TBD">
+      <action dev="tn" type="fix" issue="MATH-1070" due-to="Oleksandr Muliarevych">
+        Fix "Precision#round(float, int, int)" when using rounding mode "BigDecimal.ROUND_UP"
+        and the discarded fraction is zero.
+      </action>
       <action dev="tn" type="fix" issue="MATH-1059">
         Use "FastMath" instead of "Math" within Commons Math.
       </action>
diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java
index ef3b57f399..f0b0c4ff7d 100644
--- a/src/main/java/org/apache/commons/math3/util/Precision.java
+++ b/src/main/java/org/apache/commons/math3/util/Precision.java
@@ -491,8 +491,7 @@ private static double roundUnscaled(double unscaled,
                 unscaled = FastMath.floor(unscaled);
             } else {
                 // The following equality test is intentional and needed for rounding purposes
-                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(Math
-                    .floor(unscaled) / 2.0)) { // even
+                if (FastMath.floor(unscaled) / 2.0 == FastMath.floor(FastMath.floor(unscaled) / 2.0)) { // even
                     unscaled = FastMath.floor(unscaled);
                 } else { // odd
                     unscaled = FastMath.ceil(unscaled);
@@ -516,7 +515,10 @@ private static double roundUnscaled(double unscaled,
             }
             break;
         case BigDecimal.ROUND_UP :
-            unscaled = FastMath.ceil(FastMath.nextAfter(unscaled,  Double.POSITIVE_INFINITY));
+            // do not round if the discarded fraction is equal to zero
+            if (unscaled != FastMath.floor(unscaled)) {
+                unscaled = FastMath.ceil(FastMath.nextAfter(unscaled, Double.POSITIVE_INFINITY));
+            }
             break;
         default :
             throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,
diff --git a/src/test/java/org/apache/commons/math3/util/PrecisionTest.java b/src/test/java/org/apache/commons/math3/util/PrecisionTest.java
index ca833fcb5b..f73d117522 100644
--- a/src/test/java/org/apache/commons/math3/util/PrecisionTest.java
+++ b/src/test/java/org/apache/commons/math3/util/PrecisionTest.java
@@ -490,6 +490,13 @@ public void testRoundFloat() {
         Assert.assertEquals(0.0f, Precision.round(0.0f, 2), 0.0f);
         Assert.assertEquals(Float.POSITIVE_INFINITY, Precision.round(Float.POSITIVE_INFINITY, 2), 0.0f);
         Assert.assertEquals(Float.NEGATIVE_INFINITY, Precision.round(Float.NEGATIVE_INFINITY, 2), 0.0f);
+        
+        // MATH-1070
+        Assert.assertEquals(0.0f, Precision.round(0f, 2, BigDecimal.ROUND_UP), 0.0f);
+        Assert.assertEquals(0.05f, Precision.round(0.05f, 2, BigDecimal.ROUND_UP), 0.0f);
+        Assert.assertEquals(0.06f, Precision.round(0.051f, 2, BigDecimal.ROUND_UP), 0.0f);
+        Assert.assertEquals(0.06f, Precision.round(0.0505f, 2, BigDecimal.ROUND_UP), 0.0f);
+        Assert.assertEquals(0.06f, Precision.round(0.059f, 2, BigDecimal.ROUND_UP), 0.0f);
     }
 
 
