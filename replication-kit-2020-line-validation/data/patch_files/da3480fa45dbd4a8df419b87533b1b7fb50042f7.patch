From da3480fa45dbd4a8df419b87533b1b7fb50042f7 Mon Sep 17 00:00:00 2001
From: Niall Pemberton <niallp@apache.org>
Date: Sat, 30 Jan 2010 17:49:28 +0000
Subject: [PATCH] Port LANG-530 to 2.x branch - Fix parseDate() cannot parse
 ISO8601 dates produced by FastDateFormat

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/branches/LANG_2_X@904829 13f79535-47bb-0310-9956-ffa450edef68
---
 .../apache/commons/lang/time/DateUtils.java   | 60 +++++++++++++++++--
 .../commons/lang/time/DateUtilsTest.java      |  9 +++
 2 files changed, 65 insertions(+), 4 deletions(-)

diff --git a/src/main/java/org/apache/commons/lang/time/DateUtils.java b/src/main/java/org/apache/commons/lang/time/DateUtils.java
index 5fe3bee1d16..fceb9f70574 100644
--- a/src/main/java/org/apache/commons/lang/time/DateUtils.java
+++ b/src/main/java/org/apache/commons/lang/time/DateUtils.java
@@ -25,6 +25,8 @@
 import java.util.NoSuchElementException;
 import java.util.TimeZone;
 
+import org.apache.commons.lang.StringUtils;
+
 /**
  * <p>A suite of utilities surrounding the use of the
  * {@link java.util.Calendar} and {@link java.util.Date} object.</p>
@@ -78,6 +80,9 @@ public class DateUtils {
      */
     public static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;
 
+    /** Sign characters */
+    private static final char[] SIGN_CHARS = new char[] {'+', '-'};
+
     /**
      * This is half a month, so this represents whether a date is in the top
      * or bottom half of the month.
@@ -286,19 +291,66 @@ public static Date parseDate(String str, String[] parsePatterns) throws ParseExc
         SimpleDateFormat parser = null;
         ParsePosition pos = new ParsePosition(0);
         for (int i = 0; i < parsePatterns.length; i++) {
+
+            String pattern = parsePatterns[i];
+
+            // LANG-530 - need to make sure 'ZZ' output doesn't get passed to SimpleDateFormat
+            if (parsePatterns[i].endsWith("ZZ")) {
+                pattern = pattern.substring(0, pattern.length() - 1);
+            }
+            
             if (i == 0) {
-                parser = new SimpleDateFormat(parsePatterns[0]);
+                parser = new SimpleDateFormat(pattern);
             } else {
-                parser.applyPattern(parsePatterns[i]);
+                parser.applyPattern(pattern); // cannot be null if i != 0
             }
             pos.setIndex(0);
-            Date date = parser.parse(str, pos);
-            if (date != null && pos.getIndex() == str.length()) {
+
+            String str2 = str;
+            // LANG-530 - need to make sure 'ZZ' output doesn't hit SimpleDateFormat as it will ParseException
+            if (parsePatterns[i].endsWith("ZZ")) {
+                int signIdx  = indexOfSignChars(str2, 0);
+                while (signIdx >=0) {
+                    str2 = reformatTimezone(str2, signIdx);
+                    signIdx = indexOfSignChars(str2, ++signIdx);
+                }
+            }
+
+            Date date = parser.parse(str2, pos);
+            if (date != null && pos.getIndex() == str2.length()) {
                 return date;
             }
         }
         throw new ParseException("Unable to parse the date: " + str, -1);
     }
+    private static int indexOfSignChars(String str, int startPos) {
+        int idx = StringUtils.indexOf(str, '+', startPos);
+        if (idx < 0) {
+            idx = StringUtils.indexOf(str, '-', startPos);
+        }
+        return idx;
+    }
+
+    /**
+     * Reformat the timezone in a date string.
+     *
+     * @param str The input string
+     * @param signIdx The index position of the sign characters
+     * @return The reformatted string
+     */
+    private static String reformatTimezone(String str, int signIdx) {
+        String str2 = str;
+        if (signIdx >= 0 &&
+            signIdx + 5 < str.length() &&
+            Character.isDigit(str.charAt(signIdx + 1)) &&
+            Character.isDigit(str.charAt(signIdx + 2)) &&
+            str.charAt(signIdx + 3) == ':' &&
+            Character.isDigit(str.charAt(signIdx + 4)) &&
+            Character.isDigit(str.charAt(signIdx + 5))) {
+            str2 = str.substring(0, signIdx + 3) + str.substring(signIdx + 4);
+        }
+        return str2;
+    }
 
     //-----------------------------------------------------------------------
     /**
diff --git a/src/test/java/org/apache/commons/lang/time/DateUtilsTest.java b/src/test/java/org/apache/commons/lang/time/DateUtilsTest.java
index c32e6f0b962..900529fd9fc 100644
--- a/src/test/java/org/apache/commons/lang/time/DateUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang/time/DateUtilsTest.java
@@ -1170,6 +1170,15 @@ public void testTruncateLang59() throws Exception {
         TimeZone.setDefault(defaultZone);
     }
 
+    // http://issues.apache.org/jira/browse/LANG-520
+    public void testLang520() throws ParseException {
+        Date d = new Date();
+        String isoDateStr = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.format(d);
+        Date d2 = DateUtils.parseDate(isoDateStr, new String[] { DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT.getPattern() });
+        // the format loses milliseconds so have to reintroduce them
+        assertEquals("Date not equal to itself ISO formatted and parsed", d.getTime(), d2.getTime() + d.getTime() % 1000); 
+    }
+    
     /**
      * Tests various values with the ceiling method
      */
