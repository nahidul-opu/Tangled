From b88692f83a938e31fd5f703c99db2a5720cd9f3e Mon Sep 17 00:00:00 2001
From: Thomas Neidhart <tn@apache.org>
Date: Mon, 4 Mar 2013 20:20:18 +0000
Subject: [PATCH] [COLLECTIONS-447] Fix traversal of a TreeListIterator after
 calling remove(). Thanks to Jeffrey Barnes for the report and patch.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/collections/trunk@1452481 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  4 ++++
 .../commons/collections/list/TreeList.java    | 11 +++++-----
 .../collections/list/TreeListTest.java        | 21 +++++++++++++++++++
 3 files changed, 30 insertions(+), 6 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index a98d8066f5..2adc1862bd 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -22,6 +22,10 @@
   <body>
 
   <release version="4.0" date="TBA" description="Next release">
+    <action issue="COLLECTIONS-447" dev="tn" type="fix" due-to="Jeffrey Barnes">
+      Tree traversal with a TreeListIterator will not be affected anymore by
+      the removal of an element directly after a call to previous().
+    </action>
     <action issue="COLLECTIONS-275" dev="tn" type="add" due-to="Stephen Kestle">
       Added "IndexedCollection" collection decorator which provides a map-like
       view on an existing collection.
diff --git a/src/main/java/org/apache/commons/collections/list/TreeList.java b/src/main/java/org/apache/commons/collections/list/TreeList.java
index 25ec94dd92..390ed338de 100644
--- a/src/main/java/org/apache/commons/collections/list/TreeList.java
+++ b/src/main/java/org/apache/commons/collections/list/TreeList.java
@@ -900,15 +900,14 @@ public void remove() {
             if (currentIndex == -1) {
                 throw new IllegalStateException();
             }
-            if (nextIndex == currentIndex) {
-                // remove() following previous()
-                next = next.next();
-                parent.remove(currentIndex);
-            } else {
+            parent.remove(currentIndex);
+            if (nextIndex != currentIndex) {
                 // remove() following next()
-                parent.remove(currentIndex);
                 nextIndex--;
             }
+            // the AVL node referenced by next may have become stale after a remove
+            // reset it now: will be retrieved by next call to next()/previous() via nextIndex
+            next = null;
             current = null;
             currentIndex = -1;
             expectedModCount++;
diff --git a/src/test/java/org/apache/commons/collections/list/TreeListTest.java b/src/test/java/org/apache/commons/collections/list/TreeListTest.java
index 1d780edccc..a5d57050ca 100644
--- a/src/test/java/org/apache/commons/collections/list/TreeListTest.java
+++ b/src/test/java/org/apache/commons/collections/list/TreeListTest.java
@@ -46,6 +46,7 @@ public TreeListTest(final String name) {
 //        benchmark(new java.util.ArrayList());
 //        System.out.print("\n LinkedList = ");
 //        benchmark(new java.util.LinkedList());
+//        System.out.print("\n NodeCachingLinkedList = ");
 //        benchmark(new NodeCachingLinkedList());
 //    }
 
@@ -246,5 +247,25 @@ public void testBug35258() {
         assertEquals(new Integer(4), li.next());
         assertEquals(false, li.hasNext());
     }
+    
+    public void testBugCollections447() {
+        final List<String> treeList = new TreeList<String>();
+        treeList.add("A");
+        treeList.add("B");
+        treeList.add("C");
+        treeList.add("D");
+        
+        final ListIterator<String> li = treeList.listIterator();
+        assertEquals("A", li.next());
+        assertEquals("B", li.next());
+        
+        assertEquals("B", li.previous());
+                
+        li.remove(); // Deletes "B"
+                
+        // previous() after remove() should move to
+        // the element before the one just removed
+        assertEquals("A", li.previous());
+    }    
 
 }
