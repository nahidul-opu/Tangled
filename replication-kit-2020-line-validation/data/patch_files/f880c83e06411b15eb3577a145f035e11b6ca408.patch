From f880c83e06411b15eb3577a145f035e11b6ca408 Mon Sep 17 00:00:00 2001
From: Sebastien Brisard <celestin@apache.org>
Date: Sat, 3 Dec 2011 18:23:02 +0000
Subject: [PATCH] - In distribution.AbstractRealDistribution, removed
 superfluous methods getDomainLowerBound(double), getDomainUpperBound(double)
 and getInitialDomain(double p) (MATH-699). - Resolved checkstyle issues in
 the distribution package. - Improved Javadoc of
 RealDistribution.getSupportLowerBound(),
 RealDistribution.getSupportUpperBound() and
 AbstractRealDistribution.inverseCumulativeDistribution(double).

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1209963 13f79535-47bb-0310-9956-ffa450edef68
---
 .../AbstractIntegerDistribution.java          |  8 +-
 .../AbstractRealDistribution.java             | 83 ++++++++++---------
 .../math/distribution/BetaDistribution.java   | 22 +----
 .../distribution/BinomialDistribution.java    |  4 +-
 .../math/distribution/CauchyDistribution.java | 48 +----------
 .../distribution/ChiSquaredDistribution.java  | 50 +----------
 .../distribution/ExponentialDistribution.java | 44 +---------
 .../math/distribution/FDistribution.java      | 36 ++------
 .../math/distribution/GammaDistribution.java  | 50 +----------
 .../HypergeometricDistribution.java           | 10 +--
 .../distribution/IntegerDistribution.java     |  5 +-
 .../KolmogorovSmirnovDistribution.java        |  2 +-
 .../math/distribution/NormalDistribution.java | 48 +----------
 .../math/distribution/PascalDistribution.java |  4 +-
 .../distribution/PoissonDistribution.java     |  6 +-
 .../math/distribution/RealDistribution.java   | 14 +++-
 .../math/distribution/TDistribution.java      | 32 ++-----
 .../distribution/WeibullDistribution.java     | 43 +++-------
 .../math/distribution/ZipfDistribution.java   |  8 +-
 .../AbstractRealDistributionTest.java         | 30 -------
 20 files changed, 115 insertions(+), 432 deletions(-)

diff --git a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
index 358e08f356..793f72be0f 100644
--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
@@ -43,11 +43,11 @@ public abstract class AbstractIntegerDistribution
     protected final RandomDataImpl randomData = new RandomDataImpl();
 
     /** Default constructor. */
-    protected AbstractIntegerDistribution() {}
+    protected AbstractIntegerDistribution() { }
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The default implementation uses the identity
      * <p>{@code P(x0 <= X <= x1) = P(X <= x1) - P(X <= x0 - 1)}</p>
      */
@@ -136,7 +136,7 @@ public void reseedRandomGenerator(long seed) {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The default implementation uses the
      * <a href="http://en.wikipedia.org/wiki/Inverse_transform_sampling">
      * inversion method</a>.
@@ -147,7 +147,7 @@ public int sample() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The default implementation generates the sample by calling
      * {@link #sample()} in a loop.
      */
diff --git a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java
index d83837d71e..9f729eb464 100644
--- a/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/AbstractRealDistribution.java
@@ -37,12 +37,12 @@
  */
 public abstract class AbstractRealDistribution
 implements RealDistribution, Serializable {
-    /** Serializable version identifier */
-    private static final long serialVersionUID = -38038050983108802L;
-
     /** Default accuracy. */
     public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY = 1e-6;
 
+    /** Serializable version identifier */
+    private static final long serialVersionUID = -38038050983108802L;
+
     /** Solver absolute accuracy for inverse cumulative computation */
     private double solverAbsoluteAccuracy = SOLVER_DEFAULT_ABSOLUTE_ACCURACY;
 
@@ -50,7 +50,7 @@ public abstract class AbstractRealDistribution
     protected final RandomDataImpl randomData = new RandomDataImpl();
 
     /** Default constructor. */
-    protected AbstractRealDistribution() {}
+    protected AbstractRealDistribution() { }
 
     /**
      * {@inheritDoc}
@@ -66,8 +66,44 @@ public double cumulativeProbability(double x0, double x1) throws NumberIsTooLarg
         return cumulativeProbability(x1) - cumulativeProbability(x0);
     }
 
-    /** {@inheritDoc} */
+    /**
+     * {@inheritDoc}
+     *
+     * The default implementation returns
+     * <ul>
+     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>
+     * <li>{@link #getSupportUpperBound()} for {@code p = 1}.</li>
+     * </ul>
+     */
     public double inverseCumulativeProbability(final double p) throws OutOfRangeException {
+        /*
+         * IMPLEMENTATION NOTES
+         * --------------------
+         * Where applicable, use is made of the one-sided Chebyshev inequality
+         * to bracket the root. This inequality states that
+         * P(X - mu >= k * sig) <= 1 / (1 + k^2),
+         * mu: mean, sig: standard deviation. Equivalently
+         * 1 - P(X < mu + k * sig) <= 1 / (1 + k^2),
+         * F(mu + k * sig) >= k^2 / (1 + k^2).
+         *
+         * For k = sqrt(p / (1 - p)), we find
+         * F(mu + k * sig) >= p,
+         * and (mu + k * sig) is an upper-bound for the root.
+         *
+         * Then, introducing Y = -X, mean(Y) = -mu, sd(Y) = sig, and
+         * P(Y >= -mu + k * sig) <= 1 / (1 + k^2),
+         * P(-X >= -mu + k * sig) <= 1 / (1 + k^2),
+         * P(X <= mu - k * sig) <= 1 / (1 + k^2),
+         * F(mu - k * sig) <= 1 / (1 + k^2).
+         *
+         * For k = sqrt((1 - p) / p), we find
+         * F(mu - k * sig) <= p,
+         * and (mu - k * sig) is a lower-bound for the root.
+         *
+         * In cases where the Chebyshev inequality does not apply, geometric
+         * progressions 1, 2, 4, ... and -1, -2, -4, ... are used to bracket
+         * the root.
+         */
         if (p < 0.0 || p > 1.0) {
             throw new OutOfRangeException(p, 0, 1);
         }
@@ -144,39 +180,6 @@ public double value(final double x) {
         return x;
     }
 
-    /**
-     * Access the initial domain value, based on {@code p}, used to
-     * bracket a CDF root.  This method is used by
-     * {@link #inverseCumulativeProbability(double)} to find critical values.
-     *
-     * @param p Desired probability for the critical value.
-     * @return the initial domain value.
-     * TODO to be deleted when applying MATH-699
-     */
-    protected abstract double getInitialDomain(double p);
-
-    /**
-     * Access the domain value lower bound, based on {@code p}, used to
-     * bracket a CDF root.  This method is used by
-     * {@link #inverseCumulativeProbability(double)} to find critical values.
-     *
-     * @param p Desired probability for the critical value.
-     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.
-     * TODO to be deleted when applying MATH-699
-     */
-    protected abstract double getDomainLowerBound(double p);
-
-    /**
-     * Access the domain value upper bound, based on {@code p}, used to
-     * bracket a CDF root.  This method is used by
-     * {@link #inverseCumulativeProbability(double)} to find critical values.
-     *
-     * @param p Desired probability for the critical value.
-     * @return the domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.
-     * TODO to be deleted when applying MATH-699
-     */
-    protected abstract double getDomainUpperBound(double p);
-
     /**
      * Returns the solver absolute accuracy for inverse cumulative computation.
      * You can override this method in order to use a Brent solver with an
@@ -195,7 +198,7 @@ public void reseedRandomGenerator(long seed) {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The default implementation uses the
      * <a href="http://en.wikipedia.org/wiki/Inverse_transform_sampling">
      * inversion method.
@@ -207,7 +210,7 @@ public double sample() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The default implementation generates the sample by calling
      * {@link #sample()} in a loop.
      */
diff --git a/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java
index 5dd74d33a7..a985eb255d 100644
--- a/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java
@@ -145,24 +145,6 @@ public double inverseCumulativeProbability(double p)  {
         }
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        return p;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        return 0;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        return 1;
-    }
-
     /** {@inheritDoc} */
     public double cumulativeProbability(double x)  {
         if (x <= 0) {
@@ -245,9 +227,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java
index 311e868f22..3d6cc39a7f 100644
--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java
@@ -182,9 +182,9 @@ public int getSupportUpperBound() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java
index b0872396fc..f62bb5bd20 100644
--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java
@@ -144,50 +144,6 @@ public double inverseCumulativeProbability(double p) throws OutOfRangeException
         return ret;
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        double ret;
-
-        if (p < 0.5) {
-            ret = -Double.MAX_VALUE;
-        } else {
-            ret = median;
-        }
-
-        return ret;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        double ret;
-
-        if (p < 0.5) {
-            ret = median;
-        } else {
-            ret = Double.MAX_VALUE;
-        }
-
-        return ret;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        double ret;
-
-        if (p < 0.5) {
-            ret = median - scale;
-        } else if (p > 0.5) {
-            ret = median + scale;
-        } else {
-            ret = median;
-        }
-
-        return ret;
-    }
-
     /** {@inheritDoc} */
     @Override
     protected double getSolverAbsoluteAccuracy() {
@@ -252,9 +208,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java
index 8ee176cd35..0987f937f4 100644
--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java
@@ -108,50 +108,6 @@ public double inverseCumulativeProbability(final double p) {
         return super.inverseCumulativeProbability(p);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        return Double.MIN_VALUE * gamma.getBeta();
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        // NOTE: chi squared is skewed to the left
-        // NOTE: therefore, P(X < &mu;) > .5
-
-        double ret;
-
-        if (p < .5) {
-            // use mean
-            ret = getDegreesOfFreedom();
-        } else {
-            // use max
-            ret = Double.MAX_VALUE;
-        }
-
-        return ret;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        // NOTE: chi squared is skewed to the left
-        // NOTE: therefore, P(X < &mu;) > 0.5
-
-        double ret;
-
-        if (p < 0.5) {
-            // use 1/2 mean
-            ret = getDegreesOfFreedom() * 0.5;
-        } else {
-            // use mean
-            ret = getDegreesOfFreedom();
-        }
-
-        return ret;
-    }
-
     /** {@inheritDoc} */
     @Override
     protected double getSolverAbsoluteAccuracy() {
@@ -175,7 +131,7 @@ public double getNumericalMean() {
      * @return {@inheritDoc}
      */
     public double getNumericalVariance() {
-        return 2*getDegreesOfFreedom();
+        return 2 * getDegreesOfFreedom();
     }
 
     /**
@@ -214,9 +170,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java
index 1131ca2c67..6edcb5a394 100644
--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java
@@ -60,7 +60,7 @@ public ExponentialDistribution(double mean) {
      * @since 2.1
      */
     public ExponentialDistribution(double mean, double inverseCumAccuracy)
-        throws NotStrictlyPositiveException{
+        throws NotStrictlyPositiveException {
         if (mean <= 0) {
             throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);
         }
@@ -153,44 +153,6 @@ public double sample() {
         return randomData.nextExponential(mean);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        return 0;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        // NOTE: exponential is skewed to the left
-        // NOTE: therefore, P(X < &mu;) > .5
-
-        if (p < 0.5) {
-            // use mean
-            return mean;
-        } else {
-            // use max
-            return Double.MAX_VALUE;
-        }
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        // TODO: try to improve on this estimate
-        // TODO: what should really happen here is not derive from
-        // AbstractContinuousDistribution
-        // TODO: because the inverse cumulative distribution is simple.
-        // Exponential is skewed to the left, therefore, P(X < &mu;) > .5
-        if (p < 0.5) {
-            // use 1/2 mean
-            return mean * 0.5;
-        } else {
-            // use mean
-            return mean;
-        }
-    }
-
     /** {@inheritDoc} */
     @Override
     protected double getSolverAbsoluteAccuracy() {
@@ -251,9 +213,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/FDistribution.java b/src/main/java/org/apache/commons/math/distribution/FDistribution.java
index 6d59ad9ac9..8c088fa77f 100644
--- a/src/main/java/org/apache/commons/math/distribution/FDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/FDistribution.java
@@ -31,15 +31,15 @@
  * @version $Id$
  */
 public class FDistribution extends AbstractRealDistribution {
-    /** Serializable version identifier. */
-    private static final long serialVersionUID = -8516354193418641566L;
-
     /**
      * Default inverse cumulative probability accuracy.
      * @since 2.1
      */
     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
 
+    /** Serializable version identifier. */
+    private static final long serialVersionUID = -8516354193418641566L;
+
     /** The numerator degrees of freedom. */
     private final double numeratorDegreesOfFreedom;
 
@@ -172,30 +172,6 @@ public double inverseCumulativeProbability(final double p) throws OutOfRangeExce
         return super.inverseCumulativeProbability(p);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        return 0;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        return Double.MAX_VALUE;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        double ret = 1;
-        double d = denominatorDegreesOfFreedom;
-        if (d > 2) {
-            // use mean
-            ret = d / (d - 2);
-        }
-        return ret;
-    }
-
     /**
      * Access the numerator degrees of freedom.
      *
@@ -262,7 +238,7 @@ public double getNumericalVariance() {
 
     /**
      * used by {@link #getNumericalVariance()}
-     * 
+     *
      * @return the variance of this distribution
      */
     protected double calculateNumericalVariance() {
@@ -314,9 +290,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java
index 6151798bef..8e5ccff4d7 100644
--- a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java
@@ -161,52 +161,6 @@ public double inverseCumulativeProbability(final double p) {
         return super.inverseCumulativeProbability(p);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        // TODO: try to improve on this estimate
-        return Double.MIN_VALUE;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        // TODO: try to improve on this estimate
-        // NOTE: gamma is skewed to the left
-        // NOTE: therefore, P(X < &mu;) > .5
-
-        double ret;
-
-        if (p < 0.5) {
-            // use mean
-            ret = alpha * beta;
-        } else {
-            // use max value
-            ret = Double.MAX_VALUE;
-        }
-
-        return ret;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        // TODO: try to improve on this estimate
-        // Gamma is skewed to the left, therefore, P(X < &mu;) > .5
-
-        double ret;
-
-        if (p < 0.5) {
-            // use 1/2 mean
-            ret = alpha * beta * 0.5;
-        } else {
-            // use mean
-            ret = alpha * beta;
-        }
-
-        return ret;
-    }
-
     /** {@inheritDoc} */
     @Override
     protected double getSolverAbsoluteAccuracy() {
@@ -271,9 +225,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java
index f481e2af70..99cb892f8e 100644
--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java
@@ -280,7 +280,7 @@ private double innerCumulativeProbability(int x0, int x1, int dx,
      * size {@code n}, the mean is {@code n * m / N}.
      */
     public double getNumericalMean() {
-        return (double)(getSampleSize() * getNumberOfSuccesses()) / (double)getPopulationSize();
+        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();
     }
 
     /**
@@ -300,14 +300,14 @@ public double getNumericalVariance() {
 
     /**
      * Used by {@link #getNumericalVariance()}.
-     * 
+     *
      * @return the variance of this distribution
      */
     protected double calculateNumericalVariance() {
         final double N = getPopulationSize();
         final double m = getNumberOfSuccesses();
         final double n = getSampleSize();
-        return ( n * m * (N - n) * (N - m) ) / ( (N*N * (N - 1)) );
+        return ( n * m * (N - n) * (N - m) ) / ( (N * N * (N - 1)) );
     }
 
     /**
@@ -338,9 +338,9 @@ public int getSupportUpperBound() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java
index f585cb805d..b0d9c66650 100644
--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java
@@ -93,9 +93,8 @@ public interface IntegerDistribution {
      * Use this method to get the numerical value of the variance of this
      * distribution.
      *
-     * @return the variance (possibly {@code Double.POSITIVE_INFINITY} as
-     * for certain cases in {@link TDistributionImpl}) or
-     * {@code Double.NaN} if it is not defined
+     * @return the variance (possibly {@code Double.POSITIVE_INFINITY} or
+     * {@code Double.NaN} if it is not defined)
      */
     double getNumericalVariance();
 
diff --git a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java
index 9c7701bf0a..6e901c4c90 100644
--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistribution.java
@@ -246,7 +246,7 @@ private double roundedK(double d) throws MathArithmeticException {
         double pFrac = Hpower.getEntry(k - 1, k - 1);
 
         for (int i = 1; i <= n; ++i) {
-            pFrac *= (double)i / (double)n;
+            pFrac *= (double) i / (double) n;
         }
 
         return pFrac;
diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java
index 43471dbf00..082b815b48 100644
--- a/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java
@@ -172,50 +172,6 @@ public double inverseCumulativeProbability(final double p) {
         return super.inverseCumulativeProbability(p);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        double ret;
-
-        if (p < 0.5) {
-            ret = -Double.MAX_VALUE;
-        } else {
-            ret = mean;
-        }
-
-        return ret;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        double ret;
-
-        if (p < 0.5) {
-            ret = mean;
-        } else {
-            ret = Double.MAX_VALUE;
-        }
-
-        return ret;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        double ret;
-
-        if (p < 0.5) {
-            ret = mean - standardDeviation;
-        } else if (p > 0.5) {
-            ret = mean + standardDeviation;
-        } else {
-            ret = mean;
-        }
-
-        return ret;
-    }
-
     /** {@inheritDoc} */
     @Override
     protected double getSolverAbsoluteAccuracy() {
@@ -279,9 +235,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java
index 20659c7c28..b96a3b9ab3 100644
--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java
@@ -206,9 +206,9 @@ public int getSupportUpperBound() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java
index f218aeedb7..73534486af 100644
--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java
@@ -139,9 +139,9 @@ public double probability(int x) {
         } else if (x == 0) {
             ret = FastMath.exp(-mean);
         } else {
-            ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x)
-                  - SaddlePointExpansion.getDeviancePart(x, mean))
-                  / FastMath.sqrt(MathUtils.TWO_PI * x);
+            ret = FastMath.exp(-SaddlePointExpansion.getStirlingError(x) -
+                  SaddlePointExpansion.getDeviancePart(x, mean)) /
+                  FastMath.sqrt(MathUtils.TWO_PI * x);
         }
         return ret;
     }
diff --git a/src/main/java/org/apache/commons/math/distribution/RealDistribution.java b/src/main/java/org/apache/commons/math/distribution/RealDistribution.java
index 510f6bfb37..ca817633df 100644
--- a/src/main/java/org/apache/commons/math/distribution/RealDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/RealDistribution.java
@@ -105,13 +105,16 @@ public interface RealDistribution {
      * distribution.
      *
      * @return the variance (possibly {@code Double.POSITIVE_INFINITY} as
-     * for certain cases in {@link TDistributionImpl}) or
-     * {@code Double.NaN} if it is not defined
+     * for certain cases in {@link TDistribution}) or {@code Double.NaN} if it
+     * is not defined
      */
     double getNumericalVariance();
 
     /**
-     * Access the lower bound of the support.
+     * Access the lower bound of the support. This method must return the same
+     * value as {@code inverseCumulativeProbability(0)}. In other words, this
+     * method must return
+     * <p><code>inf {x in R | P(X <= x) > 0}</code>.</p>
      *
      * @return lower bound of the support (might be
      * {@code Double.NEGATIVE_INFINITY})
@@ -119,7 +122,10 @@ public interface RealDistribution {
     double getSupportLowerBound();
 
     /**
-     * Access the upper bound of the support.
+     * Access the upper bound of the support. This method must return the same
+     * value as {@code inverseCumulativeProbability(1)}. In other words, this
+     * method must return
+     * <p><code>inf {x in R | P(X <= x) = 1}</code>.</p>
      *
      * @return upper bound of the support (might be
      * {@code Double.POSITIVE_INFINITY})
diff --git a/src/main/java/org/apache/commons/math/distribution/TDistribution.java b/src/main/java/org/apache/commons/math/distribution/TDistribution.java
index 2a1f1f9a91..d5698de1d1 100644
--- a/src/main/java/org/apache/commons/math/distribution/TDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/TDistribution.java
@@ -98,11 +98,11 @@ public double probability(double x) {
     public double density(double x) {
         final double n = degreesOfFreedom;
         final double nPlus1Over2 = (n + 1) / 2;
-        return FastMath.exp(Gamma.logGamma(nPlus1Over2)
-                            - 0.5 * (FastMath.log(FastMath.PI)
-                                     + FastMath.log(n))
-                            - Gamma.logGamma(n/2)
-                            - nPlus1Over2 * FastMath.log(1 + x * x /n));
+        return FastMath.exp(Gamma.logGamma(nPlus1Over2) -
+                            0.5 * (FastMath.log(FastMath.PI) +
+                                   FastMath.log(n)) -
+                            Gamma.logGamma(n / 2) -
+                            nPlus1Over2 * FastMath.log(1 + x * x / n));
     }
 
     /** {@inheritDoc} */
@@ -143,24 +143,6 @@ public double inverseCumulativeProbability(final double p) {
         return super.inverseCumulativeProbability(p);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        return -Double.MAX_VALUE;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        return Double.MAX_VALUE;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        return 0;
-    }
-
     /** {@inheritDoc} */
     @Override
     protected double getSolverAbsoluteAccuracy() {
@@ -249,9 +231,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java
index 7917df1489..e7365e93af 100644
--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java
@@ -35,21 +35,21 @@
  * @version $Id$
  */
 public class WeibullDistribution extends AbstractRealDistribution {
-    /** Serializable version identifier. */
-    private static final long serialVersionUID = 8589540077390120676L;
-    
     /**
      * Default inverse cumulative probability accuracy.
      * @since 2.1
      */
     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;
-    
+
+    /** Serializable version identifier. */
+    private static final long serialVersionUID = 8589540077390120676L;
+
     /** The shape parameter. */
     private final double shape;
-    
+
     /** The scale parameter. */
     private final double scale;
-    
+
     /** Inverse cumulative probability accuracy. */
     private final double solverAbsoluteAccuracy;
 
@@ -188,25 +188,6 @@ public double inverseCumulativeProbability(double p) {
         return ret;
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainLowerBound(double p) {
-        return 0;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getDomainUpperBound(double p) {
-        return Double.MAX_VALUE;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected double getInitialDomain(double p) {
-        // use median
-        return FastMath.pow(scale * FastMath.log(2.0), 1.0 / shape);
-    }
-
     /**
      * Return the absolute accuracy setting of the solver used to estimate
      * inverse cumulative probabilities.
@@ -235,7 +216,7 @@ public double getNumericalMean() {
 
     /**
      * used by {@link #getNumericalMean()}
-     * 
+     *
      * @return the mean of this distribution
      */
     protected double calculateNumericalMean() {
@@ -261,7 +242,7 @@ public double getNumericalVariance() {
 
     /**
      * used by {@link #getNumericalVariance()}
-     * 
+     *
      * @return the variance of this distribution
      */
     protected double calculateNumericalVariance() {
@@ -269,8 +250,8 @@ protected double calculateNumericalVariance() {
         final double sc = getScale();
         final double mn = getNumericalMean();
 
-        return (sc * sc) * FastMath.exp(Gamma.logGamma(1 + (2 / sh)))
-               - (mn * mn);
+        return (sc * sc) * FastMath.exp(Gamma.logGamma(1 + (2 / sh))) -
+               (mn * mn);
     }
 
     /**
@@ -309,9 +290,9 @@ public boolean isSupportUpperBoundInclusive() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java
index b6fb683aa2..1b5736ab5a 100644
--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java
@@ -143,7 +143,7 @@ public double getNumericalMean() {
 
     /**
      * Used by {@link #getNumericalMean()}.
-     * 
+     *
      * @return the mean of this distribution
      */
     protected double calculateNumericalMean() {
@@ -177,7 +177,7 @@ public double getNumericalVariance() {
 
     /**
      * used by {@link #getNumericalVariance()}
-     * 
+     *
      * @return the variance of this distribution
      */
     protected double calculateNumericalVariance() {
@@ -232,9 +232,9 @@ public int getSupportUpperBound() {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * The support of this distribution is connected.
-     * 
+     *
      * @return {@code true}
      */
     public boolean isSupportConnected() {
diff --git a/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java
index d0b9a94900..182e69ff01 100644
--- a/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/AbstractRealDistributionTest.java
@@ -64,21 +64,6 @@ public double density(final double x) {
                 return 0.0;
             }
 
-            @Override
-            protected double getDomainLowerBound(final double p) {
-                throw new UnsupportedOperationException();
-            }
-
-            @Override
-            protected double getDomainUpperBound(final double p) {
-                throw new UnsupportedOperationException();
-            }
-
-            @Override
-            protected double getInitialDomain(final double p) {
-                throw new UnsupportedOperationException();
-            }
-
             public double getNumericalMean() {
                 return ((x0 + x1) * p12 + (x2 + x3) * (1.0 - p12)) / 2.0;
             }
@@ -164,21 +149,6 @@ public double density(final double x) {
                 }
             }
 
-            @Override
-            protected double getDomainLowerBound(final double p) {
-                throw new UnsupportedOperationException();
-            }
-
-            @Override
-            protected double getDomainUpperBound(final double p) {
-                throw new UnsupportedOperationException();
-            }
-
-            @Override
-            protected double getInitialDomain(final double p) {
-                throw new UnsupportedOperationException();
-            }
-
             public double getNumericalMean() {
                 final UnivariateFunction f = new UnivariateFunction() {
 
