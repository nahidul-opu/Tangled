From 4bb2f5f1a66f4fa8059941549cc6eea53a19286c Mon Sep 17 00:00:00 2001
From: Sebastian Bazley <sebb@apache.org>
Date: Sat, 6 Oct 2012 15:24:53 +0000
Subject: [PATCH] NET-483 Base64.encodeBase64(byte[], boolean, boolean, int)
 does not calculate output size correctly for unchunked output

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/net/trunk@1395097 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |   3 +
 .../org/apache/commons/net/util/Base64.java   |  11 +-
 .../apache/commons/net/util/Base64Test.java   | 213 ++++++++++++++++++
 3 files changed, 226 insertions(+), 1 deletion(-)
 create mode 100644 src/test/java/org/apache/commons/net/util/Base64Test.java

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index ab9914bde..b2cf4f8ff 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -66,6 +66,9 @@ The <action> type attribute can be add,update,fix,remove.
 This release fixes bugs and adds some new functionality (see below).
  It is binary compatible with previous releases
         ">
+            <action issue="NET-483" dev="sebb" type="fix">
+            Base64.encodeBase64(byte[], boolean, boolean, int) does not calculate output size correctly for unchunked output.
+            </action>
             <action issue="NET-466" dev="sebb" type="fix" due-to="Martin Oberhuber">
             Regression: TelnetInputStream#available() blocks.
             </action>
diff --git a/src/main/java/org/apache/commons/net/util/Base64.java b/src/main/java/org/apache/commons/net/util/Base64.java
index f07c3f63b..5f3969fac 100644
--- a/src/main/java/org/apache/commons/net/util/Base64.java
+++ b/src/main/java/org/apache/commons/net/util/Base64.java
@@ -845,7 +845,7 @@ public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean
             return binaryData;
         }
 
-        long len = getEncodeLength(binaryData, CHUNK_SIZE, CHUNK_SEPARATOR);
+        long len = getEncodeLength(binaryData, isChunked ? CHUNK_SIZE : 0, CHUNK_SEPARATOR);
         if (len > maxResultSize) {
             throw new IllegalArgumentException("Input array too big, the output array would be bigger (" +
                 len +
@@ -1076,4 +1076,13 @@ private void reset() {
         eof = false;
     }
 
+    // Getters for use in testing
+    
+    int getLineLength() {
+        return lineLength;
+    }
+    
+    byte[] getLineSeparator() {
+        return lineSeparator.clone();
+    }
 }
diff --git a/src/test/java/org/apache/commons/net/util/Base64Test.java b/src/test/java/org/apache/commons/net/util/Base64Test.java
new file mode 100644
index 000000000..552fb7239
--- /dev/null
+++ b/src/test/java/org/apache/commons/net/util/Base64Test.java
@@ -0,0 +1,213 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * 
+ */
+
+package org.apache.commons.net.util;
+
+import static org.junit.Assert.*;
+
+import java.util.Arrays;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+public class Base64Test {
+
+    @Test
+    public void testBase64() {
+        Base64 b64 = new Base64();
+        assertFalse(b64.isUrlSafe());
+    }
+
+    @Test
+    public void testBase64Boolean() {
+        Base64 b64 = new Base64(true);
+        assertTrue(b64.isUrlSafe());
+        assertTrue(Arrays.equals(new byte[]{'\r','\n'}, b64.getLineSeparator()));
+    }
+
+    @Test
+    public void testBase64Int() {
+        Base64 b64;
+        b64 = new Base64(8);
+        assertFalse(b64.isUrlSafe());
+        assertEquals(8, b64.getLineLength());
+        b64 = new Base64(11);
+        assertEquals(8, b64.getLineLength());
+    }
+
+    @Test
+    public void testBase64IntByteArray() {
+        Base64 b64;
+        b64 = new Base64(8, new byte[]{});
+        assertFalse(b64.isUrlSafe());
+        assertTrue(Arrays.equals(new byte[]{}, b64.getLineSeparator()));
+    }
+
+    @Test
+    public void testBase64IntByteArrayBoolean() {
+        Base64 b64;
+        b64 = new Base64(8, new byte[]{}, false);
+        assertFalse(b64.isUrlSafe());
+        b64 = new Base64(8, new byte[]{}, true);
+        assertTrue(b64.isUrlSafe());
+    }
+
+    @Test
+    public void testIsBase64() {
+        assertTrue(Base64.isBase64((byte)'b'));
+        assertFalse(Base64.isBase64((byte)' '));
+    }
+
+    @Test
+    public void testIsArrayByteBase64() {
+        assertTrue(Base64.isArrayByteBase64(new byte[]{'b',' '}));
+        assertFalse(Base64.isArrayByteBase64(new byte[]{'?'}));
+    }
+
+    @Test
+    public void testEncodeBase64ByteArray() {
+        byte[] binaryData=null;
+        assertTrue(Arrays.equals(binaryData, Base64.encodeBase64(binaryData)));
+    }
+
+    @Test @Ignore
+    public void testEncodeBase64StringByteArray() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeBase64StringUnChunked() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeBase64StringByteArrayBoolean() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeBase64URLSafe() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeBase64URLSafeString() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeBase64Chunked() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testDecodeObject() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testDecodeString() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testDecodeByteArray() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeBase64ByteArrayBoolean() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeBase64ByteArrayBooleanBoolean() {
+        fail("Not yet implemented");
+    }
+
+    @Test
+    public void testEncodeBase64ByteArrayBooleanBooleanInt() {
+        byte[] binaryData = new byte[]{'1','2','3'};
+        byte[] encoded;
+        encoded = Base64.encodeBase64(binaryData, false, false);
+        assertNotNull(encoded);
+        assertEquals(4, encoded.length);
+        try {
+            Base64.encodeBase64(binaryData, false, false, 3);
+            fail("Expected IllegalArgumentException");
+        } catch (IllegalArgumentException expected) {
+            // expected
+        }
+        encoded = Base64.encodeBase64(binaryData, false, false, 4); // NET-483
+        assertNotNull(encoded);
+        assertEquals(4, encoded.length);
+        encoded = Base64.encodeBase64(binaryData, true, false);
+        assertNotNull(encoded);
+        assertEquals(6, encoded.length); // always adds trailer
+        try {
+            Base64.encodeBase64(binaryData, true, false, 5);
+            fail("Expected IllegalArgumentException");
+        } catch (IllegalArgumentException expected) {
+            // expected
+        }
+        encoded = Base64.encodeBase64(binaryData, true, false, 6);
+        assertNotNull(encoded);
+        assertEquals(6, encoded.length);
+    }
+
+    @Test @Ignore
+    public void testDecodeBase64String() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testDecodeBase64ByteArray() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeObject() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeToString() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeByteArray() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testDecodeInteger() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testEncodeInteger() {
+        fail("Not yet implemented");
+    }
+
+    @Test @Ignore
+    public void testToIntegerBytes() {
+        fail("Not yet implemented");
+    }
+
+}
