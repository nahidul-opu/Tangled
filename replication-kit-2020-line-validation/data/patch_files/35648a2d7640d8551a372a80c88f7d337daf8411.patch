From 35648a2d7640d8551a372a80c88f7d337daf8411 Mon Sep 17 00:00:00 2001
From: Sebastian Bazley <sebb@apache.org>
Date: Mon, 7 Apr 2008 00:27:04 +0000
Subject: [PATCH] NET-188 - apply patch of 12/Mar/08 01:19 PM; fixes Feb 29
 parsing

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/net/trunk@645336 13f79535-47bb-0310-9956-ffa450edef68
---
 .../ftp/parser/FTPTimestampParserImpl.java    | 64 ++++++++-----------
 1 file changed, 28 insertions(+), 36 deletions(-)

diff --git a/src/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java b/src/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
index 41002c1dc..0c157a704 100644
--- a/src/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
+++ b/src/java/org/apache/commons/net/ftp/parser/FTPTimestampParserImpl.java
@@ -97,10 +97,22 @@ public Calendar parseTimestamp(String timestampStr, Calendar now) throws ParseEx
 		ParsePosition pp = new ParsePosition(0);
 
 		Date parsed = null;
+		String timeStampStrPlusYear="";
 		if (recentDateFormat != null) {
-			parsed = recentDateFormat.parse(timestampStr, pp);
+            // Temporarily add the current year to the short date time
+            // to cope with short-date leap year strings.
+            // e.g. Java's DateFormatter will assume that "Feb 29 12:00" refers to 
+            // Feb 29 1970 (an invalid date) rather than a potentially valid leap year date.
+            // This is pretty bad hack to work around the deficiencies of the JDK date/time classes.
+            int year = now.get(Calendar.YEAR);
+            timeStampStrPlusYear = timestampStr + " " + year;
+            SimpleDateFormat hackFormatter = new SimpleDateFormat(recentDateFormat.toPattern() + " yyyy", 
+                    recentDateFormat.getDateFormatSymbols());
+            hackFormatter.setLenient(false);
+            hackFormatter.setTimeZone(recentDateFormat.getTimeZone());
+            parsed = hackFormatter.parse(timeStampStrPlusYear, pp);
 		}
-		if (parsed != null && pp.getIndex() == timestampStr.length()) 
+		if (parsed != null && pp.getIndex() == timeStampStrPlusYear.length()) 
 		{
 			working.setTime(parsed);
 			working.set(Calendar.YEAR, now.get(Calendar.YEAR));
@@ -114,41 +126,21 @@ public Calendar parseTimestamp(String timestampStr, Calendar now) throws ParseEx
 				working.add(Calendar.YEAR, -1);
 			}
 		} else {
-			// Temporarily add the current year to the short date time
-			// to cope with short-date leap year strings.
-			// e.g. Java's DateFormatter will assume that "Feb 29 12:00" refers to 
-			// Feb 29 1970 (an invalid date) rather than a potentially valid leap year date.
-			// This is pretty bad hack to work around the deficiencies of the JDK date/time classes.
-			if (recentDateFormat != null) {
-				pp = new ParsePosition(0);
-				int year = now.get(Calendar.YEAR);
-				String timeStampStrPlusYear = timestampStr + " " + year;
-				SimpleDateFormat hackFormatter = new SimpleDateFormat(recentDateFormat.toPattern() + " yyyy", 
-						recentDateFormat.getDateFormatSymbols());
-				hackFormatter.setLenient(false);
-				hackFormatter.setTimeZone(recentDateFormat.getTimeZone());
-				parsed = hackFormatter.parse(timeStampStrPlusYear, pp);
-			}
-			if (parsed != null && pp.getIndex() == timestampStr.length() + 5) {
+			pp = new ParsePosition(0);
+			parsed = defaultDateFormat.parse(timestampStr, pp);
+			// note, length checks are mandatory for us since
+			// SimpleDateFormat methods will succeed if less than
+			// full string is matched.  They will also accept, 
+			// despite "leniency" setting, a two-digit number as
+			// a valid year (e.g. 22:04 will parse as 22 A.D.) 
+			// so could mistakenly confuse an hour with a year, 
+			// if we don't insist on full length parsing.
+			if (parsed != null && pp.getIndex() == timestampStr.length()) {
 				working.setTime(parsed);
-			}
-			else {
-				pp = new ParsePosition(0);
-				parsed = defaultDateFormat.parse(timestampStr, pp);
-				// note, length checks are mandatory for us since
-				// SimpleDateFormat methods will succeed if less than
-				// full string is matched.  They will also accept, 
-				// despite "leniency" setting, a two-digit number as
-				// a valid year (e.g. 22:04 will parse as 22 A.D.) 
-				// so could mistakenly confuse an hour with a year, 
-				// if we don't insist on full length parsing.
-				if (parsed != null && pp.getIndex() == timestampStr.length()) {
-					working.setTime(parsed);
-				} else {
-					throw new ParseException(
-							"Timestamp could not be parsed with older or recent DateFormat", 
-							pp.getIndex());
-				}
+			} else {
+				throw new ParseException(
+						"Timestamp could not be parsed with older or recent DateFormat", 
+						pp.getIndex());
 			}
 		}
 		return working;
