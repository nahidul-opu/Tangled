From 1feaeb03ebdfad34715c0238effce75fa08b74f1 Mon Sep 17 00:00:00 2001
From: Oliver Heger <oheger@apache.org>
Date: Sun, 6 Jun 2010 15:56:47 +0000
Subject: [PATCH] [CONFIGURATION-418] Improved handling of escaped list
 delimiters

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/configuration/trunk@951878 13f79535-47bb-0310-9956-ffa450edef68
---
 conf/test.properties                          |  6 ++
 .../PropertiesConfiguration.java              | 81 ++++++++++++++++---
 .../TestPropertiesConfiguration.java          | 27 +++++++
 3 files changed, 101 insertions(+), 13 deletions(-)

diff --git a/conf/test.properties b/conf/test.properties
index 3855b4f98c..051f51d46a 100644
--- a/conf/test.properties
+++ b/conf/test.properties
@@ -102,3 +102,9 @@ test.separator.formfeedfoo
 test.separator.whitespace foo
 test.separator.no.space=foo
 
+# Tests for backslash escaping in lists
+test.share1 = \\\\\\\\share1a, \\\\\\\\share1b
+test.share2 = \\\\share2a
+test.share2 = \\\\share2b
+test.share3 = \\\\\\\\share3a\\\\\\\\,\\\\\\\\share3b\\
+
diff --git a/src/java/org/apache/commons/configuration/PropertiesConfiguration.java b/src/java/org/apache/commons/configuration/PropertiesConfiguration.java
index ec945bf881..3e2290b348 100644
--- a/src/java/org/apache/commons/configuration/PropertiesConfiguration.java
+++ b/src/java/org/apache/commons/configuration/PropertiesConfiguration.java
@@ -210,6 +210,9 @@ public class PropertiesConfiguration extends AbstractFileConfiguration
     /** Constant for the escaping character.*/
     private static final String ESCAPE = "\\";
 
+    /** Constant for the escaped escaping character.*/
+    private static final String DOUBLE_ESC = ESCAPE + ESCAPE;
+
     /** Constant for the radix of hex numbers.*/
     private static final int HEX_RADIX = 16;
 
@@ -588,6 +591,24 @@ static boolean isCommentLine(String line)
         return s.length() < 1 || COMMENT_CHARS.indexOf(s.charAt(0)) >= 0;
     }
 
+    /**
+     * Returns the number of trailing backslashes. This is sometimes needed for
+     * the correct handling of escape characters.
+     *
+     * @param line the string to investigate
+     * @return the number of trailing backslashes
+     */
+    private static int countTrailingBS(String line)
+    {
+        int bsCount = 0;
+        for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\'; idx--)
+        {
+            bsCount++;
+        }
+
+        return bsCount;
+    }
+
     /**
      * This class is used to read properties lines. These lines do
      * not terminate with new-line chars but rather when there is no
@@ -828,13 +849,7 @@ protected void initPropertySeparator(String value)
          */
         private static boolean checkCombineLines(String line)
         {
-            int bsCount = 0;
-            for (int idx = line.length() - 1; idx >= 0 && line.charAt(idx) == '\\'; idx--)
-            {
-                bsCount++;
-            }
-
-            return bsCount % 2 != 0;
+            return countTrailingBS(line) % 2 != 0;
         }
 
         /**
@@ -1104,7 +1119,7 @@ public void writeProperty(String key, Object value,
             }
             else
             {
-                v = escapeValue(value);
+                v = escapeValue(value, false);
             }
 
             write(escapeKey(key));
@@ -1160,12 +1175,13 @@ private String escapeKey(String key)
          * will be escaped.
          *
          * @param value the property value
+         * @param inList a flag whether the value is part of a list
          * @return the escaped property value
          * @since 1.3
          */
-        private String escapeValue(Object value)
+        private String escapeValue(Object value, boolean inList)
         {
-            String escapedValue = StringEscapeUtils.escapeJava(String.valueOf(value));
+            String escapedValue = handleBackslashs(value, inList);
             if (delimiter != 0)
             {
                 escapedValue = StringUtils.replace(escapedValue, String.valueOf(delimiter), ESCAPE + delimiter);
@@ -1173,6 +1189,45 @@ private String escapeValue(Object value)
             return escapedValue;
         }
 
+        /**
+         * Performs the escaping of backslashes in the specified properties
+         * value. Because a double backslash is used to escape the escape
+         * character of a list delimiter, double backslashes also have to be
+         * escaped if the property is part of a (single line) list. Then, in all cases each backslash has to be doubled in order to produce a
+         * valid properties file.
+         *
+         * @param value the value to be escaped
+         * @param inList a flag whether the value is part of a list
+         * @return the value with escaped backslashes as string
+         */
+        private String handleBackslashs(Object value, boolean inList)
+        {
+            String strValue = String.valueOf(value);
+
+            if (inList && strValue.indexOf(DOUBLE_ESC) >= 0)
+            {
+                char esc = ESCAPE.charAt(0);
+                StringBuffer buf = new StringBuffer(strValue.length() + 8);
+                for (int i = 0; i < strValue.length(); i++)
+                {
+                    if (strValue.charAt(i) == esc && i < strValue.length() - 1
+                            && strValue.charAt(i + 1) == esc)
+                    {
+                        buf.append(DOUBLE_ESC).append(DOUBLE_ESC);
+                        i++;
+                    }
+                    else
+                    {
+                        buf.append(strValue.charAt(i));
+                    }
+                }
+
+                strValue = buf.toString();
+            }
+
+            return StringEscapeUtils.escapeJava(strValue);
+        }
+
         /**
          * Transforms a list of values into a single line value.
          *
@@ -1185,19 +1240,19 @@ private String makeSingleLineValue(List values)
             if (!values.isEmpty())
             {
                 Iterator it = values.iterator();
-                String lastValue = escapeValue(it.next());
+                String lastValue = escapeValue(it.next(), true);
                 StringBuffer buf = new StringBuffer(lastValue);
                 while (it.hasNext())
                 {
                     // if the last value ended with an escape character, it has
                     // to be escaped itself; otherwise the list delimiter will
                     // be escaped
-                    if (lastValue.endsWith(ESCAPE))
+                    if (lastValue.endsWith(ESCAPE) && (countTrailingBS(lastValue) / 2) % 2 != 0)
                     {
                         buf.append(ESCAPE).append(ESCAPE);
                     }
                     buf.append(delimiter);
-                    lastValue = escapeValue(it.next());
+                    lastValue = escapeValue(it.next(), true);
                     buf.append(lastValue);
                 }
                 return buf.toString();
diff --git a/src/test/org/apache/commons/configuration/TestPropertiesConfiguration.java b/src/test/org/apache/commons/configuration/TestPropertiesConfiguration.java
index e5d1d3b5fb..81a1715524 100644
--- a/src/test/org/apache/commons/configuration/TestPropertiesConfiguration.java
+++ b/src/test/org/apache/commons/configuration/TestPropertiesConfiguration.java
@@ -994,6 +994,33 @@ public void testSlashEscaping() throws ConfigurationException
                 + " = http://www.apache.org") >= 0);
     }
 
+    /**
+     * Tests whether backslashes are correctly handled if lists are parsed. This
+     * test is related to CONFIGURATION-418.
+     */
+    public void testBackslashEscapingInLists() throws ConfigurationException
+    {
+        checkBackslashList("share2");
+        checkBackslashList("share1");
+    }
+
+    /**
+     * Helper method for testing the content of a list with elements that
+     * contain backslashes.
+     *
+     * @param key the key
+     */
+    private void checkBackslashList(String key)
+    {
+        Object prop = conf.getProperty("test." + key);
+        assertTrue("Not a list", prop instanceof List);
+        List list = (List) prop;
+        assertEquals("Wrong number of list elements", 2, list.size());
+        final String prefix = "\\\\" + key;
+        assertEquals("Wrong element 1", prefix + "a", list.get(0));
+        assertEquals("Wrong element 2", prefix + "b", list.get(1));
+    }
+
     /**
      * Creates a configuration that can be used for testing copy operations.
      *
