From 71d7c3264239c55b6e2daf89c44c5685085f26dd Mon Sep 17 00:00:00 2001
From: Chas Honton <chas@apache.org>
Date: Sat, 9 May 2015 16:40:56 -0700
Subject: [PATCH] LANG-1133
 FastDateParser_TimeZoneStrategyTest#testTimeZoneStrategyPattern fails on
 Windows with German Locale reimplementing LANG-1107

---
 src/changes/changes.xml                       |  1 +
 .../commons/lang3/time/FastDateParser.java    | 88 +++++++++++--------
 .../FastDateParser_TimeZoneStrategyTest.java  | 28 +++---
 3 files changed, 67 insertions(+), 50 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index aa455333b7d..6a7a864dc24 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -22,6 +22,7 @@
   <body>
 
   <release version="3.5" date="tba" description="tba">
+    <action issue="LANG-1133" type="bug" dev="chas" due-to="Pascal Schumacher">FastDateParser_TimeZoneStrategyTest#testTimeZoneStrategyPattern fails on Windows with German Locale</action>
     <action issue="LANG-1135" type="add" dev="britter" due-to="Eduardo Martins">Add method containsAllWords to WordUtils</action>
     <action issue="LANG-1132" type="add" dev="britter" due-to="Jack Tan">ReflectionToStringBuilder doesn't throw IllegalArgumentException when the constructor's object param is null</action>
     <action issue="LANG-1122" type="fix" dev="britter" due-to="Adrian Ber">Inconsistent behavior of swap for malformed inputs</action>
diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
index f8a700e426d..7863322ade5 100644
--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java
@@ -29,9 +29,7 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
-import java.util.SortedMap;
 import java.util.TimeZone;
-import java.util.TreeMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.regex.Matcher;
@@ -369,6 +367,30 @@ public Date parse(final String source, final ParsePosition pos) {
     // Support for strategies
     //-----------------------------------------------------------------------
 
+    private static StringBuilder simpleQuote(final StringBuilder sb, final String value) {
+        for(int i= 0; i<value.length(); ++i) {
+            char c= value.charAt(i);
+            switch(c) {
+            case '\\':
+            case '^':
+            case '$':
+            case '.':
+            case '|':
+            case '?':
+            case '*':
+            case '+':
+            case '(':
+            case ')':
+            case '[':
+            case '{':
+                sb.append('\\');
+            default:
+                sb.append(c);
+            }
+        }
+        return sb;
+    }
+
     /**
      * Escape constant fields into regular expression
      * @param regex The destination regex
@@ -667,7 +689,7 @@ private static class CaseInsensitiveTextStrategy extends Strategy {
         boolean addRegex(final FastDateParser parser, final StringBuilder regex) {
             regex.append("((?iu)");
             for(final String textKeyValue : lKeyValues.keySet()) {
-                escapeRegex(regex, textKeyValue, false).append('|');
+                simpleQuote(regex, textKeyValue).append('|');
             }
             regex.setCharAt(regex.length()-1, ')');
             return true;
@@ -768,56 +790,44 @@ void setCalendar(final FastDateParser parser, final Calendar cal, final String v
     static class TimeZoneStrategy extends Strategy {
         private static final String RFC_822_TIME_ZONE = "[+-]\\d{4}";
         private static final String GMT_OPTION= "GMT[+-]\\d{1,2}:\\d{2}";
-        // see http://www.iana.org/time-zones and http://cldr.unicode.org/translation/timezones
-        static final String TZ_DATABASE= "(?:\\p{L}[\\p{L}\\p{Mc}\\p{Nd}\\p{Zs}\\p{P}&&[^-]]*-?\\p{Zs}?)*";
-        private static final String VALID_TZ = "((?iu)"+RFC_822_TIME_ZONE+"|"+GMT_OPTION+"|"+TZ_DATABASE+")";
         
-        private final SortedMap<String, TimeZone> tzNames= new TreeMap<String, TimeZone>(String.CASE_INSENSITIVE_ORDER);
+        private final Locale locale;
+        private final Map<String, TimeZone> tzNames= new HashMap<String, TimeZone>();
+        private final String validTimeZoneChars;
 
         /**
          * Index of zone id
          */
         private static final int ID = 0;
-        /**
-         * Index of the long name of zone in standard time
-         */
-        private static final int LONG_STD = 1;
-        /**
-         * Index of the short name of zone in standard time
-         */
-        private static final int SHORT_STD = 2;
-        /**
-         * Index of the long name of zone in daylight saving time
-         */
-        private static final int LONG_DST = 3;
-        /**
-         * Index of the short name of zone in daylight saving time
-         */
-        private static final int SHORT_DST = 4;
 
         /**
          * Construct a Strategy that parses a TimeZone
          * @param locale The Locale
          */
         TimeZoneStrategy(final Locale locale) {
+            this.locale = locale;
+
+            final StringBuilder sb = new StringBuilder();
+            sb.append('(' + RFC_822_TIME_ZONE + "|(?iu)" + GMT_OPTION );
+
             final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();
-            for (final String[] zone : zones) {
-                final TimeZone tz = TimeZone.getTimeZone(zone[ID]);
-                if (!tzNames.containsKey(zone[LONG_STD])){
-                    tzNames.put(zone[LONG_STD], tz);
-                }
-                if (!tzNames.containsKey(zone[SHORT_STD])){
-                    tzNames.put(zone[SHORT_STD], tz);
+            for (final String[] zoneNames : zones) {
+                final String tzId = zoneNames[ID];
+                if (tzId.equalsIgnoreCase("GMT")) {
+                    continue;
                 }
-                if (tz.useDaylightTime()) {
-                    if (!tzNames.containsKey(zone[LONG_DST])){
-                        tzNames.put(zone[LONG_DST], tz);
-                    }
-                    if (!tzNames.containsKey(zone[SHORT_DST])){
-                        tzNames.put(zone[SHORT_DST], tz);
+                final TimeZone tz = TimeZone.getTimeZone(tzId);
+                for(int i= 1; i<zoneNames.length; ++i) {
+                    String zoneName = zoneNames[i].toLowerCase(locale);
+                    if (!tzNames.containsKey(zoneName)){
+                        tzNames.put(zoneName, tz);
+                        simpleQuote(sb.append('|'), zoneName);
                     }
                 }
-            }            
+            }
+
+            sb.append(')');
+            validTimeZoneChars = sb.toString();
         }
 
         /**
@@ -825,7 +835,7 @@ static class TimeZoneStrategy extends Strategy {
          */
         @Override
         boolean addRegex(final FastDateParser parser, final StringBuilder regex) {
-            regex.append(VALID_TZ);
+            regex.append(validTimeZoneChars);
             return true;
         }
 
@@ -842,7 +852,7 @@ else if(value.regionMatches(true, 0, "GMT", 0, 3)) {
                 tz= TimeZone.getTimeZone(value.toUpperCase());
             }
             else {
-                tz= tzNames.get(value);
+                tz= tzNames.get(value.toLowerCase(locale));
                 if(tz==null) {
                     throw new IllegalArgumentException(value + " is not a supported timezone name");
                 }
diff --git a/src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java b/src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java
index e9746277002..7c557be7e9c 100644
--- a/src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java
+++ b/src/test/java/org/apache/commons/lang3/time/FastDateParser_TimeZoneStrategyTest.java
@@ -16,27 +16,33 @@
  */
 package org.apache.commons.lang3.time;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
 import java.text.DateFormatSymbols;
 import java.util.Locale;
-import java.util.regex.Pattern;
+import java.util.TimeZone;
 
+import org.junit.Assert;
 import org.junit.Test;
 
 public class FastDateParser_TimeZoneStrategyTest {
 
     @Test
     public void testTimeZoneStrategyPattern() {
-        Pattern tz = Pattern.compile(FastDateParser.TimeZoneStrategy.TZ_DATABASE);
-        assertFalse(tz.matcher("GMT-1234").matches());
-
-        for (Locale locale : Locale.getAvailableLocales()) {
+        for(final Locale locale : Locale.getAvailableLocales()) {
+            final FastDateParser parser = new FastDateParser("z", TimeZone.getDefault(), locale);
             final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();
-            for (final String[] zone : zones) {
-                for (String zoneExpr : zone) {
-                    assertTrue(locale.getDisplayName() + ":" + zoneExpr, tz.matcher(zoneExpr).matches());
+            for(final String[] zone :  zones) {
+                for(int t = 1; t<zone.length; ++t) {
+                    final String tzDisplay = zone[t];
+
+                    try {
+                        parser.parse(tzDisplay);
+                    }
+                    catch(Exception ex) {
+                        Assert.fail(tzDisplay
+                                + " Locale: " + locale.getDisplayName()
+                                + " TimeZone: " + zone[0]
+                                + " offset: " + t);
+                    }
                 }
             }
         }
