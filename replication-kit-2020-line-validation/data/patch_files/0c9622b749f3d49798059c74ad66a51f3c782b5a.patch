From 0c9622b749f3d49798059c74ad66a51f3c782b5a Mon Sep 17 00:00:00 2001
From: "Gary D. Gregory" <ggregory@apache.org>
Date: Sat, 24 Nov 2012 01:56:20 +0000
Subject: [PATCH] <action issue="LANG-858"
 type="fix">StringEscapeUtils.escapeJava() and escapeEcmaScript() do not
 output the escaped surrogate pairs that are Java parsable</action>

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/lang/trunk@1413114 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  1 +
 .../commons/lang3/StringEscapeUtils.java      |  5 +-
 .../text/translate/JavaUnicodeEscaper.java    | 96 +++++++++++++++++++
 .../lang3/text/translate/UnicodeEscaper.java  | 12 ++-
 .../apache/commons/lang3/StringUtilsTest.java |  1 -
 5 files changed, 107 insertions(+), 8 deletions(-)
 create mode 100644 src/main/java/org/apache/commons/lang3/text/translate/JavaUnicodeEscaper.java

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index f31c928a72f..6895d57f092 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -22,6 +22,7 @@
   <body>
 
   <release version="3.2" date="TBA" description="Next release">
+    <action issue="LANG-858" type="fix">StringEscapeUtils.escapeJava() and escapeEcmaScript() do not output the escaped surrogate pairs that are Java parsable</action>
     <action issue="LANG-857" type="add">StringIndexOutOfBoundsException in CharSequenceTranslator</action>
     <action issue="LANG-856" type="add">Code refactoring in NumberUtils</action>
     <action issue="LANG-855" type="add">NumberUtils#createBigInteger does not allow for hex and octal numbers</action>
diff --git a/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java b/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java
index ec0b931ee17..d3b969ad16a 100644
--- a/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java
+++ b/src/main/java/org/apache/commons/lang3/StringEscapeUtils.java
@@ -22,6 +22,7 @@
 import org.apache.commons.lang3.text.translate.AggregateTranslator;
 import org.apache.commons.lang3.text.translate.CharSequenceTranslator;
 import org.apache.commons.lang3.text.translate.EntityArrays;
+import org.apache.commons.lang3.text.translate.JavaUnicodeEscaper;
 import org.apache.commons.lang3.text.translate.LookupTranslator;
 import org.apache.commons.lang3.text.translate.NumericEntityUnescaper;
 import org.apache.commons.lang3.text.translate.OctalUnescaper;
@@ -57,7 +58,7 @@ public class StringEscapeUtils {
           }).with(
             new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE())
           ).with(
-            UnicodeEscaper.outsideOf(32, 0x7f) 
+            JavaUnicodeEscaper.outsideOf(32, 0x7f) 
         );
 
     /**
@@ -79,7 +80,7 @@ public class StringEscapeUtils {
                             {"/", "\\/"}
                       }),
             new LookupTranslator(EntityArrays.JAVA_CTRL_CHARS_ESCAPE()),
-            UnicodeEscaper.outsideOf(32, 0x7f) 
+            JavaUnicodeEscaper.outsideOf(32, 0x7f) 
         );
             
     /**
diff --git a/src/main/java/org/apache/commons/lang3/text/translate/JavaUnicodeEscaper.java b/src/main/java/org/apache/commons/lang3/text/translate/JavaUnicodeEscaper.java
new file mode 100644
index 00000000000..03f01d7156a
--- /dev/null
+++ b/src/main/java/org/apache/commons/lang3/text/translate/JavaUnicodeEscaper.java
@@ -0,0 +1,96 @@
+package org.apache.commons.lang3.text.translate;
+
+/**
+ * Translates codepoints to their Unicode escaped value suitable for Java source.
+ * 
+ * @since 3.2
+ * @version $Id$
+ */
+public class JavaUnicodeEscaper extends UnicodeEscaper {
+
+    /**
+     * <p>
+     * Constructs a <code>JavaUnicodeEscaper</code> above the specified value (exclusive).
+     * </p>
+     * 
+     * @param codepoint
+     *            above which to escape
+     * @return the newly created {@code UnicodeEscaper} instance
+     */
+    public static JavaUnicodeEscaper above(int codepoint) {
+        return outsideOf(0, codepoint);
+    }
+
+    /**
+     * <p>
+     * Constructs a <code>JavaUnicodeEscaper</code> below the specified value (exclusive).
+     * </p>
+     * 
+     * @param codepoint
+     *            below which to escape
+     * @return the newly created {@code UnicodeEscaper} instance
+     */
+    public static JavaUnicodeEscaper below(int codepoint) {
+        return outsideOf(codepoint, Integer.MAX_VALUE);
+    }
+
+    /**
+     * <p>
+     * Constructs a <code>JavaUnicodeEscaper</code> between the specified values (inclusive).
+     * </p>
+     * 
+     * @param codepointLow
+     *            above which to escape
+     * @param codepointHigh
+     *            below which to escape
+     * @return the newly created {@code UnicodeEscaper} instance
+     */
+    public static JavaUnicodeEscaper between(int codepointLow, int codepointHigh) {
+        return new JavaUnicodeEscaper(codepointLow, codepointHigh, true);
+    }
+
+    /**
+     * <p>
+     * Constructs a <code>JavaUnicodeEscaper</code> outside of the specified values (exclusive).
+     * </p>
+     * 
+     * @param codepointLow
+     *            below which to escape
+     * @param codepointHigh
+     *            above which to escape
+     * @return the newly created {@code UnicodeEscaper} instance
+     */
+    public static JavaUnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {
+        return new JavaUnicodeEscaper(codepointLow, codepointHigh, false);
+    }
+
+    /**
+     * <p>
+     * Constructs a <code>JavaUnicodeEscaper</code> for the specified range. This is the underlying method for the
+     * other constructors/builders. The <code>below</code> and <code>above</code> boundaries are inclusive when
+     * <code>between</code> is <code>true</code> and exclusive when it is <code>false</code>.
+     * </p>
+     * 
+     * @param below
+     *            int value representing the lowest codepoint boundary
+     * @param above
+     *            int value representing the highest codepoint boundary
+     * @param between
+     *            whether to escape between the boundaries or outside them
+     */
+    public JavaUnicodeEscaper(int below, int above, boolean between) {
+        super(below, above, between);
+    }
+
+    /**
+     * Converts the given codepoint to a hex string of the form {@code "\\uXXXX\\uXXXX"}
+     * 
+     * @param codePoint
+     *            a Unicode code point
+     */
+    protected String toUtf16Escape(int codepoint) {
+        char[] surrogatePair = Character.toChars(codepoint);
+        return "\\u" + hex(surrogatePair[0]) + "\\u" + hex(surrogatePair[1]);
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java
index 05c12229179..4214064ce8f 100644
--- a/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java
+++ b/src/main/java/org/apache/commons/lang3/text/translate/UnicodeEscaper.java
@@ -48,7 +48,7 @@ public UnicodeEscaper(){
      * @param above int value representing the highest codepoint boundary
      * @param between whether to escape between the boundaries or outside them
      */
-    private UnicodeEscaper(int below, int above, boolean between) {
+    protected UnicodeEscaper(int below, int above, boolean between) {
         this.below = below;
         this.above = above;
         this.between = between;
@@ -101,7 +101,7 @@ public static UnicodeEscaper between(int codepointLow, int codepointHigh) {
      */
     @Override
     public boolean translate(int codepoint, Writer out) throws IOException {
-        if(between) {
+        if (between) {
             if (codepoint < below || codepoint > above) {
                 return false;
             }
@@ -113,9 +113,7 @@ public boolean translate(int codepoint, Writer out) throws IOException {
 
         // TODO: Handle potential + sign per various Unicode escape implementations
         if (codepoint > 0xffff) {
-            // TODO: Figure out what to do. Output as two Unicodes?
-            //       Does this make this a Java-specific output class?
-            out.write("\\u" + hex(codepoint));
+            out.write(toUtf16Escape(codepoint));
         } else if (codepoint > 0xfff) {
             out.write("\\u" + hex(codepoint));
         } else if (codepoint > 0xff) {
@@ -127,4 +125,8 @@ public boolean translate(int codepoint, Writer out) throws IOException {
         }
         return true;
     }
+
+    protected String toUtf16Escape(int codepoint) {
+        return "\\u" + hex(codepoint);
+    }
 }
diff --git a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java
index 31cf6ad9595..834e9104173 100644
--- a/src/test/java/org/apache/commons/lang3/StringUtilsTest.java
+++ b/src/test/java/org/apache/commons/lang3/StringUtilsTest.java
@@ -2201,7 +2201,6 @@ public void testEscapeSurrogatePairs() throws Exception {
      * @throws Exception
      */
     @Test
-    @Ignore
     public void testEscapeSurrogatePairsLang858() throws Exception {
         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeJava("\uDBFF\uDFFD"));       //fail LANG-858
         assertEquals("\\uDBFF\\uDFFD", StringEscapeUtils.escapeEcmaScript("\uDBFF\uDFFD")); //fail LANG-858
