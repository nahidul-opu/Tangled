From ded56ffd598e41e32817f6c1b091595fe7122e8b Mon Sep 17 00:00:00 2001
From: Alex Levenson <alexlevenson@twitter.com>
Date: Tue, 19 May 2015 19:36:04 -0700
Subject: [PATCH] PARQUET-287: Keep a least 1 column from union members when
 projecting thrift unions

Currently, the projection API allows you to select only some "kinds" of a union, or to drop a required union entirely. This becomes an issue when assembling these records, as they will be appear to be unions of an unknown type (how do you coerce an empty struct into a union?). The way this case is handled for primitives is by supplying a default value (like 0, or null). However, with a union, you have to choose what "kind" of the union it will act as, and in the interest of not being misleading, this PR reads one column to figure out what the correct "kind" is.

In the future, the better solution is to filter these records out -- a projection is really a request for a filter in this case. But for now, this should get us correctness without involving the filter API.

I think this PR needs some more tests before merging, but I wanted to get it out and get some feedback now.

I also refactored how ThriftSchemaVisitor works to not be stateful, by explicitly passing state through the recursion -- this makes it much easier to reason about.

*edit* This PR also includes a fix for PARQUET-275 because I encountered it during testing.

*edit 2* This PR also includes a fix for PARQUET-283

Author: Alex Levenson <alexlevenson@twitter.com>

Closes #189 from isnotinvain/alexlevenson/project-union and squashes the following commits:

c710702 [Alex Levenson] Avoid instantiating (unused) empty group type
c43a44c [Alex Levenson] Merge branch 'master' into alexlevenson/project-union
d62ee8c [Alex Levenson] Merge branch 'master' into alexlevenson/project-union
df51f41 [Alex Levenson] Fix tests
4d3f825 [Alex Levenson] Address review comments
6dd95f5 [Alex Levenson] Update tests to reflect changes
d7cee7e [Alex Levenson] Add tests for nested maps
9c34b20 [Alex Levenson] Keep a sentinel column in map values
53e5580 [Alex Levenson] Remove debug println
c525a65 [Alex Levenson] update docs to reflect set projection rules
aefb637 [Alex Levenson] Do not allow partial projection of keys or set elements
8b4e791 [Alex Levenson] Add tests for maps of unions
35de282 [Alex Levenson] Add test for list<union>
098630f [Alex Levenson] Merge branch 'master' into alexlevenson/project-union
77cc9e9 [Alex Levenson] Add license header
63b80fd [Alex Levenson] more clean up
6341747 [Alex Levenson] Clean up ConvertedField
dcd3ea9 [Alex Levenson] Merge branch 'master' into alexlevenson/project-union
9ce4781 [Alex Levenson] Some cleanup and comments
6964837 [Alex Levenson] Keep one sentinel column in projected unions that cannot be dropped entirely
37a9bef [Alex Levenson] Clean up visitor pattern for thrift types
---
 .../apache/parquet/thrift/ConvertedField.java | 167 ++++++
 .../thrift/KeepOnlyFirstPrimitiveFilter.java  |  44 ++
 .../thrift/ThriftSchemaConvertVisitor.java    | 401 +++++++++------
 .../parquet/thrift/ThriftSchemaConverter.java |  11 +-
 .../projection/FieldProjectionFilter.java     |   3 +-
 .../parquet/thrift/projection/FieldsPath.java |  18 +-
 .../amend/DefaultEventsVisitor.java           |  43 +-
 .../amend/DefaultProtocolEventsGenerator.java |   2 +-
 .../thrift/struct/CompatibilityChecker.java   |  65 ++-
 .../parquet/thrift/struct/ThriftType.java     | 121 ++---
 ...ParquetToThriftReadWriteAndProjection.java | 140 +++++
 .../thrift/TestThriftSchemaConverter.java     |  93 +++-
 ...TestThriftSchemaConverterProjectUnion.java | 480 ++++++++++++++++++
 .../thrift/projection/TestFieldsPath.java     |  80 ++-
 parquet-thrift/src/test/thrift/compat.thrift  |  94 ++++
 parquet_cascading.md                          |   6 +-
 16 files changed, 1420 insertions(+), 348 deletions(-)
 create mode 100644 parquet-thrift/src/main/java/org/apache/parquet/thrift/ConvertedField.java
 create mode 100644 parquet-thrift/src/main/java/org/apache/parquet/thrift/KeepOnlyFirstPrimitiveFilter.java
 create mode 100644 parquet-thrift/src/test/java/org/apache/parquet/thrift/TestThriftSchemaConverterProjectUnion.java

diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/ConvertedField.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/ConvertedField.java
new file mode 100644
index 0000000000..9674054511
--- /dev/null
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/ConvertedField.java
@@ -0,0 +1,167 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.parquet.thrift;
+
+import org.apache.parquet.ShouldNeverHappenException;
+import org.apache.parquet.schema.Type;
+import org.apache.parquet.thrift.projection.FieldsPath;
+
+import static org.apache.parquet.Preconditions.checkNotNull;
+
+/**
+ * This is the return value for the recursion done in {@link ThriftSchemaConvertVisitor}
+ * It represents a field that has been converted from a {@link org.apache.parquet.thrift.struct.ThriftType}
+ * to a {@link org.apache.parquet.schema.MessageType}, as well as whether this field is being
+ * projected away, kept, or kept only because we cannot safely drop all of its fields.
+ *
+ * This interface is essentially a union of {keep, drop, sentinelUnion}
+ */
+public interface ConvertedField {
+
+  /**
+   * The path from the root of the schema to this field.
+   */
+  FieldsPath path();
+
+  boolean isKeep();
+  Keep asKeep();
+
+  boolean isDrop();
+  Drop asDrop();
+
+  boolean isSentinelUnion();
+  SentinelUnion asSentinelUnion();
+
+  static abstract class ConvertedFieldBase implements ConvertedField {
+    private final FieldsPath path;
+
+    protected ConvertedFieldBase(FieldsPath path) {
+      this.path = checkNotNull(path, "path");
+    }
+
+    @Override
+    public boolean isKeep() {
+      return false;
+    }
+
+    @Override
+    public Keep asKeep() {
+      throw new ShouldNeverHappenException("asKeep called on " + this);
+    }
+
+    @Override
+    public boolean isDrop() {
+      return false;
+    }
+
+    @Override
+    public Drop asDrop() {
+      throw new ShouldNeverHappenException("asDrop called on " + this);
+    }
+
+    @Override
+    public boolean isSentinelUnion() {
+      return false;
+    }
+
+    @Override
+    public SentinelUnion asSentinelUnion() {
+      throw new ShouldNeverHappenException("asSentinelUnion called on " + this);
+    }
+
+    @Override
+    public FieldsPath path() {
+      return path;
+    }
+  }
+
+  /**
+   * Signals that the user explicitly requested either this field or one of its children.
+   */
+  public static final class Keep extends ConvertedFieldBase {
+    private final Type type;
+
+    public Keep(FieldsPath path, Type type) {
+      super(path);
+      this.type = checkNotNull(type, "type");
+    }
+
+    @Override
+    public boolean isKeep() {
+      return true;
+    }
+
+    @Override
+    public Keep asKeep() {
+      return this;
+    }
+
+    public Type getType() {
+      return type;
+    }
+  }
+
+  /**
+   * Signals that the user did not explicitly request this field nor its children, but
+   * we carry the converted type info anyway in case it is not possible to drop this union
+   * entirely.
+   */
+  public static final class SentinelUnion extends ConvertedFieldBase {
+    private final Type type;
+
+    public SentinelUnion(FieldsPath path, Type type) {
+      super(path);
+      this.type = checkNotNull(type, "type");
+    }
+
+    @Override
+    public boolean isSentinelUnion() {
+      return true;
+    }
+
+    @Override
+    public SentinelUnion asSentinelUnion() {
+      return this;
+    }
+
+    public Type getType() {
+      return type;
+    }
+  }
+
+  /**
+   * Signals the user did not request this field nor its children.
+   */
+  public static final class Drop extends ConvertedFieldBase {
+    public Drop(FieldsPath path) {
+      super(path);
+    }
+
+    @Override
+    public boolean isDrop() {
+      return true;
+    }
+
+    @Override
+    public Drop asDrop() {
+      return this;
+    }
+  }
+}
+
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/KeepOnlyFirstPrimitiveFilter.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/KeepOnlyFirstPrimitiveFilter.java
new file mode 100644
index 0000000000..bc3df93c84
--- /dev/null
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/KeepOnlyFirstPrimitiveFilter.java
@@ -0,0 +1,44 @@
+/* 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.parquet.thrift;
+
+import org.apache.parquet.thrift.projection.FieldProjectionFilter;
+import org.apache.parquet.thrift.projection.FieldsPath;
+import org.apache.parquet.thrift.projection.ThriftProjectionException;
+
+/**
+ * A {@link FieldProjectionFilter} that keeps only the first primitive field
+ * that it encounters.
+ */
+class KeepOnlyFirstPrimitiveFilter implements FieldProjectionFilter {
+  private boolean found = false;
+
+  @Override
+  public boolean keep(FieldsPath path) {
+    if (found) {
+      return false;
+    }
+
+    found = true;
+    return true;
+  }
+
+  @Override
+  public void assertNoUnmatchedPatterns() throws ThriftProjectionException { }
+}
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/ThriftSchemaConvertVisitor.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/ThriftSchemaConvertVisitor.java
index 3081d87b4a..25347f8ac7 100644
--- a/parquet-thrift/src/main/java/org/apache/parquet/thrift/ThriftSchemaConvertVisitor.java
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/ThriftSchemaConvertVisitor.java
@@ -18,36 +18,54 @@
  */
 package org.apache.parquet.thrift;
 
-import static org.apache.parquet.schema.ConversionPatterns.listType;
-import static org.apache.parquet.schema.ConversionPatterns.mapType;
-import static org.apache.parquet.schema.OriginalType.ENUM;
-import static org.apache.parquet.schema.OriginalType.UTF8;
-import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.BINARY;
-import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.BOOLEAN;
-import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.DOUBLE;
-import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.INT32;
-import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.INT64;
-import static org.apache.parquet.schema.Type.Repetition.OPTIONAL;
-import static org.apache.parquet.schema.Type.Repetition.REPEATED;
-import static org.apache.parquet.schema.Type.Repetition.REQUIRED;
-import static org.apache.parquet.schema.Types.primitive;
-
 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.parquet.Preconditions;
+import org.apache.parquet.ShouldNeverHappenException;
 import org.apache.parquet.schema.GroupType;
 import org.apache.parquet.schema.MessageType;
 import org.apache.parquet.schema.OriginalType;
 import org.apache.parquet.schema.PrimitiveType;
 import org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName;
 import org.apache.parquet.schema.Type;
+import org.apache.parquet.schema.Type.Repetition;
 import org.apache.parquet.schema.Types.PrimitiveBuilder;
+import org.apache.parquet.thrift.ConvertedField.Drop;
+import org.apache.parquet.thrift.ConvertedField.Keep;
+import org.apache.parquet.thrift.ConvertedField.SentinelUnion;
 import org.apache.parquet.thrift.projection.FieldProjectionFilter;
 import org.apache.parquet.thrift.projection.FieldsPath;
 import org.apache.parquet.thrift.projection.ThriftProjectionException;
 import org.apache.parquet.thrift.struct.ThriftField;
 import org.apache.parquet.thrift.struct.ThriftType;
+import org.apache.parquet.thrift.struct.ThriftType.BoolType;
+import org.apache.parquet.thrift.struct.ThriftType.ByteType;
+import org.apache.parquet.thrift.struct.ThriftType.DoubleType;
+import org.apache.parquet.thrift.struct.ThriftType.EnumType;
+import org.apache.parquet.thrift.struct.ThriftType.I16Type;
+import org.apache.parquet.thrift.struct.ThriftType.I32Type;
+import org.apache.parquet.thrift.struct.ThriftType.I64Type;
+import org.apache.parquet.thrift.struct.ThriftType.ListType;
+import org.apache.parquet.thrift.struct.ThriftType.MapType;
+import org.apache.parquet.thrift.struct.ThriftType.SetType;
+import org.apache.parquet.thrift.struct.ThriftType.StringType;
+import org.apache.parquet.thrift.struct.ThriftType.StructType;
+import org.apache.parquet.thrift.struct.ThriftType.StructType.StructOrUnionType;
+
+import static org.apache.parquet.Preconditions.checkNotNull;
+import static org.apache.parquet.schema.ConversionPatterns.listType;
+import static org.apache.parquet.schema.ConversionPatterns.mapType;
+import static org.apache.parquet.schema.OriginalType.ENUM;
+import static org.apache.parquet.schema.OriginalType.UTF8;
+import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.BINARY;
+import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.BOOLEAN;
+import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.DOUBLE;
+import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.INT32;
+import static org.apache.parquet.schema.PrimitiveType.PrimitiveTypeName.INT64;
+import static org.apache.parquet.schema.Type.Repetition.OPTIONAL;
+import static org.apache.parquet.schema.Type.Repetition.REPEATED;
+import static org.apache.parquet.schema.Type.Repetition.REQUIRED;
+import static org.apache.parquet.schema.Types.primitive;
 
 /**
  * Visitor Class for converting a thrift definition to parquet message type.
@@ -55,203 +73,266 @@
  *
  * @author Tianshuo Deng
  */
-public class ThriftSchemaConvertVisitor implements ThriftType.TypeVisitor {
+public class ThriftSchemaConvertVisitor implements ThriftType.TypeVisitor<ConvertedField, ThriftSchemaConvertVisitor.State> {
   private final FieldProjectionFilter fieldProjectionFilter;
-  private final FieldsPath currentFieldPath = new FieldsPath();
+  private final boolean doProjection;
+
+  private ThriftSchemaConvertVisitor(FieldProjectionFilter fieldProjectionFilter, boolean doProjection) {
+    this.fieldProjectionFilter = checkNotNull(fieldProjectionFilter, "fieldProjectionFilter");
+    this.doProjection = doProjection;
+  }
 
-  private Type currentType;
-  private Type.Repetition currentRepetition = Type.Repetition.REPEATED; // MessageType is repeated GroupType
-  private String currentName = "ParquetSchema";
+  public static MessageType convert(StructType struct, FieldProjectionFilter filter) {
+    State state = new State(new FieldsPath(), REPEATED, "ParquetSchema");
 
-  public ThriftSchemaConvertVisitor(FieldProjectionFilter fieldProjectionFilter) {
-    this.fieldProjectionFilter = Preconditions.checkNotNull(fieldProjectionFilter, "fieldProjectionFilter");
+    ConvertedField converted = struct.accept(new ThriftSchemaConvertVisitor(filter, true), state);
+
+    if (!converted.isKeep()) {
+      throw new ThriftProjectionException("No columns have been selected");
+    }
+
+    return new MessageType(state.name, converted.asKeep().getType().asGroupType().getFields());
   }
 
   @Override
-  public void visit(ThriftType.MapType mapType) {
-    final ThriftField mapKeyField = mapType.getKey();
-    final ThriftField mapValueField = mapType.getValue();
-
-    //save env for map
-    String mapName = currentName;
-    Type.Repetition mapRepetition = currentRepetition;
-
-    //=========handle key
-    currentFieldPath.push(mapKeyField);
-    currentName = "key";
-    currentRepetition = REQUIRED;
-    mapKeyField.getType().accept(this);
-    Type keyType = currentType;//currentType is the already converted type
-    currentFieldPath.pop();
-
-    //=========handle value
-    currentFieldPath.push(mapValueField);
-    currentName = "value";
-    currentRepetition = OPTIONAL;
-    mapValueField.getType().accept(this);
-    Type valueType = currentType;
-    currentFieldPath.pop();
-
-    if (keyType == null && valueType == null) {
-      currentType = null;
-      return;
+  public ConvertedField visit(MapType mapType, State state) {
+    ThriftField keyField = mapType.getKey();
+    ThriftField valueField = mapType.getValue();
+
+    State keyState = new State(state.path.push(keyField), REQUIRED, "key");
+
+    // TODO: This is a bug! this should be REQUIRED but changing this will
+    // break the the schema compatibility check against old data
+    // Thrift does not support null / missing map values.
+    State valueState = new State(state.path.push(valueField), OPTIONAL, "value");
+
+    ConvertedField convertedKey = keyField.getType().accept(this, keyState);
+    ConvertedField convertedValue = valueField.getType().accept(this, valueState);
+
+    if (!convertedKey.isKeep()) {
+
+      if (convertedValue.isKeep()) {
+        throw new ThriftProjectionException(
+            "Cannot select only the values of a map, you must keep the keys as well: " + state.path);
+      }
+
+      // neither key nor value was requested
+      return new Drop(state.path);
     }
 
-    if (keyType == null && valueType != null)
-      throw new ThriftProjectionException("key of map is not specified in projection: " + currentFieldPath);
+    // we are keeping the key, but we do not allow partial projections on keys
+    // as that doesn't make sense when assembling back into a map.
+    // NOTE: doProjections prevents us from infinite recursion here.
+    if (doProjection) {
+      ConvertedField fullConvKey = keyField
+          .getType()
+          .accept(new ThriftSchemaConvertVisitor(FieldProjectionFilter.ALL_COLUMNS, false), keyState);
+
+      if (!fullConvKey.asKeep().getType().equals(convertedKey.asKeep().getType())) {
+        throw new ThriftProjectionException("Cannot select only a subset of the fields in a map key, " +
+            "for path " + state.path);
+      }
 
-    //restore Env
-    currentName = mapName;
-    currentRepetition = mapRepetition;
-    currentType = mapType(currentRepetition, currentName,
-            keyType,
-            valueType);
-  }
+    }
 
-  @Override
-  public void visit(ThriftType.SetType setType) {
-    final ThriftField setElemField = setType.getValues();
-    String setName = currentName;
-    Type.Repetition setRepetition = currentRepetition;
-    currentName = currentName + "_tuple";
-    currentRepetition = REPEATED;
-    setElemField.getType().accept(this);
-    //after conversion, currentType is the nested type
-    if (currentType != null) {
-      currentType = listType(setRepetition, setName, currentType);
+    // now, are we keeping the value?
+
+    if (convertedValue.isKeep()) {
+      // keep both key and value
+
+      Type mapField = mapType(
+          state.repetition,
+          state.name,
+          convertedKey.asKeep().getType(),
+          convertedValue.asKeep().getType());
+
+      return new Keep(state.path, mapField);
     }
+
+    // keep only the key, not the value
+
+    ConvertedField sentinelValue =
+        valueField.getType().accept(new ThriftSchemaConvertVisitor(new KeepOnlyFirstPrimitiveFilter(), true), valueState);
+
+    Type mapField = mapType(
+        state.repetition,
+        state.name,
+        convertedKey.asKeep().getType(),
+        sentinelValue.asKeep().getType()); // signals to mapType method to project the value
+
+    return new Keep(state.path, mapField);
   }
 
-  @Override
-  public void visit(ThriftType.ListType listType) {
-    final ThriftField setElemField = listType.getValues();
-    String listName = currentName;
-    Type.Repetition listRepetition = currentRepetition;
-    currentName = currentName + "_tuple";
-    currentRepetition = REPEATED;
-    setElemField.getType().accept(this);
-    //after conversion, currentType is the nested type
-    if (currentType != null) {
-      currentType = listType(listRepetition, listName, currentType);
+  private ConvertedField visitListLike(ThriftField listLike, State state, boolean isSet) {
+    State childState = new State(state.path, REPEATED, state.name + "_tuple");
+
+    ConvertedField converted = listLike.getType().accept(this, childState);
+
+    if (converted.isKeep()) {
+      // doProjection prevents an infinite recursion here
+      if (isSet && doProjection) {
+        ConvertedField fullConv = listLike
+            .getType()
+            .accept(new ThriftSchemaConvertVisitor(FieldProjectionFilter.ALL_COLUMNS, false), childState);
+        if (!converted.asKeep().getType().equals(fullConv.asKeep().getType())) {
+          throw new ThriftProjectionException("Cannot select only a subset of the fields in a set, " +
+              "for path " + state.path);
+        }
+      }
+
+      return new Keep(state.path, listType(state.repetition, state.name, converted.asKeep().getType()));
     }
+
+    return new Drop(state.path);
   }
 
-  public MessageType getConvertedMessageType() {
-    // the root should be a GroupType
-    if (currentType == null)
-      return new MessageType(currentName, new ArrayList<Type>());
+  @Override
+  public ConvertedField visit(SetType setType, State state) {
+    return visitListLike(setType.getValues(), state, true);
+  }
 
-    GroupType rootType = currentType.asGroupType();
-    return new MessageType(currentName, rootType.getFields());
+  @Override
+  public ConvertedField visit(ListType listType, State state) {
+    return visitListLike(listType.getValues(), state, false);
   }
 
   @Override
-  public void visit(ThriftType.StructType structType) {
-    List<ThriftField> fields = structType.getChildren();
+  public ConvertedField visit(StructType structType, State state) {
 
-    String oldName = currentName;
-    Type.Repetition oldRepetition = currentRepetition;
+    // special care is taken when converting unions,
+    // because we are actually both converting + projecting in
+    // one pass, and unions need special handling when projecting.
+    final boolean isUnion = isUnion(structType.getStructOrUnionType());
 
-    List<Type> types = getFieldsTypes(fields);
+    boolean hasSentinelUnionColumns = false;
+    boolean hasNonSentinelUnionColumns = false;
 
-    currentName = oldName;
-    currentRepetition = oldRepetition;
-    if (types.size() > 0) {
-      currentType = new GroupType(currentRepetition, currentName, types);
-    } else {
-      currentType = null;
-    }
-  }
+    List<Type> convertedChildren = new ArrayList<Type>();
+
+    for (ThriftField child : structType.getChildren()) {
+
+      State childState = new State(state.path.push(child), getRepetition(child), child.getName());
+
+      ConvertedField converted = child.getType().accept(this, childState);
 
-  private List<Type> getFieldsTypes(List<ThriftField> fields) {
-    List<Type> types = new ArrayList<Type>();
-    for (ThriftField field : fields) {
-      currentRepetition = getRepetition(field);
-      currentName = field.getName();
-      currentFieldPath.push(field);
-      field.getType().accept(this);
-      if (currentType != null) {
-        // currentType is converted with the currentName(fieldName)
-        types.add(currentType.withId(field.getFieldId()));
+      if (isUnion && !converted.isKeep()) {
+        // user is not keeping this "kind" of union, but we still need
+        // to keep at least one of the primitives of this union around.
+        // in order to know what "kind" of union each record is.
+        // TODO: in the future, we should just filter these records out instead
+
+        // re-do the recursion, with a new projection filter that keeps only
+        // the first primitive it encounters
+        ConvertedField firstPrimitive = child.getType().accept(
+            new ThriftSchemaConvertVisitor(new KeepOnlyFirstPrimitiveFilter(), true), childState);
+
+        convertedChildren.add(firstPrimitive.asKeep().getType().withId(child.getFieldId()));
+        hasSentinelUnionColumns = true;
       }
-      currentFieldPath.pop();
+
+      if (converted.isSentinelUnion()) {
+        // child field is a sentinel union that we should drop if possible
+        if (childState.repetition == REQUIRED) {
+          // but this field is required, so we may still need it
+          convertedChildren.add(converted.asSentinelUnion().getType().withId(child.getFieldId()));
+          hasSentinelUnionColumns = true;
+        }
+      } else if (converted.isKeep()) {
+        // user has selected this column, so we keep it.
+        convertedChildren.add(converted.asKeep().getType().withId(child.getFieldId()));
+        hasNonSentinelUnionColumns = true;
+      }
+
+    }
+
+    if (!hasNonSentinelUnionColumns && hasSentinelUnionColumns) {
+      // this is a union, and user has not requested any of the children
+      // of this union. We should drop this union, if possible, but
+      // we may not be able to, so tag this as a sentinel.
+      return new SentinelUnion(state.path, new GroupType(state.repetition, state.name, convertedChildren));
     }
-    return types;
-  }
 
-  private boolean isCurrentlyMatchedFilter(){
-     if(!fieldProjectionFilter.keep(currentFieldPath)){
-       currentType = null;
-       return false;
-     }
-    return true;
+    if (hasNonSentinelUnionColumns) {
+      // user requested some of the fields of this struct, so we keep the struct
+      return new Keep(state.path, new GroupType(state.repetition, state.name, convertedChildren));
+    } else {
+      // user requested none of the fields of this struct, so we drop it
+      return new Drop(state.path);
+    }
   }
 
-  private void primitiveType(PrimitiveTypeName type) {
-    primitiveType(type, null);
+  private ConvertedField visitPrimitiveType(PrimitiveTypeName type, State state) {
+    return visitPrimitiveType(type, null, state);
   }
 
-  private void primitiveType(PrimitiveTypeName type, OriginalType orig) {
-    if (isCurrentlyMatchedFilter()) {
-      PrimitiveBuilder<PrimitiveType> b = primitive(type, currentRepetition);
-      if (orig != null) {
-        b = b.as(orig);
-      }
-      currentType = b.named(currentName);
+  private ConvertedField visitPrimitiveType(PrimitiveTypeName type, OriginalType orig, State state) {
+    PrimitiveBuilder<PrimitiveType> b = primitive(type, state.repetition);
+
+    if (orig != null) {
+      b = b.as(orig);
+    }
+
+    if (fieldProjectionFilter.keep(state.path)) {
+      return new Keep(state.path, b.named(state.name));
+    } else {
+      return new Drop(state.path);
     }
   }
 
   @Override
-  public void visit(ThriftType.EnumType enumType) {
-    primitiveType(BINARY, ENUM);
+  public ConvertedField visit(EnumType enumType, State state) {
+    return visitPrimitiveType(BINARY, ENUM, state);
   }
 
   @Override
-  public void visit(ThriftType.BoolType boolType) {
-    primitiveType(BOOLEAN);
+  public ConvertedField visit(BoolType boolType, State state) {
+    return visitPrimitiveType(BOOLEAN, state);
   }
 
   @Override
-  public void visit(ThriftType.ByteType byteType) {
-    primitiveType(INT32);
+  public ConvertedField visit(ByteType byteType, State state) {
+    return visitPrimitiveType(INT32, state);
   }
 
   @Override
-  public void visit(ThriftType.DoubleType doubleType) {
-    primitiveType(DOUBLE);
+  public ConvertedField visit(DoubleType doubleType, State state) {
+    return visitPrimitiveType(DOUBLE, state);
   }
 
   @Override
-  public void visit(ThriftType.I16Type i16Type) {
-    primitiveType(INT32);
+  public ConvertedField visit(I16Type i16Type, State state) {
+    return visitPrimitiveType(INT32, state);
   }
 
   @Override
-  public void visit(ThriftType.I32Type i32Type) {
-    primitiveType(INT32);
+  public ConvertedField visit(I32Type i32Type, State state) {
+    return visitPrimitiveType(INT32, state);
   }
 
   @Override
-  public void visit(ThriftType.I64Type i64Type) {
-    primitiveType(INT64);
+  public ConvertedField visit(I64Type i64Type, State state) {
+    return visitPrimitiveType(INT64, state);
   }
 
   @Override
-  public void visit(ThriftType.StringType stringType) {
-    primitiveType(BINARY, UTF8);
+  public ConvertedField visit(StringType stringType, State state) {
+    return visitPrimitiveType(BINARY, UTF8, state);
   }
 
-  /**
-   * by default we can make everything optional
-   *
-   * @param thriftField
-   * @return
-   */
-  private Type.Repetition getRepetition(ThriftField thriftField) {
-    if (thriftField == null) {
-      return OPTIONAL;
+  private static boolean isUnion(StructOrUnionType s) {
+    switch (s) {
+      case STRUCT:
+        return false;
+      case UNION:
+        return true;
+      case UNKNOWN:
+        throw new ShouldNeverHappenException("Encountered UNKNOWN StructOrUnionType");
+      default:
+        throw new ShouldNeverHappenException("Unrecognized type: " + s);
     }
+  }
 
+  private Type.Repetition getRepetition(ThriftField thriftField) {
     switch (thriftField.getRequirement()) {
       case REQUIRED:
         return REQUIRED;
@@ -263,4 +344,20 @@ private Type.Repetition getRepetition(ThriftField thriftField) {
         throw new IllegalArgumentException("unknown requirement type: " + thriftField.getRequirement());
     }
   }
+
+  /**
+   * The state passed through the recursion as we traverse a thrift schema.
+   */
+  public static final class State {
+    public final FieldsPath path; // current field path
+    public final Type.Repetition repetition; // current repetition (no relation to parent's repetition)
+    public final String name; // name of the field located at path
+
+    public State(FieldsPath path, Repetition repetition, String name) {
+      this.path = path;
+      this.repetition = repetition;
+      this.name = name;
+    }
+  }
+
 }
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/ThriftSchemaConverter.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/ThriftSchemaConverter.java
index 112913ecea..4ce1e910a6 100644
--- a/parquet-thrift/src/main/java/org/apache/parquet/thrift/ThriftSchemaConverter.java
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/ThriftSchemaConverter.java
@@ -56,12 +56,10 @@ public MessageType convert(Class<? extends TBase<?, ?>> thriftClass) {
     return convert(toStructType(thriftClass));
   }
 
-  public MessageType convert(StructType thriftClass) {
-    ThriftSchemaConvertVisitor visitor = new ThriftSchemaConvertVisitor(fieldProjectionFilter);
-    thriftClass.accept(visitor);
+  public MessageType convert(StructType struct) {
+    MessageType messageType = ThriftSchemaConvertVisitor.convert(struct, fieldProjectionFilter);
     fieldProjectionFilter.assertNoUnmatchedPatterns();
-    MessageType convertedMessageType = visitor.getConvertedMessageType();
-    return convertedMessageType;
+    return messageType;
   }
 
   public static <T extends TBase<?,?>> StructOrUnionType structOrUnionType(Class<T> klass) {
@@ -76,8 +74,7 @@ public static ThriftType.StructType toStructType(Class<? extends TBase<?, ?>> th
   private static StructType toStructType(TStructDescriptor struct) {
     List<Field> fields = struct.getFields();
     List<ThriftField> children = new ArrayList<ThriftField>(fields.size());
-    for (int i = 0; i < fields.size(); i++) {
-      Field field = fields.get(i);
+    for (Field field : fields) {
       Requirement req =
           field.getFieldMetaData() == null ?
               Requirement.OPTIONAL :
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/FieldProjectionFilter.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/FieldProjectionFilter.java
index 5498c8e02c..53b8b593fc 100644
--- a/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/FieldProjectionFilter.java
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/FieldProjectionFilter.java
@@ -24,12 +24,13 @@
  * be included when reading thrift data. It is used to implement projection push down.
  *
  * See {@link StrictFieldProjectionFilter} and
- * {@link parquet.thrift.projection.deprecated.DeprecatedFieldProjectionFilter}
+ * {@link org.apache.parquet.thrift.projection.deprecated.DeprecatedFieldProjectionFilter}
  */
 public interface FieldProjectionFilter {
 
   /**
    * Decide whether to keep the field (column) represented by path.
+   * This path always represents a primitive (leaf node) path.
    *
    * @param path the path to the field (column)
    * @return true to keep, false to discard (project out)
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/FieldsPath.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/FieldsPath.java
index aa5ebafbc7..239384ddad 100644
--- a/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/FieldsPath.java
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/FieldsPath.java
@@ -24,23 +24,25 @@
 import org.apache.parquet.thrift.struct.ThriftType;
 
 /**
- * Represents a column path as a sequence of fields.
+ * Represents an immutable column path as a sequence of fields.
  *
  * @author Tianshuo Deng
  */
 public class FieldsPath {
-  private final ArrayList<ThriftField> fields = new ArrayList<ThriftField>();
+  private final ArrayList<ThriftField> fields;
 
-  public void push(ThriftField f) {
-    this.fields.add(f);
+  public FieldsPath() {
+    this(new ArrayList<ThriftField>());
   }
 
-  public ThriftField pop() {
-    return this.fields.remove(fields.size() - 1);
+  private FieldsPath(ArrayList<ThriftField> fields) {
+    this.fields = fields;
   }
 
-  public ArrayList<ThriftField> getFields() {
-    return fields;
+  public FieldsPath push(ThriftField f) {
+    ArrayList<ThriftField> copy = new ArrayList<ThriftField>(fields);
+    copy.add(f);
+    return new FieldsPath(copy);
   }
 
   public String toDelimitedString(String delim) {
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/amend/DefaultEventsVisitor.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/amend/DefaultEventsVisitor.java
index aeaf434467..ec63d85183 100644
--- a/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/amend/DefaultEventsVisitor.java
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/amend/DefaultEventsVisitor.java
@@ -34,10 +34,10 @@
 /**
  * Create a dummy events for all required fields according to thrift definition
  */
-class DefaultEventsVisitor implements ThriftType.TypeVisitor {
+class DefaultEventsVisitor implements ThriftType.TypeVisitor<Void, Void> {
   List<ParquetProtocol> dummyEvents= new ArrayList<ParquetProtocol>();
   @Override
-  public void visit(ThriftType.MapType mapType) {
+  public Void visit(ThriftType.MapType mapType, Void v) {
      dummyEvents.add(new ParquetProtocol("readMapBegin()") {
        @Override
        public TMap readMapBegin() throws TException {
@@ -50,11 +50,11 @@ public TMap readMapBegin() throws TException {
       public void readMapEnd() throws TException {
       }
     });
-
+    return null;
   }
 
   @Override
-  public void visit(final ThriftType.SetType setType) {
+  public Void visit(final ThriftType.SetType setType, Void v) {
     dummyEvents.add(new ParquetProtocol("readSetBegin()") {
       @Override
       public TSet readSetBegin() throws TException {
@@ -67,11 +67,13 @@ public TSet readSetBegin() throws TException {
       public void readSetEnd() throws TException {
       }
     });
+
+    return null;
   }
 
 
   @Override
-  public void visit(final ThriftType.ListType listType) {
+  public Void visit(final ThriftType.ListType listType, Void v) {
     dummyEvents.add(new ParquetProtocol("readListBegin()") {
       @Override
       public TList readListBegin() throws TException {
@@ -84,96 +86,107 @@ public TList readListBegin() throws TException {
       public void readListEnd() throws TException {
       }
     });
+
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.StructType structType) {
+  public Void visit(ThriftType.StructType structType, Void v) {
     dummyEvents.add(new StructBeginProtocol("struct"));
     List<ThriftField> children = structType.getChildren();
     for (ThriftField child : children) {
       dummyEvents.add(new ReadFieldBeginProtocol(child));
-      child.getType().accept(this); //currently will create all the attributes in struct, it's safer
+      child.getType().accept(this, null); //currently will create all the attributes in struct, it's safer
       dummyEvents.add(DefaultProtocolEventsGenerator.READ_FIELD_END);
     }
     dummyEvents.add(DefaultProtocolEventsGenerator.READ_FIELD_STOP);
     dummyEvents.add(DefaultProtocolEventsGenerator.READ_STRUCT_END);
 
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.EnumType enumType) {
+  public Void visit(ThriftType.EnumType enumType, Void v) {
     dummyEvents.add(new ParquetProtocol("readI32() enum") {
       @Override
       public int readI32() throws TException {
         return 0;
       }
     });
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.BoolType boolType) {
+  public Void visit(ThriftType.BoolType boolType, Void v) {
     dummyEvents.add(new ParquetProtocol("readBool()") {
       @Override
       public boolean readBool() throws TException {
         return false;
       }
     });
+    return null;
   }
 
 
   @Override
-  public void visit(ThriftType.ByteType byteType) {
+  public Void visit(ThriftType.ByteType byteType, Void v) {
     dummyEvents.add(new ParquetProtocol("readByte() int") {
       @Override
       public byte readByte() throws TException {
         return (byte) 0;
       }
     });
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.DoubleType doubleType) {
+  public Void visit(ThriftType.DoubleType doubleType, Void v) {
     dummyEvents.add(new ParquetProtocol("readDouble()") {
       @Override
       public double readDouble() throws TException {
         return 0.0;
       }
     });
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.I16Type i16Type) {
+  public Void visit(ThriftType.I16Type i16Type, Void v) {
     dummyEvents.add(new ParquetProtocol("readI16()") {
       @Override
       public short readI16() throws TException {
         return (short) 0;
       }
     });
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.I32Type i32Type) {
+  public Void visit(ThriftType.I32Type i32Type, Void v) {
     dummyEvents.add(new ParquetProtocol("readI32()") {
       @Override
       public int readI32() throws TException {
         return 0;
       }
     });
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.I64Type i64Type) {
+  public Void visit(ThriftType.I64Type i64Type, Void v) {
     dummyEvents.add(new ParquetProtocol("readI64()") {
       @Override
       public long readI64() throws TException {
         return 0;
       }
     });
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.StringType stringType) {
+  public Void visit(ThriftType.StringType stringType, Void v) {
     dummyEvents.add(new StringProtocol(""));
+    return null;
   }
 
   public List<ParquetProtocol> getEvents() {
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/amend/DefaultProtocolEventsGenerator.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/amend/DefaultProtocolEventsGenerator.java
index 99d0171923..6d22e7f620 100644
--- a/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/amend/DefaultProtocolEventsGenerator.java
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/projection/amend/DefaultProtocolEventsGenerator.java
@@ -59,7 +59,7 @@ public List<TProtocol> createProtocolEventsForField(ThriftField missingField) {
     createdEvents.add(fieldBegin);
 
     DefaultEventsVisitor dummyCreatorvisitor = new DefaultEventsVisitor();
-    missingField.getType().accept(dummyCreatorvisitor);
+    missingField.getType().accept(dummyCreatorvisitor, null);
     createdEvents.addAll(dummyCreatorvisitor.getEvents());
     createdEvents.add(READ_FIELD_END);
     return createdEvents;
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/struct/CompatibilityChecker.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/struct/CompatibilityChecker.java
index 04a106a551..95a6d276b0 100644
--- a/parquet-thrift/src/main/java/org/apache/parquet/thrift/struct/CompatibilityChecker.java
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/struct/CompatibilityChecker.java
@@ -22,6 +22,15 @@
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.parquet.thrift.struct.ThriftType.BoolType;
+import org.apache.parquet.thrift.struct.ThriftType.ByteType;
+import org.apache.parquet.thrift.struct.ThriftType.DoubleType;
+import org.apache.parquet.thrift.struct.ThriftType.EnumType;
+import org.apache.parquet.thrift.struct.ThriftType.I16Type;
+import org.apache.parquet.thrift.struct.ThriftType.I32Type;
+import org.apache.parquet.thrift.struct.ThriftType.I64Type;
+import org.apache.parquet.thrift.struct.ThriftType.StringType;
+
 /**
  * A checker for thrift struct, returns compatibility report based on following rules:
  * 1. Should not add new REQUIRED field in new thrift struct. Adding optional field is OK
@@ -35,7 +44,7 @@ public class CompatibilityChecker {
 
   public CompatibilityReport checkCompatibility(ThriftType.StructType oldStruct, ThriftType.StructType newStruct) {
     CompatibleCheckerVisitor visitor = new CompatibleCheckerVisitor(oldStruct);
-    newStruct.accept(visitor);
+    newStruct.accept(visitor, null);
     return visitor.getReport();
   }
 
@@ -59,7 +68,7 @@ public List<String> getMessages() {
   }
 }
 
-class CompatibleCheckerVisitor implements ThriftType.TypeVisitor {
+class CompatibleCheckerVisitor implements ThriftType.TypeVisitor<Void, Void> {
   ThriftType oldType;
   CompatibilityReport report = new CompatibilityReport();
 
@@ -72,7 +81,7 @@ public CompatibilityReport getReport() {
   }
 
   @Override
-  public void visit(ThriftType.MapType mapType) {
+  public Void visit(ThriftType.MapType mapType, Void v) {
     ThriftType.MapType currentOldType = ((ThriftType.MapType) oldType);
     ThriftField oldKeyField = currentOldType.getKey();
     ThriftField newKeyField = mapType.getKey();
@@ -84,24 +93,27 @@ public void visit(ThriftType.MapType mapType) {
     checkField(oldValueField, newValueField);
 
     oldType = currentOldType;
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.SetType setType) {
+  public Void visit(ThriftType.SetType setType, Void v) {
     ThriftType.SetType currentOldType = ((ThriftType.SetType) oldType);
     ThriftField oldField = currentOldType.getValues();
     ThriftField newField = setType.getValues();
     checkField(oldField, newField);
     oldType = currentOldType;
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.ListType listType) {
+  public Void visit(ThriftType.ListType listType, Void v) {
     ThriftType.ListType currentOldType = ((ThriftType.ListType) oldType);
     ThriftField oldField = currentOldType.getValues();
     ThriftField newField = listType.getValues();
     checkField(oldField, newField);
     oldType = currentOldType;
+    return null;
   }
 
   public void fail(String message) {
@@ -126,7 +138,7 @@ private void checkField(ThriftField oldField, ThriftField newField) {
     }
 
     oldType = oldField.getType();
-    newField.getType().accept(this);
+    newField.getType().accept(this, null);
   }
 
   private boolean firstIsMoreRestirctive(ThriftField.Requirement firstReq, ThriftField.Requirement secReq) {
@@ -139,7 +151,7 @@ private boolean firstIsMoreRestirctive(ThriftField.Requirement firstReq, ThriftF
   }
 
   @Override
-  public void visit(ThriftType.StructType newStruct) {
+  public Void visit(ThriftType.StructType newStruct, Void v) {
     ThriftType.StructType currentOldType = ((ThriftType.StructType) oldType);
     short oldMaxId = 0;
     for (ThriftField oldField : currentOldType.getChildren()) {
@@ -150,7 +162,7 @@ public void visit(ThriftType.StructType newStruct) {
       ThriftField newField = newStruct.getChildById(fieldId);
       if (newField == null) {
         fail("can not find index in new Struct: " + fieldId +" in " + newStruct);
-        return;
+        return null;
       }
       checkField(oldField, newField);
     }
@@ -164,57 +176,58 @@ public void visit(ThriftType.StructType newStruct) {
       short newFieldId = newField.getFieldId();
       if (newFieldId > oldMaxId) {
         fail("new required field " + newField.getName() + " is added");
-        return;
+        return null;
       }
       if (newFieldId < oldMaxId && currentOldType.getChildById(newFieldId) == null) {
         fail("new required field " + newField.getName() + " is added");
-        return;
+        return null;
       }
 
     }
 
     //restore
     oldType = currentOldType;
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.EnumType enumType) {
-    return;
+  public Void visit(EnumType enumType, Void v) {
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.BoolType boolType) {
-    return;
+  public Void visit(BoolType boolType, Void v) {
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.ByteType byteType) {
-    return;
+  public Void visit(ByteType byteType, Void v) {
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.DoubleType doubleType) {
-    return;
+  public Void visit(DoubleType doubleType, Void v) {
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.I16Type i16Type) {
-    return;
+  public Void visit(I16Type i16Type, Void v) {
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.I32Type i32Type) {
-    return;
+  public Void visit(I32Type i32Type, Void v) {
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.I64Type i64Type) {
-    return;
+  public Void visit(I64Type i64Type, Void v) {
+    return null;
   }
 
   @Override
-  public void visit(ThriftType.StringType stringType) {
-    return;
+  public Void visit(StringType stringType, Void v) {
+    return null;
   }
 }
 
diff --git a/parquet-thrift/src/main/java/org/apache/parquet/thrift/struct/ThriftType.java b/parquet-thrift/src/main/java/org/apache/parquet/thrift/struct/ThriftType.java
index 2f0f597d34..92d12b43d7 100644
--- a/parquet-thrift/src/main/java/org/apache/parquet/thrift/struct/ThriftType.java
+++ b/parquet-thrift/src/main/java/org/apache/parquet/thrift/struct/ThriftType.java
@@ -98,75 +98,31 @@ public String toString() {
     return toJSON();
   }
 
-  public interface TypeVisitor {
+  public interface TypeVisitor<R, S> {
 
-    void visit(MapType mapType);
+    R visit(MapType mapType, S state);
 
-    void visit(SetType setType);
+    R visit(SetType setType, S state);
 
-    void visit(ListType listType);
+    R visit(ListType listType, S state);
 
-    void visit(StructType structType);
+    R visit(StructType structType, S state);
 
-    void visit(EnumType enumType);
+    R visit(EnumType enumType, S state);
 
-    void visit(BoolType boolType);
+    R visit(BoolType boolType, S state);
 
-    void visit(ByteType byteType);
+    R visit(ByteType byteType, S state);
 
-    void visit(DoubleType doubleType);
+    R visit(DoubleType doubleType, S state);
 
-    void visit(I16Type i16Type);
+    R visit(I16Type i16Type, S state);
 
-    void visit(I32Type i32Type);
+    R visit(I32Type i32Type, S state);
 
-    void visit(I64Type i64Type);
+    R visit(I64Type i64Type, S state);
 
-    void visit(StringType stringType);
-
-  }
-
-  public static abstract class ComplexTypeVisitor implements TypeVisitor {
-
-    @Override
-    final public void visit(EnumType enumType) {
-      throw new IllegalArgumentException("Expected complex type");
-    }
-
-    @Override
-    final public void visit(BoolType boolType) {
-      throw new IllegalArgumentException("Expected complex type");
-    }
-
-    @Override
-    final public void visit(ByteType byteType) {
-      throw new IllegalArgumentException("Expected complex type");
-    }
-
-    @Override
-    final public void visit(DoubleType doubleType) {
-      throw new IllegalArgumentException("Expected complex type");
-    }
-
-    @Override
-    final public void visit(I16Type i16Type) {
-      throw new IllegalArgumentException("Expected complex type");
-    }
-
-    @Override
-    final public void visit(I32Type i32Type) {
-      throw new IllegalArgumentException("Expected complex type");
-    }
-
-    @Override
-    final public void visit(I64Type i64Type) {
-      throw new IllegalArgumentException("Expected complex type");
-    }
-
-    @Override
-    final public void visit(StringType stringType) {
-      throw new IllegalArgumentException("Expected complex type");
-    }
+    R visit(StringType stringType, S state);
 
   }
 
@@ -233,8 +189,8 @@ public StructOrUnionType getStructOrUnionType() {
     }
 
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
 
     @Override
@@ -276,8 +232,8 @@ public ThriftField getValue() {
     }
 
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
 
     @Override
@@ -317,8 +273,8 @@ public ThriftField getValues() {
     }
 
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
 
     @Override
@@ -356,8 +312,8 @@ public ThriftField getValues() {
     }
 
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
 
     @Override
@@ -452,8 +408,8 @@ private void prepareEnumLookUp() {
     }
 
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
 
     @Override
@@ -484,8 +440,8 @@ public BoolType() {
       super(BOOL);
     }
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
   }
 
@@ -496,8 +452,8 @@ public ByteType() {
       super(BYTE);
     }
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
   }
 
@@ -508,8 +464,8 @@ public DoubleType() {
       super(DOUBLE);
     }
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
   }
 
@@ -520,8 +476,8 @@ public I16Type() {
       super(I16);
     }
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
   }
 
@@ -532,8 +488,8 @@ public I32Type() {
       super(I32);
     }
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
   }
 
@@ -544,9 +500,10 @@ public I64Type() {
       super(I64);
     }
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
+
   }
 
   public static class StringType extends ThriftType {
@@ -556,8 +513,8 @@ public StringType() {
       super(STRING);
     }
     @Override
-    public void accept(TypeVisitor visitor) {
-      visitor.visit(this);
+    public <R, S> R accept(TypeVisitor<R, S> visitor, S state) {
+      return visitor.visit(this, state);
     }
   }
 
@@ -568,7 +525,7 @@ private ThriftType(ThriftTypeID type) {
     this.type = type;
   }
 
-  public abstract void accept(TypeVisitor visitor);
+  public abstract <R, S> R accept(TypeVisitor<R, S> visitor, S state);
 
   @JsonIgnore
   public ThriftTypeID getType() {
diff --git a/parquet-thrift/src/test/java/org/apache/parquet/hadoop/thrift/TestParquetToThriftReadWriteAndProjection.java b/parquet-thrift/src/test/java/org/apache/parquet/hadoop/thrift/TestParquetToThriftReadWriteAndProjection.java
index bf9b2a3385..aa0b81d524 100644
--- a/parquet-thrift/src/test/java/org/apache/parquet/hadoop/thrift/TestParquetToThriftReadWriteAndProjection.java
+++ b/parquet-thrift/src/test/java/org/apache/parquet/hadoop/thrift/TestParquetToThriftReadWriteAndProjection.java
@@ -27,6 +27,11 @@
 import org.apache.hadoop.fs.Path;
 import org.apache.hadoop.io.BytesWritable;
 import org.apache.hadoop.mapreduce.*;
+import org.apache.parquet.thrift.test.compat.MapWithPrimMapValue;
+import org.apache.parquet.thrift.test.compat.MapWithStructMapValue;
+import org.apache.parquet.thrift.test.compat.MapWithStructValue;
+import org.apache.parquet.thrift.test.compat.StructV3;
+import org.apache.parquet.thrift.test.compat.StructV4WithExtracStructField;
 import org.apache.thrift.TBase;
 import org.apache.thrift.protocol.TCompactProtocol;
 import org.apache.thrift.protocol.TProtocol;
@@ -156,6 +161,141 @@ public void testPullInRequiredMaps() throws Exception {
     shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, RequiredMapFixture.class);
   }
 
+  @Test
+  public void testDropMapValuePrimitive() throws Exception {
+    String filter = "mavalue/key";
+
+    Map<String, String> mapValue = new HashMap<String, String>();
+    mapValue.put("a", "1");
+    mapValue.put("b", "2");
+    RequiredMapFixture toWrite = new RequiredMapFixture(mapValue);
+    toWrite.setName("testName");
+
+    // for now we expect no value projection to happen
+    // because a sentinel value is selected from the value
+    Map<String, String> readValue = new HashMap<String, String>();
+    readValue.put("a", "1");
+    readValue.put("b", "2");
+
+    RequiredMapFixture toRead = new RequiredMapFixture(readValue);
+
+    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, RequiredMapFixture.class);
+  }
+
+  private StructV4WithExtracStructField makeStructV4WithExtracStructField(String id) {
+    StructV4WithExtracStructField sv4 = new StructV4WithExtracStructField();
+    StructV3 sv3 = new StructV3();
+    sv3.setAge("age " + id);
+    sv3.setGender("gender" + id);
+    sv3.setName("inner name " + id);
+    sv4.setAge("outer age " + id);
+    sv4.setAddedStruct(sv3);
+    sv4.setGender("outer gender " + id);
+    sv4.setName("outer name " + id);
+    return sv4;
+  }
+
+
+  @Test
+  public void testDropMapValueStruct() throws Exception {
+    String filter = "reqMap/key";
+
+    Map<String, StructV4WithExtracStructField> mapValue = new HashMap<String, StructV4WithExtracStructField>();
+
+    StructV4WithExtracStructField v1 = makeStructV4WithExtracStructField("1");
+    StructV4WithExtracStructField v2 = makeStructV4WithExtracStructField("2");
+
+    mapValue.put("key 1", v1);
+    mapValue.put("key 2", v2);
+    MapWithStructValue toWrite = new MapWithStructValue(mapValue);
+
+    // for now we expect a sentinel column to be kept
+    HashMap<String, StructV4WithExtracStructField> readValue = new HashMap<String, StructV4WithExtracStructField>();
+    readValue.put("key 1", new StructV4WithExtracStructField("outer name 1"));
+    readValue.put("key 2", new StructV4WithExtracStructField("outer name 2"));
+
+    MapWithStructValue toRead = new MapWithStructValue(readValue);
+
+    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, MapWithStructValue.class);
+  }
+
+  @Test
+  public void testDropMapValueNestedPrim() throws Exception {
+    String filter = "reqMap/key";
+
+    Map<String, Map<String, String>> mapValue =
+        new HashMap<String, Map<String, String>>();
+
+    Map<String, String> innerValue1 = new HashMap<String, String>();
+    innerValue1.put("inner key (1, 1)", "inner (1, 1)");
+    innerValue1.put("inner key (1, 2)", "inner (1, 2)");
+
+    Map<String, String> innerValue2 = new HashMap<String, String>();
+    innerValue2.put("inner key (2, 1)", "inner (2, 1)");
+    innerValue2.put("inner key (2, 2)", "inner (2, 2)");
+
+    mapValue.put("outer key 1", innerValue1);
+    mapValue.put("outer key 2", innerValue2);
+
+    MapWithPrimMapValue toWrite = new MapWithPrimMapValue(mapValue);
+
+    Map<String, Map<String, String>> expected = new HashMap<String, Map<String, String>>();
+
+    Map<String, String> expectedInnerValue1 = new HashMap<String, String>();
+    expectedInnerValue1.put("inner key (1, 1)", "inner (1, 1)");
+    expectedInnerValue1.put("inner key (1, 2)", "inner (1, 2)");
+
+    Map<String, String> expectedInnerValue2 = new HashMap<String, String>();
+    expectedInnerValue2.put("inner key (2, 1)", "inner (2, 1)");
+    expectedInnerValue2.put("inner key (2, 2)", "inner (2, 2)");
+
+    expected.put("outer key 1", expectedInnerValue1);
+    expected.put("outer key 2", expectedInnerValue2);
+
+    MapWithPrimMapValue toRead = new MapWithPrimMapValue(expected);
+
+    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, MapWithPrimMapValue.class);
+  }
+
+
+  @Test
+  public void testDropMapValueNestedStruct() throws Exception {
+    String filter = "reqMap/key";
+
+    Map<String, Map<String, StructV4WithExtracStructField>> mapValue =
+        new HashMap<String, Map<String, StructV4WithExtracStructField>>();
+
+    Map<String, StructV4WithExtracStructField> innerValue1 = new HashMap<String, StructV4WithExtracStructField>();
+    innerValue1.put("inner key (1, 1)", makeStructV4WithExtracStructField("inner (1, 1)"));
+    innerValue1.put("inner key (1, 2)", makeStructV4WithExtracStructField("inner (1, 2)"));
+
+    Map<String, StructV4WithExtracStructField> innerValue2 = new HashMap<String, StructV4WithExtracStructField>();
+    innerValue2.put("inner key (2, 1)", makeStructV4WithExtracStructField("inner (2, 1)"));
+    innerValue2.put("inner key (2, 2)", makeStructV4WithExtracStructField("inner (2, 2)"));
+
+    mapValue.put("outer key 1", innerValue1);
+    mapValue.put("outer key 2", innerValue2);
+
+    MapWithStructMapValue toWrite = new MapWithStructMapValue(mapValue);
+
+    Map<String, Map<String, StructV4WithExtracStructField>> expected = new HashMap<String, Map<String, StructV4WithExtracStructField>>();
+
+    Map<String, StructV4WithExtracStructField> expectedInnerValue1 = new HashMap<String, StructV4WithExtracStructField>();
+    expectedInnerValue1.put("inner key (1, 1)", new StructV4WithExtracStructField("outer name inner (1, 1)"));
+    expectedInnerValue1.put("inner key (1, 2)", new StructV4WithExtracStructField("outer name inner (1, 2)"));
+
+    Map<String, StructV4WithExtracStructField> expectedInnerValue2 = new HashMap<String, StructV4WithExtracStructField>();
+    expectedInnerValue2.put("inner key (2, 1)", new StructV4WithExtracStructField("outer name inner (2, 1)"));
+    expectedInnerValue2.put("inner key (2, 2)", new StructV4WithExtracStructField("outer name inner (2, 2)"));
+
+    expected.put("outer key 1", expectedInnerValue1);
+    expected.put("outer key 2", expectedInnerValue2);
+
+    MapWithStructMapValue toRead = new MapWithStructMapValue(expected);
+
+    shouldDoProjectionWithThriftColumnFilter(filter, toWrite, toRead, MapWithStructMapValue.class);
+  }
+
   @Test
   public void testPullInRequiredLists() throws Exception {
     String filter = "info";
diff --git a/parquet-thrift/src/test/java/org/apache/parquet/thrift/TestThriftSchemaConverter.java b/parquet-thrift/src/test/java/org/apache/parquet/thrift/TestThriftSchemaConverter.java
index 97e1a12f50..cd5fc47eb4 100644
--- a/parquet-thrift/src/test/java/org/apache/parquet/thrift/TestThriftSchemaConverter.java
+++ b/parquet-thrift/src/test/java/org/apache/parquet/thrift/TestThriftSchemaConverter.java
@@ -18,25 +18,26 @@
  */
 package org.apache.parquet.thrift;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.apache.parquet.schema.MessageTypeParser.parseMessageType;
-
-import org.apache.thrift.TBase;
-import org.junit.Test;
-
 import org.apache.parquet.schema.MessageType;
 import org.apache.parquet.schema.MessageTypeParser;
 import org.apache.parquet.thrift.projection.StrictFieldProjectionFilter;
-import org.apache.parquet.thrift.projection.deprecated.DeprecatedFieldProjectionFilter;
 import org.apache.parquet.thrift.projection.ThriftProjectionException;
+import org.apache.parquet.thrift.projection.deprecated.DeprecatedFieldProjectionFilter;
 import org.apache.parquet.thrift.struct.ThriftType;
 import org.apache.parquet.thrift.struct.ThriftType.StructType;
+import org.apache.parquet.thrift.test.compat.MapStructV2;
+import org.apache.parquet.thrift.test.compat.SetStructV2;
+import org.apache.thrift.TBase;
+import org.junit.Test;
 
 import com.twitter.data.proto.tutorial.thrift.AddressBook;
 import com.twitter.data.proto.tutorial.thrift.Person;
 import com.twitter.elephantbird.thrift.test.TestStructInMap;
 
+import static org.apache.parquet.schema.MessageTypeParser.parseMessageType;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
 public class TestThriftSchemaConverter {
 
   @Test
@@ -188,6 +189,11 @@ public void testProjectOnlyKeyInMap() {
             "  optional group names (MAP) = 2 {\n" +
             "    repeated group map (MAP_KEY_VALUE) {\n" +
             "      required binary key (UTF8);\n" +
+            "      optional group value {\n" +
+            "        optional group name = 1 {\n" +
+            "          optional binary first_name (UTF8) = 1;\n" +
+            "        }\n" +
+            "      }" +
             "    }\n" +
             "  }\n" +
             "}",TestStructInMap.class);
@@ -203,25 +209,86 @@ private void shouldThrowWhenProjectionFilterMatchesNothing(String filters, Strin
     }
   }
 
+  private void shouldThrowWhenNoColumnsAreSelected(String filters, Class<? extends TBase<?, ?>> thriftClass) {
+    try {
+      getDeprecatedFilteredSchema(filters, thriftClass);
+      fail("should throw projection exception when no columns are selected");
+    } catch (ThriftProjectionException e) {
+      assertEquals("No columns have been selected", e.getMessage());
+    }
+  }
+
+  @Test
+  public void testThrowWhenNoColumnsAreSelected() {
+    shouldThrowWhenNoColumnsAreSelected("non_existing", TestStructInMap.class);
+  }
+
   @Test
   public void testThrowWhenProjectionFilterMatchesNothing() {
-    shouldThrowWhenProjectionFilterMatchesNothing("non_existing", "non_existing", TestStructInMap.class);
     shouldThrowWhenProjectionFilterMatchesNothing("name;non_existing", "non_existing", TestStructInMap.class);
     shouldThrowWhenProjectionFilterMatchesNothing("**;non_existing", "non_existing", TestStructInMap.class);
     shouldThrowWhenProjectionFilterMatchesNothing("**;names/non_existing", "names/non_existing", TestStructInMap.class);
     shouldThrowWhenProjectionFilterMatchesNothing("**;names/non_existing;non_existing", "names/non_existing\nnon_existing", TestStructInMap.class);
   }
 
+  @Test
   public void testProjectOnlyValueInMap() {
     try {
       getDeprecatedFilteredSchema("name;names/value/**", TestStructInMap.class);
       fail("this should throw");
     } catch (ThriftProjectionException e) {
-      assertEquals("", e.getMessage());
+      assertEquals("Cannot select only the values of a map, you must keep the keys as well: names", e.getMessage());
+    }
+
+    try {
+      getStrictFilteredSchema("name;names.value", TestStructInMap.class);
+      fail("this should throw");
+    } catch (ThriftProjectionException e) {
+      assertEquals("Cannot select only the values of a map, you must keep the keys as well: names", e.getMessage());
+    }
+
+  }
+
+  private void doTestPartialKeyProjection(String deprecated, String strict) {
+    try {
+      getDeprecatedFilteredSchema(deprecated, MapStructV2.class);
+      fail("this should throw");
+    } catch (ThriftProjectionException e) {
+      assertEquals("Cannot select only a subset of the fields in a map key, for path map1", e.getMessage());
+    }
+
+    try {
+      getStrictFilteredSchema(strict, MapStructV2.class);
+      fail("this should throw");
+    } catch (ThriftProjectionException e) {
+      assertEquals("Cannot select only a subset of the fields in a map key, for path map1", e.getMessage());
+    }
+  }
+
+  @Test
+  public void testPartialKeyProjection() {
+    doTestPartialKeyProjection("map1/key/age", "map1.key.age");
+    doTestPartialKeyProjection("map1/key/age;map1/value/**", "map1.{key.age,value}");
+  }
+
+  @Test
+  public void testSetPartialProjection() {
+    try {
+      getDeprecatedFilteredSchema("set1/age", SetStructV2.class);
+      fail("this should throw");
+    } catch (ThriftProjectionException e) {
+      assertEquals("Cannot select only a subset of the fields in a set, for path set1", e.getMessage());
+    }
+
+    try {
+      getStrictFilteredSchema("set1.age", SetStructV2.class);
+      fail("this should throw");
+    } catch (ThriftProjectionException e) {
+      assertEquals("Cannot select only a subset of the fields in a set, for path set1", e.getMessage());
     }
   }
 
-  private void shouldGetProjectedSchema(String deprecatedFilterDesc, String strictFilterDesc, String expectedSchemaStr, Class<? extends TBase<?,?>> thriftClass) {
+  public static void shouldGetProjectedSchema(String deprecatedFilterDesc, String strictFilterDesc, String expectedSchemaStr, Class<? extends TBase<?,?>> thriftClass) {
     MessageType depRequestedSchema = getDeprecatedFilteredSchema(deprecatedFilterDesc, thriftClass);
     MessageType strictRequestedSchema = getStrictFilteredSchema(strictFilterDesc, thriftClass);
     MessageType expectedSchema = parseMessageType(expectedSchemaStr);
@@ -229,12 +296,12 @@ private void shouldGetProjectedSchema(String deprecatedFilterDesc, String strict
     assertEquals(expectedSchema, strictRequestedSchema);
   }
 
-  private MessageType getDeprecatedFilteredSchema(String filterDesc, Class<? extends TBase<?,?>> thriftClass) {
+  private static MessageType getDeprecatedFilteredSchema(String filterDesc, Class<? extends TBase<?,?>> thriftClass) {
     DeprecatedFieldProjectionFilter fieldProjectionFilter = new DeprecatedFieldProjectionFilter(filterDesc);
     return new ThriftSchemaConverter(fieldProjectionFilter).convert(thriftClass);
   }
 
-  private MessageType getStrictFilteredSchema(String semicolonDelimitedString, Class<? extends TBase<?,?>> thriftClass) {
+  private static MessageType getStrictFilteredSchema(String semicolonDelimitedString, Class<? extends TBase<?,?>> thriftClass) {
     StrictFieldProjectionFilter fieldProjectionFilter = StrictFieldProjectionFilter.fromSemicolonDelimitedString(semicolonDelimitedString);
     return new ThriftSchemaConverter(fieldProjectionFilter).convert(thriftClass);
   }
diff --git a/parquet-thrift/src/test/java/org/apache/parquet/thrift/TestThriftSchemaConverterProjectUnion.java b/parquet-thrift/src/test/java/org/apache/parquet/thrift/TestThriftSchemaConverterProjectUnion.java
new file mode 100644
index 0000000000..611a1a9c55
--- /dev/null
+++ b/parquet-thrift/src/test/java/org/apache/parquet/thrift/TestThriftSchemaConverterProjectUnion.java
@@ -0,0 +1,480 @@
+/* 
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.parquet.thrift;
+
+import org.apache.parquet.thrift.test.compat.ListOfUnions;
+import org.apache.parquet.thrift.test.compat.MapWithUnionKey;
+import org.apache.parquet.thrift.test.compat.MapWithUnionValue;
+import org.apache.parquet.thrift.test.compat.NestedNestedUnion;
+import org.apache.parquet.thrift.test.compat.NestedUnion;
+import org.apache.parquet.thrift.test.compat.OptionalInsideRequired;
+import org.apache.parquet.thrift.test.compat.RequiredInsideOptional;
+import org.apache.parquet.thrift.test.compat.StructWithNestedUnion;
+import org.apache.parquet.thrift.test.compat.StructWithOptionalUnionOfStructs;
+import org.apache.parquet.thrift.test.compat.UnionOfStructs;
+import org.apache.parquet.thrift.test.compat.UnionV2;
+import org.junit.Test;
+
+import static org.apache.parquet.thrift.TestThriftSchemaConverter.shouldGetProjectedSchema;
+
+public class TestThriftSchemaConverterProjectUnion {
+
+  /**
+   * Test projecting into a top level union
+   */
+  @Test
+  public void testTopLevelUnions() {
+
+    // very simple case, a union of structs where each struct has only 1 field
+    shouldGetProjectedSchema("aLong/**", "aLong",
+        "message ParquetSchema {\n" +
+        "  optional group aString = 1 {\n" +
+        "    required binary s (UTF8) = 1;\n" +
+        "  }\n" +
+        "  optional group aLong = 2 {\n" +
+        "    required int64 l = 1;\n" +
+        "  }\n" +
+        "  optional group aNewBool = 3 {\n" +
+        "    required boolean b = 1;\n" +
+        "  }\n" +
+        "}", UnionV2.class);
+
+    // a union of structs, where each struct has more than one field
+    // we should still only get one field per child here though
+    shouldGetProjectedSchema("aNewBool/**", "aNewBool",
+        "message ParquetSchema {\n" +
+        "  optional group structV3 = 1 {\n" +
+        "    required binary name (UTF8) = 1;\n" +
+        "  }\n" +
+        "  optional group structV4 = 2 {\n" +
+        "    required binary name (UTF8) = 1;\n" +
+        "  }\n" +
+        "  optional group aNewBool = 3 {\n" +
+        "    required boolean b = 1;\n" +
+        "  }\n" +
+        "}", UnionOfStructs.class);
+  }
+
+  /**
+   * An optional union should be dropped if not selected.
+   */
+  @Test
+  public void optionalUnionShouldBeDropped() {
+    shouldGetProjectedSchema("name", "name",
+        "message ParquetSchema {\n" +
+        "  required binary name (UTF8) = 1;\n" +
+        "}", StructWithOptionalUnionOfStructs.class);
+  }
+
+  /**
+   * An optional union inside a required struct should still be
+   * dropped if not selected.
+   */
+  @Test
+  public void optionalUnionInRequiredStructShouldBeDropped() {
+    shouldGetProjectedSchema("name", "name",
+        "message ParquetSchema {\n" +
+        "  required binary name (UTF8) = 1;\n" +
+        "}", OptionalInsideRequired.class);
+  }
+
+  /**
+   * A required union inside of an un-selected optional struct
+   * should get dropped along with the optional struct.
+   */
+  @Test
+  public void requiredUnionInsideOptionalStructShouldBeDropped() {
+    // test a required union inside an optional struct
+    shouldGetProjectedSchema("name", "name",
+        "message ParquetSchema {\n" +
+        "  required binary name (UTF8) = 1;\n" +
+        "}", RequiredInsideOptional.class);
+  }
+
+  /**
+   * A required union inside a selected optional struct should keep
+   * one sentinel column for each "kind" of union member.
+   */
+  @Test
+  public void requiredUnionInsideOptionalStructShouldBeKeptIfParentSelected() {
+    shouldGetProjectedSchema("aStruct/name", "aStruct.name",
+        "message ParquetSchema {\n" +
+        "  optional group aStruct = 2 {\n" +
+        "    required binary name (UTF8) = 1;\n" +
+        "    required group aUnion = 2 {\n" +
+        "      optional group structV3 = 1 {\n" +
+        "        required binary name (UTF8) = 1;\n" +
+        "      }\n" +
+        "      optional group structV4 = 2 {\n" +
+        "        required binary name (UTF8) = 1;\n" +
+        "      }\n" +
+        "      optional group aNewBool = 3 {\n" +
+        "        required boolean b = 1;\n" +
+        "      }\n" +
+        "    }\n" +
+        "  }\n" +
+        "}", RequiredInsideOptional.class);
+  }
+
+  /**
+   * Selecting only one "kind" of a union should trigger keeping one sentinel
+   * column from the rest of the "kinds" of the union.
+   */
+  @Test
+  public void selectingOneUnionMemberKeepsSentinels() {
+    shouldGetProjectedSchema(
+        "aUnion/structV4/addedStruct/gender",
+        "aUnion.structV4.addedStruct.gender",
+        "message ParquetSchema {\n" +
+        "  optional group aUnion = 2 {\n" +
+        "    optional group structV3 = 1 {\n" +
+        "      required binary name (UTF8) = 1;\n" +
+        "    }\n" +
+        "    optional group structV4 = 2 {\n" +
+        "      optional group addedStruct = 4 {\n" +
+        "        optional binary gender (UTF8) = 3;\n" +
+        "      }\n" +
+        "    }\n" +
+        "    optional group aNewBool = 3 {\n" +
+        "      required boolean b = 1;\n" +
+        "    }\n" +
+        "  }\n" +
+        "}",
+        StructWithOptionalUnionOfStructs.class);
+  }
+
+  /**
+   * In the case of a union inside a union (and union inside union inside union),
+   * even though the fields will be "optional" because of how unions
+   * are stored, we still need to grab sentinel columns from
+   * the members of the union.
+   */
+  @Test
+  public void testUnionInsideUnion() {
+
+    shouldGetProjectedSchema("structV3/age", "structV3.age",
+        "message ParquetSchema {\n" +
+        "  optional group structV3 = 1 {\n" +
+        "    optional binary age (UTF8) = 2;\n" +
+        "  }\n" +
+        "  optional group unionOfStructs = 2 {\n" +
+        "    optional group structV3 = 1 {\n" +
+        "      required binary name (UTF8) = 1;\n" +
+        "    }\n" +
+        "    optional group structV4 = 2 {\n" +
+        "      required binary name (UTF8) = 1;\n" +
+        "    }\n" +
+        "    optional group aNewBool = 3 {\n" +
+        "      required boolean b = 1;\n" +
+        "    }\n" +
+        "  }\n" +
+        "  optional group aLong = 3 {\n" +
+        "    required int64 l = 1;\n" +
+        "  }\n" +
+        "}", NestedUnion.class);
+
+    shouldGetProjectedSchema(
+        "unionOfStructs/structV4/addedStruct/gender",
+        "unionOfStructs.structV4.addedStruct.gender",
+        "message ParquetSchema {\n" +
+        "  optional group structV3 = 1 {\n" +
+        "    required binary name (UTF8) = 1;\n" +
+        "  }\n" +
+        "  optional group unionOfStructs = 2 {\n" +
+        "    optional group structV3 = 1 {\n" +
+        "      required binary name (UTF8) = 1;\n" +
+        "    }\n" +
+        "    optional group structV4 = 2 {\n" +
+        "      optional group addedStruct = 4 {\n" +
+        "        optional binary gender (UTF8) = 3;\n" +
+        "      }\n" +
+        "    }\n" +
+        "    optional group aNewBool = 3 {\n" +
+        "      required boolean b = 1;\n" +
+        "    }\n" +
+        "  }\n" +
+        "  optional group aLong = 3 {\n" +
+        "    required int64 l = 1;\n" +
+        "  }\n" +
+        "}\n", NestedUnion.class);
+
+    shouldGetProjectedSchema(
+        "unionV2/aLong/**",
+        "unionV2.aLong",
+        "message ParquetSchema {\n" +
+        "  optional group nestedUnion = 1 {\n" +
+        "    optional group structV3 = 1 {\n" +
+        "      required binary name (UTF8) = 1;\n" +
+        "    }\n" +
+        "    optional group unionOfStructs = 2 {\n" +
+        "      optional group structV3 = 1 {\n" +
+        "        required binary name (UTF8) = 1;\n" +
+        "      }\n" +
+        "      optional group structV4 = 2 {\n" +
+        "        required binary name (UTF8) = 1;\n" +
+        "      }\n" +
+        "      optional group aNewBool = 3 {\n" +
+        "        required boolean b = 1;\n" +
+        "      }\n" +
+        "    }\n" +
+        "    optional group aLong = 3 {\n" +
+        "      required int64 l = 1;\n" +
+        "    }\n" +
+        "  }\n" +
+        "  optional group unionV2 = 2 {\n" +
+        "    optional group aString = 1 {\n" +
+        "      required binary s (UTF8) = 1;\n" +
+        "    }\n" +
+        "    optional group aLong = 2 {\n" +
+        "      required int64 l = 1;\n" +
+        "    }\n" +
+        "    optional group aNewBool = 3 {\n" +
+        "      required boolean b = 1;\n" +
+        "    }\n" +
+        "  }\n" +
+        "}", NestedNestedUnion.class);
+
+  }
+
+  @Test
+  public void testListOfUnions() {
+
+    // selecting a field from an optional list of unions should also choose a sentinel field
+    // for the rest of the union members
+    // at the same time, this should also drop the required list of unions, because it is safe to
+    // drop even a required but repeated group
+    shouldGetProjectedSchema(
+      "optListUnion/structV3/age",
+      "optListUnion.structV3.age",
+      "message ParquetSchema {\n" +
+      "  optional group optListUnion (LIST) = 1 {\n" +
+      "    repeated group optListUnion_tuple {\n" +
+      "      optional group structV3 = 1 {\n" +
+      "        optional binary age (UTF8) = 2;\n" +
+      "      }\n" +
+      "      optional group structV4 = 2 {\n" +
+      "        required binary name (UTF8) = 1;\n" +
+      "      }\n" +
+      "      optional group aNewBool = 3 {\n" +
+      "        required boolean b = 1;\n" +
+      "      }\n" +
+      "    }\n" +
+      "  }\n" +
+      "}", ListOfUnions.class);
+
+    // same goes for selecting a field from a required list of unions
+    // and at the same time, the optional list of unions should be dropped too
+    shouldGetProjectedSchema(
+        "reqListUnion/structV3/age",
+        "reqListUnion.structV3.age",
+        "message ParquetSchema {\n" +
+        "  required group reqListUnion (LIST) = 2 {\n" +
+        "    repeated group reqListUnion_tuple {\n" +
+        "      optional group structV3 = 1 {\n" +
+        "        optional binary age (UTF8) = 2;\n" +
+        "      }\n" +
+        "      optional group structV4 = 2 {\n" +
+        "        required binary name (UTF8) = 1;\n" +
+        "      }\n" +
+        "      optional group aNewBool = 3 {\n" +
+        "        required boolean b = 1;\n" +
+        "      }\n" +
+        "    }\n" +
+        "  }\n" +
+        "}", ListOfUnions.class);
+
+  }
+
+  @Test
+  public void testMapWithUnionKey() {
+    shouldGetProjectedSchema(
+        "optMapWithUnionKey/key/**",
+        "optMapWithUnionKey.key",
+        "message ParquetSchema {\n" +
+        "  optional group optMapWithUnionKey (MAP) = 1 {\n" +
+        "    repeated group map (MAP_KEY_VALUE) {\n" +
+        "      required group key {\n" +
+        "        optional group structV3 = 1 {\n" +
+        "          required binary name (UTF8) = 1;\n" +
+        "          optional binary age (UTF8) = 2;\n" +
+        "          optional binary gender (UTF8) = 3;\n" +
+        "        }\n" +
+        "        optional group structV4 = 2 {\n" +
+        "          required binary name (UTF8) = 1;\n" +
+        "          optional binary age (UTF8) = 2;\n" +
+        "          optional binary gender (UTF8) = 3;\n" +
+        "          optional group addedStruct = 4 {\n" +
+        "            required binary name (UTF8) = 1;\n" +
+        "            optional binary age (UTF8) = 2;\n" +
+        "            optional binary gender (UTF8) = 3;\n" +
+        "          }\n" +
+        "        }\n" +
+        "        optional group aNewBool = 3 {\n" +
+        "          required boolean b = 1;\n" +
+        "        }\n" +
+        "      }\n" +
+        "      optional group value {\n" +
+        "        required binary name (UTF8) = 1;\n" +
+        "      } " +
+        "    }\n" +
+        "  }\n" +
+        "}", MapWithUnionKey.class);
+
+    shouldGetProjectedSchema(
+        "optMapWithUnionKey/key/**;optMapWithUnionKey/value/gender",
+        "optMapWithUnionKey.{key,value.gender}",
+        "message ParquetSchema {\n" +
+        "  optional group optMapWithUnionKey (MAP) = 1 {\n" +
+        "    repeated group map (MAP_KEY_VALUE) {\n" +
+        "      required group key {\n" +
+        "        optional group structV3 = 1 {\n" +
+        "          required binary name (UTF8) = 1;\n" +
+        "          optional binary age (UTF8) = 2;\n" +
+        "          optional binary gender (UTF8) = 3;\n" +
+        "        }\n" +
+        "        optional group structV4 = 2 {\n" +
+        "          required binary name (UTF8) = 1;\n" +
+        "          optional binary age (UTF8) = 2;\n" +
+        "          optional binary gender (UTF8) = 3;\n" +
+        "          optional group addedStruct = 4 {\n" +
+        "            required binary name (UTF8) = 1;\n" +
+        "            optional binary age (UTF8) = 2;\n" +
+        "            optional binary gender (UTF8) = 3;\n" +
+        "          }\n" +
+        "        }\n" +
+        "        optional group aNewBool = 3 {\n" +
+        "          required boolean b = 1;\n" +
+        "        }\n" +
+        "      }\n" +
+        "      optional group value {\n" +
+        "        optional binary gender (UTF8) = 3;\n" +
+        "      }\n" +
+        "    }\n" +
+        "  }\n" +
+        "}", MapWithUnionKey.class);
+  }
+
+  @Test
+  public void testMapWithUnionValue() {
+    shouldGetProjectedSchema(
+        "optMapWithUnionValue/key/**;optMapWithUnionValue/value/structV4/addedStruct/gender",
+        "optMapWithUnionValue.{key,value.structV4.addedStruct.gender}",
+        "message ParquetSchema {\n" +
+        "  optional group optMapWithUnionValue (MAP) = 1 {\n" +
+        "    repeated group map (MAP_KEY_VALUE) {\n" +
+        "      required group key {\n" +
+        "        required binary name (UTF8) = 1;\n" +
+        "        optional binary age (UTF8) = 2;\n" +
+        "        optional binary gender (UTF8) = 3;\n" +
+        "      }\n" +
+        "      optional group value {\n" +
+        "        optional group structV3 = 1 {\n" +
+        "          required binary name (UTF8) = 1;\n" +
+        "        }\n" +
+        "        optional group structV4 = 2 {\n" +
+        "          optional group addedStruct = 4 {\n" +
+        "            optional binary gender (UTF8) = 3;\n" +
+        "          }\n" +
+        "        }\n" +
+        "        optional group aNewBool = 3 {\n" +
+        "          required boolean b = 1;\n" +
+        "        }\n" +
+        "      }\n" +
+        "    }\n" +
+        "  }\n" +
+        "}", MapWithUnionValue.class);
+  }
+
+  /**
+   * Tests a complicated struct that contains required, optional, and unspecified
+   * members of a few different corner cases.
+   */
+  @Test
+  public void testMessyNestedUnions() {
+    shouldGetProjectedSchema("reqStructWithUnionV2/name", "reqStructWithUnionV2.name",
+        "message ParquetSchema {\n" +
+            "  required group reqUnionOfStructs = 2 {\n" +
+            "    optional group structV3 = 1 {\n" +
+            "      required binary name (UTF8) = 1;\n" +
+            "    }\n" +
+            "    optional group structV4 = 2 {\n" +
+            "      required binary name (UTF8) = 1;\n" +
+            "    }\n" +
+            "    optional group aNewBool = 3 {\n" +
+            "      required boolean b = 1;\n" +
+            "    }\n" +
+            "  }\n" +
+            "  required group reqNestedUnion = 5 {\n" +
+            "    optional group structV3 = 1 {\n" +
+            "      required binary name (UTF8) = 1;\n" +
+            "    }\n" +
+            "    optional group unionOfStructs = 2 {\n" +
+            "      optional group structV3 = 1 {\n" +
+            "        required binary name (UTF8) = 1;\n" +
+            "      }\n" +
+            "      optional group structV4 = 2 {\n" +
+            "        required binary name (UTF8) = 1;\n" +
+            "      }\n" +
+            "      optional group aNewBool = 3 {\n" +
+            "        required boolean b = 1;\n" +
+            "      }\n" +
+            "    }\n" +
+            "    optional group aLong = 3 {\n" +
+            "      required int64 l = 1;\n" +
+            "    }\n" +
+            "  }\n" +
+            "  required group reqStructWithUnionV2 = 8 {\n" +
+            "    required binary name (UTF8) = 1;\n" +
+            "    required group aUnion = 2 {\n" +
+            "      optional group aString = 1 {\n" +
+            "        required binary s (UTF8) = 1;\n" +
+            "      }\n" +
+            "      optional group aLong = 2 {\n" +
+            "        required int64 l = 1;\n" +
+            "      }\n" +
+            "      optional group aNewBool = 3 {\n" +
+            "        required boolean b = 1;\n" +
+            "      }\n" +
+            "    }\n" +
+            "  }\n" +
+            "  required group reqUnionStructUnion = 11 {\n" +
+            "    optional group structV3 = 1 {\n" +
+            "      required binary name (UTF8) = 1;\n" +
+            "    }\n" +
+            "    optional group structWithUnionOfStructs = 2 {\n" +
+            "      required binary name (UTF8) = 1;\n" +
+            "      required group aUnion = 2 {\n" +
+            "        optional group structV3 = 1 {\n" +
+            "          required binary name (UTF8) = 1;\n" +
+            "        }\n" +
+            "        optional group structV4 = 2 {\n" +
+            "          required binary name (UTF8) = 1;\n" +
+            "        }\n" +
+            "        optional group aNewBool = 3 {\n" +
+            "          required boolean b = 1;\n" +
+            "        }\n" +
+            "      }\n" +
+            "    }\n" +
+            "    optional group aLong = 3 {\n" +
+            "      required int64 l = 1;\n" +
+            "    }\n" +
+            "  }\n" +
+            "}", StructWithNestedUnion.class);
+  }
+}
diff --git a/parquet-thrift/src/test/java/org/apache/parquet/thrift/projection/TestFieldsPath.java b/parquet-thrift/src/test/java/org/apache/parquet/thrift/projection/TestFieldsPath.java
index 335a7ffe85..ee545dbd1a 100644
--- a/parquet-thrift/src/test/java/org/apache/parquet/thrift/projection/TestFieldsPath.java
+++ b/parquet-thrift/src/test/java/org/apache/parquet/thrift/projection/TestFieldsPath.java
@@ -69,9 +69,7 @@ public void testFieldsPath() {
 
   }
 
-  private static class PrimitivePathVisitor implements ThriftType.TypeVisitor {
-    private List<String> paths = new ArrayList<String>();
-    private FieldsPath path = new FieldsPath();
+  private static class PrimitivePathVisitor implements ThriftType.TypeVisitor<List<String>, FieldsPath> {
     private String delim;
 
     private PrimitivePathVisitor(String delim) {
@@ -80,87 +78,85 @@ private PrimitivePathVisitor(String delim) {
 
     public static List<String> visit(StructType s, String delim) {
       PrimitivePathVisitor v = new PrimitivePathVisitor(delim);
-      s.accept(v);
-      return v.getPaths();
-    }
-
-    public List<String> getPaths() {
-      return paths;
+      return s.accept(v, new FieldsPath());
     }
 
     @Override
-    public void visit(MapType mapType) {
+    public List<String> visit(MapType mapType, FieldsPath path) {
+      List<String> ret = new ArrayList<String>();
+
       ThriftField key = mapType.getKey();
       ThriftField value = mapType.getValue();
-      path.push(key);
-      key.getType().accept(this);
-      path.pop();
-      path.push(value);
-      value.getType().accept(this);
-      path.pop();
+
+      ret.addAll(key.getType().accept(this, path.push(key)));
+      ret.addAll(value.getType().accept(this, path.push(value)));
+
+      return ret;
     }
 
     @Override
-    public void visit(SetType setType) {
-      setType.getValues().getType().accept(this);
+    public List<String> visit(SetType setType, FieldsPath path) {
+      return setType.getValues().getType().accept(this, path);
     }
 
     @Override
-    public void visit(ListType listType) {
-      listType.getValues().getType().accept(this);
+    public List<String> visit(ListType listType, FieldsPath path) {
+      return listType.getValues().getType().accept(this, path);
     }
 
     @Override
-    public void visit(StructType structType) {
+    public List<String> visit(StructType structType, FieldsPath path) {
+      List<String> ret = new ArrayList<String>();
+
       for (ThriftField child : structType.getChildren()) {
-        path.push(child);
-        child.getType().accept(this);
-        path.pop();
+        ret.addAll(child.getType().accept(this, path.push(child)));
       }
+
+      return ret;
     }
 
-    private void visitPrimitive() {
-      paths.add(path.toDelimitedString(delim));
+    private List<String> visitPrimitive(FieldsPath path) {
+      return Arrays.asList(path.toDelimitedString(delim));
     }
 
     @Override
-    public void visit(EnumType enumType) {
-      visitPrimitive();
+    public List<String> visit(EnumType enumType, FieldsPath path) {
+      return visitPrimitive(path);
     }
 
     @Override
-    public void visit(BoolType boolType) {
-      visitPrimitive();
+    public List<String> visit(BoolType boolType, FieldsPath path) {
+      return visitPrimitive(path);
     }
 
     @Override
-    public void visit(ByteType byteType) {
-      visitPrimitive();
+    public List<String> visit(ByteType byteType, FieldsPath path) {
+      return visitPrimitive(path);
     }
 
     @Override
-    public void visit(DoubleType doubleType) {
-      visitPrimitive();
+    public List<String> visit(DoubleType doubleType, FieldsPath path) {
+      return visitPrimitive(path);
     }
 
     @Override
-    public void visit(I16Type i16Type) {
-      visitPrimitive();
+    public List<String> visit(I16Type i16Type, FieldsPath path) {
+      return visitPrimitive(path);
     }
 
     @Override
-    public void visit(I32Type i32Type) {
-      visitPrimitive();
+    public List<String> visit(I32Type i32Type, FieldsPath path) {
+      return visitPrimitive(path);
     }
 
     @Override
-    public void visit(I64Type i64Type) {
-      visitPrimitive();
+    public List<String> visit(I64Type i64Type, FieldsPath path) {
+      return visitPrimitive(path);
     }
 
     @Override
-    public void visit(StringType stringType) {
-      visitPrimitive();
+    public List<String> visit(StringType stringType, FieldsPath path) {
+      return visitPrimitive(path);
     }
   }
 }
diff --git a/parquet-thrift/src/test/thrift/compat.thrift b/parquet-thrift/src/test/thrift/compat.thrift
index 2bd8a8c2c6..63972a8dca 100644
--- a/parquet-thrift/src/test/thrift/compat.thrift
+++ b/parquet-thrift/src/test/thrift/compat.thrift
@@ -18,6 +18,7 @@
  */
 
 namespace java org.apache.parquet.thrift.test.compat
+
 struct StructV1 {
   1: required string name
 }
@@ -100,6 +101,18 @@ struct MapAddRequiredStructV1{
   1: required map<AddRequiredStructV1,string> map1
 }
 
+struct MapWithStructValue {
+  1: required map<string, StructV4WithExtracStructField> reqMap
+}
+
+struct MapWithPrimMapValue {
+  1: required map<string, map<string, string>> reqMap
+}
+
+struct MapWithStructMapValue {
+  1: required map<string, map<string, StructV4WithExtracStructField>> reqMap
+}
+
 struct SetStructV1{
   1: required set<StructV1> set1
 }
@@ -159,3 +172,84 @@ struct StructWithAStructThatLooksLikeUnionV2 {
   1: required string name,
   2: required AStructThatLooksLikeUnionV2 aNotQuiteUnion
 }
+
+union UnionOfStructs {
+  1: StructV3 structV3,
+  2: StructV4WithExtracStructField structV4,
+  3: ABool aNewBool
+}
+
+struct StructWithUnionOfStructs {  
+  1: required string name,
+  2: required UnionOfStructs aUnion
+}
+
+struct StructWithOptionalUnionOfStructs {  
+  1: required string name,
+  2: optional UnionOfStructs aUnion
+}
+
+struct StructWithRequiredUnionOfStructs {  
+  1: required string name,
+  2: required UnionOfStructs aUnion
+}
+
+struct OptionalInsideRequired {
+  1: required string name,
+  2: required StructWithOptionalUnionOfStructs aStruct
+}
+
+struct RequiredInsideOptional {
+  1: required string name,
+  2: optional StructWithRequiredUnionOfStructs aStruct
+}
+
+union UnionStructUnion {
+  1: StructV3 structV3
+  2: StructWithUnionOfStructs structWithUnionOfStructs
+  3: ALong aLong 
+}
+
+union NestedUnion {
+  1: StructV3 structV3
+  2: UnionOfStructs unionOfStructs
+  3: ALong aLong 
+}
+
+union NestedNestedUnion {
+  1: NestedUnion nestedUnion
+  2: UnionV2 unionV2
+}
+
+struct StructWithNestedUnion {
+  1: optional UnionOfStructs optUnionOfStructs
+  2: required UnionOfStructs reqUnionOfStructs
+  3: UnionOfStructs unspecifiedUnionOfStructs
+  
+  4: optional NestedUnion optNestedUnion
+  5: required NestedUnion reqNestedUnion
+  6: NestedUnion unspecifiedNestedUnion
+  
+  7: optional StructWithUnionV2 optStructWithUnionV2
+  8: required StructWithUnionV2 reqStructWithUnionV2
+  9: StructWithUnionV2 unspecifiedStructWithUnionV2
+  
+  10: optional UnionStructUnion optUnionStructUnion
+  11: required UnionStructUnion reqUnionStructUnion
+  12: UnionStructUnion unspecifiedUnionStructUnion
+}
+
+struct MapWithUnionKey {
+  1: optional map<UnionOfStructs, StructV3> optMapWithUnionKey
+  2: required map<UnionOfStructs, StructV3> reqMapWithUnionKey
+}
+
+struct MapWithUnionValue {
+  1: optional map<StructV3, UnionOfStructs> optMapWithUnionValue
+  2: required map<StructV3, UnionOfStructs> reqMapWithUnionValue
+}
+
+struct ListOfUnions {
+  1: optional list<UnionOfStructs> optListUnion
+  2: required list<UnionOfStructs> reqListUnion
+}
diff --git a/parquet_cascading.md b/parquet_cascading.md
index 15470e1132..a1b0a6864f 100644
--- a/parquet_cascading.md
+++ b/parquet_cascading.md
@@ -115,7 +115,11 @@ This applies for repeated fields as well, for example `primaryAddress.otherPhone
 Maps are a special case -- the map is split into two columns, the key and the value. All the columns in the key are required, but you can select a subset of the
 columns in the value (or skip the value entirely), for example: `otherAddresses.{key,value.street}` will select only the streets from the
 values of the map, but the entire key will be kept. To select an entire map, you can do: `otherAddresses.{key,value}`, 
-and to select only the keys: `otherAddresses.key`. When selecting a field that is a struct, for example `primaryAddress.primaryPhone`, 
+and to select only the keys: `otherAddresses.key`. Similar to map keys, the values in a set cannot be partially projected,
+you must select all the columns of the items in the set, or none of them. This is because materializing the set wouldn't make much sense if the item's
+hashcode is dependent on the dropped columns (as with the key of a map).
+
+When selecting a field that is a struct, for example `primaryAddress.primaryPhone`, 
 it will select the entire struct. So `primaryAddress.primaryPhone.*` is redundant.
 
 Columns can be specified concretely (like `primaryAddress.primaryPhone.doNotCall`), or a restricted glob syntax can be used.
