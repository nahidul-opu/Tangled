From 7ec35cf7f5d760cb6b31928c2622d528af11e406 Mon Sep 17 00:00:00 2001
From: Phil Steitz <psteitz@apache.org>
Date: Tue, 4 Jul 2006 08:09:25 +0000
Subject: [PATCH] =?UTF-8?q?Added=20a=20nextAfter=20method=20in=20MathUtils?=
 =?UTF-8?q?=20to=20return=20the=20next=20machine-representable=20number=20?=
 =?UTF-8?q?in=20a=20specified=20direction=20from=20a=20given=20floating=20?=
 =?UTF-8?q?point=20number.=20=20Used=20this=20to=20ensure=20that=20MathUti?=
 =?UTF-8?q?ls.round=20does=20not=20return=20incorrect=20results=20for=20nu?=
 =?UTF-8?q?mbers=20with=20bad=20IEEE754=20representations.=20JIRA:=20MATH-?=
 =?UTF-8?q?151=20Reported=20by=20Buza=20Zolt=C3=A1n=20Patch=20submitted=20?=
 =?UTF-8?q?by=20Luc=20Maisonobe?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

git-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/math/trunk@418934 13f79535-47bb-0310-9956-ffa450edef68
---
 project.xml                                   |  3 +
 .../apache/commons/math/util/MathUtils.java   | 84 ++++++++++++++---
 .../commons/math/util/MathUtilsTest.java      | 90 ++++++++++++++++++-
 xdocs/changes.xml                             |  7 ++
 4 files changed, 171 insertions(+), 13 deletions(-)

diff --git a/project.xml b/project.xml
index 31552cf7a5..40e263fd76 100644
--- a/project.xml
+++ b/project.xml
@@ -164,6 +164,9 @@
     <contributor>
       <name>Piotr Kochanski</name>
     </contributor>
+    <contributor>
+      <name>Luc Maisonobe</name>
+    </contributor>
     <contributor>
       <name>Fredrik Norin</name>
     </contributor>
diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java
index 9bfb7bc5b2..043a51b442 100644
--- a/src/java/org/apache/commons/math/util/MathUtils.java
+++ b/src/java/org/apache/commons/math/util/MathUtils.java
@@ -473,6 +473,55 @@ public static int mulAndCheck(int x, int y) {
         return (int)m;
     }
 
+    /**
+     * Get the closest machine representable number
+     * from a number in some direction.
+
+     * @param d base number
+     * @param direction (the only important thing is whether
+     * direction is greater or smaller than d)
+     * @return
+     */
+    public static double nextAfter(double d, double direction) {
+
+        // handling of some important special cases
+        if (Double.isNaN(d) || Double.isInfinite(d)) {
+                return d;
+        } else if (d == 0) {
+                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;
+        }
+        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0
+        // are handled just as normal numbers
+
+        // split the double in raw components
+        long bits     = Double.doubleToLongBits(d);
+        long sign     = bits & 0x8000000000000000L;
+        long exponent = bits & 0x7ff0000000000000L;
+        long mantissa = bits & 0x000fffffffffffffL;
+
+        if (d * (direction - d) >= 0) {
+                // we should increase the mantissa
+                if (mantissa == 0x000fffffffffffffL) {
+                        return Double.longBitsToDouble(sign |
+                                        (exponent + 0x0010000000000000L));
+                } else {
+                        return Double.longBitsToDouble(sign |
+                                        exponent | (mantissa + 1));
+                }
+        } else {
+                // we should decrease the mantissa
+                if (mantissa == 0L) {
+                        return Double.longBitsToDouble(sign |
+                                        (exponent - 0x0010000000000000L) |
+                                        0x000fffffffffffffL);
+                } else {
+                        return Double.longBitsToDouble(sign |
+                                        exponent | (mantissa - 1));
+                }
+        }
+
+    }
+
     /**
      * Round the given value to the specified number of decimal places. The
      * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.
@@ -499,9 +548,18 @@ public static double round(double x, int scale) {
      * @since 1.1
      */
     public static double round(double x, int scale, int roundingMethod) {
-        double sign = indicator(x);
-        double factor = Math.pow(10.0, scale) * sign;
-        return roundUnscaled(x * factor, sign, roundingMethod) / factor;
+        try {
+            return (new BigDecimal
+                   (new Double(x).toString())
+                   .setScale(scale, roundingMethod))
+                   .doubleValue();
+        } catch (NumberFormatException ex) {
+            if (Double.isInfinite(x)) {
+                return x;          
+            } else {
+                return Double.NaN;
+            }
+        }
     }
 
     /**
@@ -552,23 +610,24 @@ private static double roundUnscaled(double unscaled, double sign,
         switch (roundingMethod) {
         case BigDecimal.ROUND_CEILING :
             if (sign == -1) {
-                unscaled = Math.floor(unscaled);
+                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
             } else {
-                unscaled = Math.ceil(unscaled);
+                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
             }
             break;
         case BigDecimal.ROUND_DOWN :
-            unscaled = Math.floor(unscaled);
+            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
             break;
         case BigDecimal.ROUND_FLOOR :
             if (sign == -1) {
-                unscaled = Math.ceil(unscaled);
+                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));
             } else {
-                unscaled = Math.floor(unscaled);
+                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));
             }
             break;
         case BigDecimal.ROUND_HALF_DOWN : {
-            double fraction = Math.abs(unscaled - Math.floor(unscaled));
+            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);
+            double fraction = unscaled - Math.floor(unscaled);
             if (fraction > 0.5) {
                 unscaled = Math.ceil(unscaled);
             } else {
@@ -577,7 +636,7 @@ private static double roundUnscaled(double unscaled, double sign,
             break;
         }
         case BigDecimal.ROUND_HALF_EVEN : {
-            double fraction = Math.abs(unscaled - Math.floor(unscaled));
+            double fraction = unscaled - Math.floor(unscaled);
             if (fraction > 0.5) {
                 unscaled = Math.ceil(unscaled);
             } else if (fraction < 0.5) {
@@ -593,7 +652,8 @@ private static double roundUnscaled(double unscaled, double sign,
             break;
         }
         case BigDecimal.ROUND_HALF_UP : {
-            double fraction = Math.abs(unscaled - Math.floor(unscaled));
+            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);
+            double fraction = unscaled - Math.floor(unscaled);
             if (fraction >= 0.5) {
                 unscaled = Math.ceil(unscaled);
             } else {
@@ -607,7 +667,7 @@ private static double roundUnscaled(double unscaled, double sign,
             }
             break;
         case BigDecimal.ROUND_UP :
-            unscaled = Math.ceil(unscaled);
+            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));
             break;
         default :
             throw new IllegalArgumentException("Invalid rounding method.");
diff --git a/src/test/org/apache/commons/math/util/MathUtilsTest.java b/src/test/org/apache/commons/math/util/MathUtilsTest.java
index ccce093ab2..d57dc1f7d9 100644
--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java
+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java
@@ -583,15 +583,100 @@ public void testRoundFloat() {
         assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f);
     }
     
+    public void testNextAfterSpecialCases() {
+        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0)));
+        assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0)));
+        assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0)));
+        assertTrue(Double.isInfinite(MathUtils.nextAfter( Double.MAX_VALUE, Double.POSITIVE_INFINITY)));
+        assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY)));
+        assertEquals( Double.MIN_VALUE, MathUtils.nextAfter(0,  1), 0);
+        assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0);
+        assertEquals(0, MathUtils.nextAfter( Double.MIN_VALUE, -1), 0);
+        assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE,  1), 0);
+    }
+    
+    public void testNextAfter() {
+        // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000
+        assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0);
+
+        // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe
+        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0);
+
+        // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe
+        assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0);
+
+        // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe
+        assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0);
+
+        // 0x4020000000000000 0x404123456789abcd -> 4020000000000001
+        assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0);
+
+        // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff
+        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0);
+
+        // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff
+        assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0);
+
+        // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff
+        assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0);
+
+        // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224
+        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0);
+
+        // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224
+        assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);
+
+        // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222
+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);
+
+        // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222
+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0);
+
+        // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222
+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);
+
+        // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222
+        assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);
+
+        // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222
+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0);
+
+        // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222
+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0);
+
+        // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222
+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0);
+
+        // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224
+        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0);
+
+        // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224
+        assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0);
+
+        // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222
+        assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0);
+
+    }
+
     public void testRoundDouble() {
         double x = 1.234567890;
         assertEquals(1.23, MathUtils.round(x, 2), 0.0);
         assertEquals(1.235, MathUtils.round(x, 3), 0.0);
         assertEquals(1.2346, MathUtils.round(x, 4), 0.0);
         
+        // JIRA MATH-151
+        assertEquals(39.25,MathUtils.round(39.245, 2), 0.0);
+        assertEquals(39.24,MathUtils.round(39.245, 2, 
+                BigDecimal.ROUND_DOWN), 0.0);
+        double xx = 39.0;
+        xx = xx + 245d/1000d;
+        assertEquals(39.25,MathUtils.round(xx, 2), 0.0);
+        
         // BZ 35904
         assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d);
         assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d);
+        assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d);
+        assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d);
         assertEquals(50.09d,  MathUtils.round(50.085d, 2), 0.0d);
         assertEquals(50.19d,  MathUtils.round(50.185d, 2), 0.0d);
         assertEquals(50.01d,  MathUtils.round(50.005d, 2), 0.0d);
@@ -671,7 +756,10 @@ public void testRoundDouble() {
         } catch (IllegalArgumentException ex) {
             // success
         }
-        
+
+        // MATH-151
+        assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0);
+     
         // special values
         TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0);
         assertEquals(0.0, MathUtils.round(0.0, 2), 0.0);
diff --git a/xdocs/changes.xml b/xdocs/changes.xml
index f611a78297..60a2a73f9f 100644
--- a/xdocs/changes.xml
+++ b/xdocs/changes.xml
@@ -52,6 +52,13 @@ Commons Math Release Notes</title>
       <action dev="psteitz" type="fix" issue="MATH-60" due-to="Nhung Nnguyen">
         Modified ProperFractionFormat to reject embedded minus signs.
       </action>
+      <action dev="psteitz" type="fix" issue="MATH-151" due-to="Luc Maisonobe">
+        Added a nextAfter method in MathUtils to return the next
+        machine-representable number in a specified direction from a given
+        floating point number.  Used this to ensure that MathUtils.round does
+        not return incorrect results for numbers with bad IEEE754 
+        representations.
+      </action>
     </release>
     <release version="1.1" date="2005-12-17"  
  description="This is a maintenance release containing bug fixes and enhancements.
