From 72bfc1247553bdd2711d6bb27a7179be86ded4f1 Mon Sep 17 00:00:00 2001
From: Stefan Bodewig <bodewig@apache.org>
Date: Wed, 11 Jul 2018 18:42:57 +0200
Subject: [PATCH] COMPRESS-459 fix writing of multibyte names and add a test as
 proof

---
 .../cpio/CpioArchiveOutputStream.java         | 35 ++++++---
 .../archivers/cpio/CpioArchiveTest.java       | 74 +++++++++++++++++++
 2 files changed, 99 insertions(+), 10 deletions(-)
 create mode 100644 src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveTest.java

diff --git a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
index 07fd53a08bf..afb57a28334 100644
--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
@@ -23,6 +23,7 @@
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
 import java.nio.charset.Charset;
+import java.util.Arrays;
 import java.util.HashMap;
 
 import org.apache.commons.compress.archivers.ArchiveEntry;
@@ -300,9 +301,10 @@ private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {
         writeAsciiLong(devMin, 8, 16);
         writeAsciiLong(entry.getRemoteDeviceMaj(), 8, 16);
         writeAsciiLong(entry.getRemoteDeviceMin(), 8, 16);
-        writeAsciiLong(entry.getName().length() + 1L, 8, 16);
+        byte[] name = encode(entry.getName());
+        writeAsciiLong(name.length + 1L, 8, 16);
         writeAsciiLong(entry.getChksum(), 8, 16);
-        writeCString(entry.getName());
+        writeCString(name);
         pad(entry.getHeaderPadCount(Charset.forName(encoding)));
     }
 
@@ -331,9 +333,10 @@ private void writeOldAsciiEntry(final CpioArchiveEntry entry)
         writeAsciiLong(entry.getNumberOfLinks(), 6, 8);
         writeAsciiLong(entry.getRemoteDevice(), 6, 8);
         writeAsciiLong(entry.getTime(), 11, 8);
-        writeAsciiLong(entry.getName().length() + 1L, 6, 8);
+        byte[] name = encode(entry.getName());
+        writeAsciiLong(name.length + 1L, 6, 8);
         writeAsciiLong(entry.getSize(), 11, 8);
-        writeCString(entry.getName());
+        writeCString(name);
     }
 
     private void writeOldBinaryEntry(final CpioArchiveEntry entry,
@@ -361,9 +364,10 @@ private void writeOldBinaryEntry(final CpioArchiveEntry entry,
         writeBinaryLong(entry.getNumberOfLinks(), 2, swapHalfWord);
         writeBinaryLong(entry.getRemoteDevice(), 2, swapHalfWord);
         writeBinaryLong(entry.getTime(), 4, swapHalfWord);
-        writeBinaryLong(entry.getName().length() + 1L, 2, swapHalfWord);
+        byte[] name = encode(entry.getName());
+        writeBinaryLong(name.length + 1L, 2, swapHalfWord);
         writeBinaryLong(entry.getSize(), 4, swapHalfWord);
-        writeCString(entry.getName());
+        writeCString(name);
         pad(entry.getHeaderPadCount(Charset.forName(encoding)));
     }
 
@@ -537,16 +541,27 @@ private void writeAsciiLong(final long number, final int length,
     }
 
     /**
-     * Writes an ASCII string to the stream followed by \0
+     * Encodes the given string using the configured encoding.
+     *
      * @param str the String to write
      * @throws IOException if the string couldn't be written
+     * @return result of encoding the string
      */
-    private void writeCString(final String str) throws IOException {
+    private byte[] encode(final String str) throws IOException {
         final ByteBuffer buf = zipEncoding.encode(str);
         final int len = buf.limit() - buf.position();
-        out.write(buf.array(), buf.arrayOffset(), len);
+        return Arrays.copyOfRange(buf.array(), buf.arrayOffset(), buf.arrayOffset() + len);
+    }
+
+    /**
+     * Writes an encoded string to the stream followed by \0
+     * @param str the String to write
+     * @throws IOException if the string couldn't be written
+     */
+    private void writeCString(byte[] str) throws IOException {
+        out.write(str);
         out.write('\0');
-        count(len + 1);
+        count(str.length + 1);
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveTest.java b/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveTest.java
new file mode 100644
index 00000000000..0dac090f909
--- /dev/null
+++ b/src/test/java/org/apache/commons/compress/archivers/cpio/CpioArchiveTest.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.commons.compress.archivers.cpio;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.util.Arrays;
+import java.util.Collection;
+import org.apache.commons.compress.utils.IOUtils;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized.Parameters;
+import org.junit.runners.Parameterized;
+
+@RunWith(Parameterized.class)
+public class CpioArchiveTest {
+
+    @Parameters(name = "using {0}")
+    public static Collection<Object[]> factory() {
+        return Arrays.asList(new Object[][] {
+                new Object[]  { CpioConstants.FORMAT_NEW },
+                new Object[]  { CpioConstants.FORMAT_NEW_CRC },
+                new Object[]  { CpioConstants.FORMAT_OLD_ASCII },
+                new Object[]  { CpioConstants.FORMAT_OLD_BINARY },
+            });
+    }
+
+    private final short format;
+
+    public CpioArchiveTest(short format) {
+        this.format = format;
+    }
+
+    @Test
+    public void utf18RoundtripTest() throws Exception {
+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
+            try (CpioArchiveOutputStream os = new CpioArchiveOutputStream(baos, format, CpioConstants.BLOCK_SIZE,
+                "UTF-16LE")) {
+                CpioArchiveEntry entry = new CpioArchiveEntry(format, "T\u00e4st.txt", 4);
+                if (format == CpioConstants.FORMAT_NEW_CRC) {
+                    entry.setChksum(10);
+                }
+                os.putArchiveEntry(entry);
+                os.write(new byte[] { 1, 2, 3, 4 });
+                os.closeArchiveEntry();
+            }
+            baos.close();
+            try (ByteArrayInputStream bin = new ByteArrayInputStream(baos.toByteArray());
+                 CpioArchiveInputStream in = new CpioArchiveInputStream(bin, "UTF-16LE")) {
+                CpioArchiveEntry entry = (CpioArchiveEntry) in.getNextEntry();
+                Assert.assertNotNull(entry);
+                Assert.assertEquals("T\u00e4st.txt", entry.getName());
+                Assert.assertArrayEquals(new byte[] { 1, 2, 3, 4 }, IOUtils.toByteArray(in));
+            }
+        }
+    }
+}
