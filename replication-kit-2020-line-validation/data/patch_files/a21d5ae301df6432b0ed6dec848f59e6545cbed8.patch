From a21d5ae301df6432b0ed6dec848f59e6545cbed8 Mon Sep 17 00:00:00 2001
From: Sebastien Brisard <celestin@apache.org>
Date: Sat, 31 Dec 2011 05:18:48 +0000
Subject: [PATCH] Modifications to the hierarchy of distributions, according to
 MATH-692. Patch contributed by Christian Winter.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1226041 13f79535-47bb-0310-9956-ffa450edef68
---
 .../AbstractIntegerDistribution.java          | 143 ++++++++++--------
 .../distribution/BinomialDistribution.java    |  55 ++-----
 .../HypergeometricDistribution.java           |  12 --
 .../distribution/IntegerDistribution.java     |  72 ++++-----
 .../math/distribution/PascalDistribution.java |  49 +-----
 .../distribution/PoissonDistribution.java     |  12 --
 .../math/distribution/ZipfDistribution.java   |  14 +-
 .../commons/math/random/RandomDataImpl.java   |   8 +-
 .../AbtractIntegerDistributionTest.java       |  39 ++---
 .../BinomialDistributionTest.java             |  16 +-
 .../HypergeometricDistributionTest.java       |  31 ++--
 .../IntegerDistributionAbstractTest.java      |  20 ++-
 .../distribution/PascalDistributionTest.java  |  14 +-
 .../distribution/PoissonDistributionTest.java |  20 +--
 .../distribution/ZipfDistributionTest.java    |   6 +-
 .../apache/commons/math/random/ISAACTest.java |   2 +-
 .../commons/math/random/RandomDataTest.java   |  15 +-
 .../random/RandomGeneratorAbstractTest.java   |  93 +++++++-----
 .../commons/math/random/Well1024aTest.java    |   4 +-
 19 files changed, 286 insertions(+), 339 deletions(-)

diff --git a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
index 793f72be0f..7f87f36641 100644
--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java
@@ -20,10 +20,11 @@
 
 import org.apache.commons.math.exception.MathInternalError;
 import org.apache.commons.math.exception.NotStrictlyPositiveException;
-import org.apache.commons.math.exception.NumberIsTooSmallException;
+import org.apache.commons.math.exception.NumberIsTooLargeException;
 import org.apache.commons.math.exception.OutOfRangeException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.random.RandomDataImpl;
+import org.apache.commons.math.util.FastMath;
 
 /**
  * Base class for integer-valued discrete distributions.  Default
@@ -49,85 +50,105 @@ protected AbstractIntegerDistribution() { }
      * {@inheritDoc}
      *
      * The default implementation uses the identity
-     * <p>{@code P(x0 <= X <= x1) = P(X <= x1) - P(X <= x0 - 1)}</p>
+     * <p>{@code P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)}</p>
      */
-    public double cumulativeProbability(int x0, int x1) {
+    public double cumulativeProbability(int x0, int x1) throws NumberIsTooLargeException {
         if (x1 < x0) {
-            throw new NumberIsTooSmallException(
-                    LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,
-                    x1, x0, true);
+            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT,
+                    x0, x1, true);
         }
-        return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);
+        return cumulativeProbability(x1) - cumulativeProbability(x0);
     }
 
-    /** {@inheritDoc} */
-    public int inverseCumulativeProbability(final double p) {
-        if (p < 0 || p > 1) {
+    /**
+     * {@inheritDoc}
+     *
+     * The default implementation returns
+     * <ul>
+     * <li>{@link #getSupportLowerBound()} for {@code p = 0},</li>
+     * <li>{@link #getSupportUpperBound()} for {@code p = 1}, and</li>
+     * <li>{@link #solveInverseCumulativeProbability(double, int, int)} for
+     *     {@code 0 < p < 1}.</li>
+     * </ul>
+     */
+    public int inverseCumulativeProbability(final double p) throws OutOfRangeException {
+        if (p < 0.0 || p > 1.0) {
             throw new OutOfRangeException(p, 0, 1);
         }
 
-        // by default, do simple bisection.
-        // subclasses can override if there is a better method.
-        int x0 = getDomainLowerBound(p);
-        int x1 = getDomainUpperBound(p);
-        double pm;
-        while (x0 < x1) {
-            int xm = x0 + (x1 - x0) / 2;
-            pm = checkedCumulativeProbability(xm);
-            if (pm > p) {
-                // update x1
-                if (xm == x1) {
-                    // this can happen with integer division
-                    // simply decrement x1
-                    --x1;
-                } else {
-                    // update x1 normally
-                    x1 = xm;
-                }
-            } else {
-                // update x0
-                if (xm == x0) {
-                    // this can happen with integer division
-                    // simply increment x0
-                    ++x0;
-                } else {
-                    // update x0 normally
-                    x0 = xm;
-                }
+        int lower = getSupportLowerBound();
+        if (p == 0.0) {
+            return lower;
+        }
+        if (lower == Integer.MIN_VALUE) {
+            if (checkedCumulativeProbability(lower) >= p) {
+                return lower;
             }
+        } else {
+            lower -= 1; // this ensures cumulativeProbability(lower) < p, which
+                        // is important for the solving step
         }
 
-        // insure x0 is the correct critical point
-        pm = checkedCumulativeProbability(x0);
-        while (pm > p) {
-            --x0;
-            pm = checkedCumulativeProbability(x0);
+        int upper = getSupportUpperBound();
+        if (p == 1.0) {
+            return upper;
         }
 
-        return x0;
+        // use the one-sided Chebyshev inequality to narrow the bracket
+        // cf. AbstractRealDistribution.inverseCumulativeProbability(double)
+        final double mu = getNumericalMean();
+        final double sigma = FastMath.sqrt(getNumericalVariance());
+        final boolean chebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||
+                Double.isInfinite(sigma) || Double.isNaN(sigma) || sigma == 0.0);
+        if (chebyshevApplies) {
+            double k = FastMath.sqrt((1.0 - p) / p);
+            double tmp = mu - k * sigma;
+            if (tmp > lower) {
+                lower = ((int) Math.ceil(tmp)) - 1;
+            }
+            k = 1.0 / k;
+            tmp = mu + k * sigma;
+            if (tmp < upper) {
+                upper = ((int) Math.ceil(tmp)) - 1;
+            }
+        }
+
+        return solveInverseCumulativeProbability(p, lower, upper);
     }
 
     /**
-     * Access the domain value lower bound, based on {@code p}, used to
-     * bracket a CDF root. This method is used by
-     * {@link #inverseCumulativeProbability(double)} to find critical values.
+     * This is a utility function used by {@link
+     * #inverseCumulativeProbability(double)}. It assumes {@code 0 < p < 1} and
+     * that the inverse cumulative probability lies in the bracket {@code
+     * (lower, upper]}. The implementation does simple bisection to find the
+     * smallest {@code p}-quantile <code>inf{x in Z | P(X<=x) >= p}</code>.
      *
-     * @param p the desired probability for the critical value ({@code 0 < p < 1})
-     * @return a domain value lower bound, i.e. a value {@code x} such that
-     * {@code P(X <= x) < p}
+     * @param p the cumulative probability
+     * @param lower a value satisfying {@code cumulativeProbability(lower) < p}
+     * @param upper a value satisfying {@code p <= cumulativeProbability(upper)}
+     * @return the smallest {@code p}-quantile of this distribution
      */
-    protected abstract int getDomainLowerBound(double p);
+    protected int solveInverseCumulativeProbability(final double p, int lower, int upper) {
+        while (lower + 1 < upper) {
+            int xm = (lower + upper) / 2;
+            if (xm < lower || xm > upper) {
+                /*
+                 * Overflow.
+                 * There will never be an overflow in both calculation methods
+                 * for xm at the same time
+                 */
+                xm = lower + (upper - lower) / 2;
+            }
 
-    /**
-     * Access the domain value upper bound, based on {@code p}, used to
-     * bracket a CDF root. This method is used by
-     * {@link #inverseCumulativeProbability(double)} to find critical values.
-     *
-     * @param p the desired probability for the critical value ({@code 0 < p < 1})
-     * @return a domain value upper bound, i.e. a value {@code x} such that
-     * {@code P(X <= x) >= p}
-     */
-    protected abstract int getDomainUpperBound(double p);
+            double pm = checkedCumulativeProbability(xm);
+            if (pm >= p) {
+                upper = xm;
+            } else {
+                lower = xm;
+            }
+        }
+        return upper;
+    }
 
     /** {@inheritDoc} */
     public void reseedRandomGenerator(long seed) {
diff --git a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java
index 3d6cc39a7f..906592b563 100644
--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java
@@ -98,44 +98,12 @@ public double cumulativeProbability(int x) {
         } else if (x >= numberOfTrials) {
             ret = 1.0;
         } else {
-            ret = 1.0 - Beta.regularizedBeta(getProbabilityOfSuccess(),
+            ret = 1.0 - Beta.regularizedBeta(probabilityOfSuccess,
                     x + 1.0, numberOfTrials - x);
         }
         return ret;
     }
 
-    /**
-     * {@inheritDoc}
-     *
-     * This implementation return -1 when {@code p == 0} and
-     * {@code Integer.MAX_VALUE} when {@code p == 1}.
-     */
-    @Override
-    public int inverseCumulativeProbability(final double p) {
-        // handle extreme values explicitly
-        if (p == 0) {
-            return -1;
-        }
-        if (p == 1) {
-            return Integer.MAX_VALUE;
-        }
-
-        // use default bisection impl
-        return super.inverseCumulativeProbability(p);
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainLowerBound(double p) {
-        return -1;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainUpperBound(double p) {
-        return numberOfTrials;
-    }
-
     /**
      * {@inheritDoc}
      *
@@ -143,7 +111,7 @@ protected int getDomainUpperBound(double p) {
      * {@code n * p}.
      */
     public double getNumericalMean() {
-        return getNumberOfTrials() * getProbabilityOfSuccess();
+        return numberOfTrials * probabilityOfSuccess;
     }
 
     /**
@@ -153,31 +121,32 @@ public double getNumericalMean() {
      * {@code n * p * (1 - p)}.
      */
     public double getNumericalVariance() {
-        final double p = getProbabilityOfSuccess();
-        return getNumberOfTrials() * p * (1 - p);
+        final double p = probabilityOfSuccess;
+        return numberOfTrials * p * (1 - p);
     }
 
     /**
      * {@inheritDoc}
      *
-     * The lower bound of the support is always 0 no matter the number of trials
-     * and probability parameter.
+     * The lower bound of the support is always 0 except for the probability
+     * parameter {@code p = 1}.
      *
-     * @return lower bound of the support (always 0)
+     * @return lower bound of the support (0 or the number of trials)
      */
     public int getSupportLowerBound() {
-        return 0;
+        return probabilityOfSuccess < 1.0 ? 0 : numberOfTrials;
     }
 
     /**
      * {@inheritDoc}
      *
-     * The upper bound of the support is the number of trials.
+     * The upper bound of the support is the number of trials except for the
+     * probability parameter {@code p = 0}.
      *
-     * @return upper bound of the support (equal to number of trials)
+     * @return upper bound of the support (number of trials or 0)
      */
     public int getSupportUpperBound() {
-        return getNumberOfTrials();
+        return probabilityOfSuccess > 0.0 ? numberOfTrials : 0;
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java
index 99cb892f8e..0217c96518 100644
--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java
@@ -121,18 +121,6 @@ private int[] getDomain(int n, int m, int k) {
         return new int[] { getLowerDomain(n, m, k), getUpperDomain(m, k) };
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainLowerBound(double p) {
-        return getLowerDomain(populationSize, numberOfSuccesses, sampleSize);
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainUpperBound(double p) {
-        return getUpperDomain(sampleSize, numberOfSuccesses);
-    }
-
     /**
      * Return the lowest domain value for the given hypergeometric distribution
      * parameters.
diff --git a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java
index b0d9c66650..c18d381448 100644
--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java
@@ -16,6 +16,9 @@
  */
 package org.apache.commons.math.distribution;
 
+import org.apache.commons.math.exception.NumberIsTooLargeException;
+import org.apache.commons.math.exception.OutOfRangeException;
+
 /**
  * Interface for distributions on the integers.
  *
@@ -25,61 +28,56 @@ public interface IntegerDistribution {
     /**
      * For a random variable {@code X} whose values are distributed according
      * to this distribution, this method returns {@code P(X = x)}. In other
-     * words, this method represents the probability mass function for the
-     * distribution.
+     * words, this method represents the probability mass function (PMF)
+     * for the distribution.
      *
-     * @param x the point at which the probability density function is evaluated.
-     * @return the value of the probability density function at {@code x}
+     * @param x the point at which the PMF is evaluated
+     * @return the value of the probability mass function at {@code x}
      */
     double probability(int x);
 
     /**
      * For a random variable {@code X} whose values are distributed according
      * to this distribution, this method returns {@code P(X <= x)}.  In other
-     * words, this method represents the probability distribution function, or
-     * PDF for the distribution.
+     * words, this method represents the (cumulative) distribution function
+     * (CDF) for this distribution.
      *
-     * @param x the point at which the PDF is evaluated
-     * @return PDF for this distribution.
+     * @param x the point at which the CDF is evaluated
+     * @return the probability that a random variable with this
+     * distribution takes a value less than or equal to {@code x}
      */
     double cumulativeProbability(int x);
 
     /**
      * For a random variable {@code X} whose values are distributed according
-     * to this distribution, this method returns {@code P(x0 <= X <= x1)}.
+     * to this distribution, this method returns {@code P(x0 < X <= x1)}.
      *
-     * @param x0 the inclusive lower bound
+     * @param x0 the exclusive lower bound
      * @param x1 the inclusive upper bound
-     * @return the cumulative probability
-     * @throws IllegalArgumentException if {@code x0 > x1}
+     * @return the probability that a random variable with this distribution
+     * will take a value between {@code x0} and {@code x1},
+     * excluding the lower and including the upper endpoint
+     * @throws NumberIsTooLargeException if {@code x0 > x1}
      */
-    double cumulativeProbability(int x0, int x1);
+    double cumulativeProbability(int x0, int x1) throws NumberIsTooLargeException;
 
     /**
-     * For this distribution, {@code X}, this method returns the largest
-     * {@code x} such that {@code P(X <= x) <= p}.
-     * <br/>
-     * Note that this definition implies:
+     * Computes the quantile function of this distribution.
+     * For a random variable {@code X} distributed according to this distribution,
+     * the returned value is
      * <ul>
-     *  <li> If there is a minimum value, {@code m}, with positive
-     *   probability under (the density of) {@code X}, then {@code m - 1} is
-     *   returned by {@code inverseCumulativeProbability(0).}  If there is
-     *   no such value {@code m},  {@code Integer.MIN_VALUE} is returned.
-     *  </li>
-     *  <li> If there is a maximum value, {@code M}, such that
-     *   {@code P(X <= M) = 1}, then {@code M} is returned by
-     *   {@code inverseCumulativeProbability(1)}.
-     *   If there is no such value, {@code M}, {@code Integer.MAX_VALUE} is
-     *   returned.
-     *  </li>
+     * <li><code>inf{x in Z | P(X<=x) >= p}</code> for {@code 0 < p <= 1},</li>
+     * <li><code>inf{x in Z | P(X<=x) > 0}</code> for {@code p = 0}.</li>
      * </ul>
+     * If the result exceeds the range of the data type {@code int},
+     * then {@code Integer.MIN_VALUE} or {@code Integer.MAX_VALUE} is returned.
      *
      * @param p the cumulative probability
-     * @return the largest {@code x} such that {@code P(X < x) <= p}
-     * @throws IllegalArgumentException if {@code p} is not between 0 and 1
-     * (inclusive)
+     * @return the smallest {@code p}-quantile of this distribution
+     * (largest 0-quantile for {@code p = 0})
+     * @throws OutOfRangeException if {@code p < 0} or {@code p > 1}
      */
-    int inverseCumulativeProbability(double p);
+    int inverseCumulativeProbability(double p) throws OutOfRangeException;
 
     /**
      * Use this method to get the numerical value of the mean of this
@@ -99,7 +97,10 @@ public interface IntegerDistribution {
     double getNumericalVariance();
 
     /**
-     * Access the lower bound of the support.
+     * Access the lower bound of the support. This method must return the same
+     * value as {@code inverseCumulativeProbability(0)}. In other words, this
+     * method must return
+     * <p><code>inf {x in Z | P(X <= x) > 0}</code>.</p>
      *
      * @return lower bound of the support ({@code Integer.MIN_VALUE}
      * for negative infinity)
@@ -107,7 +108,10 @@ public interface IntegerDistribution {
     int getSupportLowerBound();
 
     /**
-     * Access the upper bound of the support.
+     * Access the upper bound of the support. This method must return the same
+     * value as {@code inverseCumulativeProbability(1)}. In other words, this
+     * method must return
+     * <p><code>inf {x in R | P(X <= x) = 1}</code>.</p>
      *
      * @return upper bound of the support ({@code Integer.MAX_VALUE}
      * for positive infinity)
diff --git a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java
index 3170b574c4..57d79f714e 100644
--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java
@@ -16,8 +16,8 @@
  */
 package org.apache.commons.math.distribution;
 
+import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.OutOfRangeException;
-import org.apache.commons.math.exception.NotPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.special.Beta;
 import org.apache.commons.math.util.ArithmeticUtils;
@@ -68,19 +68,19 @@ public class PascalDistribution extends AbstractIntegerDistribution {
     private final double probabilityOfSuccess;
 
     /**
-     * Create a Pascal distribution with the given number of trials and
+     * Create a Pascal distribution with the given number of successes and
      * probability of success.
      *
      * @param r Number of successes.
      * @param p Probability of success.
-     * @throws NotPositiveException if the number of successes is not positive
+     * @throws NotStrictlyPositiveException if the number of successes is not positive
      * @throws OutOfRangeException if the probability of success is not in the
      * range [0, 1]
      */
     public PascalDistribution(int r, double p)
-        throws NotPositiveException, OutOfRangeException {
-        if (r < 0) {
-            throw new NotPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,
+        throws NotStrictlyPositiveException, OutOfRangeException {
+        if (r <= 0) {
+            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SUCCESSES,
                                            r);
         }
         if (p < 0 || p > 1) {
@@ -135,41 +135,6 @@ public double cumulativeProbability(int x) {
         return ret;
     }
 
-    /**
-     * {@inheritDoc}
-     *
-     * Returns {@code -1} when {@code p == 0} and
-     * {@code Integer.MAX_VALUE} when {@code p == 1}.
-     */
-    @Override
-    public int inverseCumulativeProbability(final double p) {
-        int ret;
-
-        // handle extreme values explicitly
-        if (p == 0) {
-            ret = -1;
-        } else if (p == 1) {
-            ret = Integer.MAX_VALUE;
-        } else {
-            ret = super.inverseCumulativeProbability(p);
-        }
-
-        return ret;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainLowerBound(double p) {
-        return -1;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainUpperBound(double p) {
-        // use MAX - 1 because MAX causes loop
-        return Integer.MAX_VALUE - 1;
-    }
-
     /**
      * {@inheritDoc}
      *
@@ -209,7 +174,7 @@ public int getSupportLowerBound() {
      * {@inheritDoc}
      *
      * The upper bound of the support is always positive infinity no matter the
-     * parameters. Positive infinity is symbolised by {@code Integer.MAX_VALUE}.
+     * parameters. Positive infinity is symbolized by {@code Integer.MAX_VALUE}.
      *
      * @return upper bound of the support (always {@code Integer.MAX_VALUE}
      * for positive infinity)
diff --git a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java
index 73534486af..0fafe65eeb 100644
--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java
@@ -174,18 +174,6 @@ public double normalApproximateProbability(int x)  {
         return normal.cumulativeProbability(x + 0.5);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainLowerBound(double p) {
-        return 0;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainUpperBound(double p) {
-        return Integer.MAX_VALUE;
-    }
-
     /**
      * {@inheritDoc}
      *
diff --git a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java
index ea12588154..dfa34417fc 100644
--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java
+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java
@@ -111,18 +111,6 @@ public double cumulativeProbability(final int x) {
         return generalizedHarmonic(x, exponent) / generalizedHarmonic(numberOfElements, exponent);
     }
 
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainLowerBound(final double p) {
-        return 0;
-    }
-
-    /** {@inheritDoc} */
-    @Override
-    protected int getDomainUpperBound(final double p) {
-        return numberOfElements;
-    }
-
     /**
      * {@inheritDoc}
      *
@@ -176,7 +164,7 @@ public double getNumericalVariance() {
     }
 
     /**
-     * used by {@link #getNumericalVariance()}
+     * Used by {@link #getNumericalVariance()}.
      *
      * @return the variance of this distribution
      */
diff --git a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java
index 908c47dbf6..237e92306b 100644
--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java
+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java
@@ -1076,13 +1076,7 @@ public double nextInversionDeviate(RealDistribution distribution) {
      * @since 2.2
      */
     public int nextInversionDeviate(IntegerDistribution distribution) {
-        final double target = nextUniform(0, 1);
-        final int glb = distribution.inverseCumulativeProbability(target);
-        if (distribution.cumulativeProbability(glb) == 1.0d) { // No mass above
-            return glb;
-        } else {
-            return glb + 1;
-        }
+        return distribution.inverseCumulativeProbability(nextUniform(0, 1));
     }
 
     // ------------------------Private methods----------------------------------
diff --git a/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java
index 6ea177b212..615f405ed1 100644
--- a/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/AbtractIntegerDistributionTest.java
@@ -25,40 +25,37 @@
  * @version $Id$
  */
 public class AbtractIntegerDistributionTest {
-
     protected final DiceDistribution diceDistribution = new DiceDistribution();
     protected final double p = diceDistribution.probability(1);
-    
+
     @Test
-    public void testCumulativeProbabilitiesSingleIntegerArguments() throws Exception {
-        int lower = 1;
+    public void testCumulativeProbabilitiesSingleArguments() throws Exception {
         for (int i = 1; i < 7; i++) {
             Assert.assertEquals(p * i,
-                    diceDistribution.cumulativeProbability(lower), Double.MIN_VALUE);
-            lower++;
+                    diceDistribution.cumulativeProbability(i), Double.MIN_VALUE);
         }
-        Assert.assertEquals(0,
-                diceDistribution.cumulativeProbability(-1), Double.MIN_VALUE);
-        Assert.assertEquals(1,
+        Assert.assertEquals(0.0,
+                diceDistribution.cumulativeProbability(0), Double.MIN_VALUE);
+        Assert.assertEquals(1.0,
                 diceDistribution.cumulativeProbability(7), Double.MIN_VALUE);
     }
-    
+
     @Test
     public void testCumulativeProbabilitiesRangeArguments() throws Exception {
-        int lower = 1;
+        int lower = 0;
         int upper = 6;
         for (int i = 0; i < 2; i++) {
-            // cum(1,6) = p(1 <= X <= 6) = 1, cum(2,5) = 4/6, cum(3,4) = 2/6 
-            Assert.assertEquals(1 - p * 2 * i, 
+            // cum(0,6) = p(0 < X <= 6) = 1, cum(1,5) = 4/6, cum(2,4) = 2/6
+            Assert.assertEquals(1 - p * 2 * i,
                     diceDistribution.cumulativeProbability(lower, upper), 1E-12);
             lower++;
             upper--;
         }
-        for (int i = 1; i < 7; i++) {
-            Assert.assertEquals(p, diceDistribution.cumulativeProbability(i, i), 1E-12);
+        for (int i = 0; i < 6; i++) {
+            Assert.assertEquals(p, diceDistribution.cumulativeProbability(i, i+1), 1E-12);
         }
     }
-    
+
     /**
      * Simple distribution modeling a 6-sided die
      */
@@ -85,16 +82,6 @@ public double cumulativeProbability(int x) {
             }
         }
 
-        @Override
-        protected int getDomainLowerBound(double p) {
-            return 1;
-        }
-
-        @Override
-        protected int getDomainUpperBound(double p) {
-            return 6;
-        }
-
         public double getNumericalMean() {
             return 3.5;
         }
diff --git a/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java
index 408559ec6f..65cdc3f04c 100644
--- a/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java
@@ -74,7 +74,7 @@ public double[] makeInverseCumulativeTestPoints() {
      */
     @Override
     public int[] makeInverseCumulativeTestValues() {
-        return new int[] { -1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE };
+        return new int[] { 0, 2, 3, 4, 5, 5, 10, 10, 10, 9, 9, 10 };
     }
 
     // ----------------- Additional test cases ---------------------------------
@@ -82,31 +82,37 @@ public int[] makeInverseCumulativeTestValues() {
     /** Test degenerate case p = 0 */
     @Test
     public void testDegenerate0() throws Exception {
-        setDistribution(new BinomialDistribution(5, 0.0d));
+        BinomialDistribution dist = new BinomialDistribution(5, 0.0d);
+        setDistribution(dist);
         setCumulativeTestPoints(new int[] { -1, 0, 1, 5, 10 });
         setCumulativeTestValues(new double[] { 0d, 1d, 1d, 1d, 1d });
         setDensityTestPoints(new int[] { -1, 0, 1, 10, 11 });
         setDensityTestValues(new double[] { 0d, 1d, 0d, 0d, 0d });
         setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });
-        setInverseCumulativeTestValues(new int[] { -1, -1 });
+        setInverseCumulativeTestValues(new int[] { 0, 0 });
         verifyDensities();
         verifyCumulativeProbabilities();
         verifyInverseCumulativeProbabilities();
+        Assert.assertEquals(dist.getSupportLowerBound(), 0);
+        Assert.assertEquals(dist.getSupportUpperBound(), 0);
     }
 
     /** Test degenerate case p = 1 */
     @Test
     public void testDegenerate1() throws Exception {
-        setDistribution(new BinomialDistribution(5, 1.0d));
+        BinomialDistribution dist = new BinomialDistribution(5, 1.0d);
+        setDistribution(dist);
         setCumulativeTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });
         setCumulativeTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 1d });
         setDensityTestPoints(new int[] { -1, 0, 1, 2, 5, 10 });
         setDensityTestValues(new double[] { 0d, 0d, 0d, 0d, 1d, 0d });
         setInverseCumulativeTestPoints(new double[] { 0.1d, 0.5d });
-        setInverseCumulativeTestValues(new int[] { 4, 4 });
+        setInverseCumulativeTestValues(new int[] { 5, 5 });
         verifyDensities();
         verifyCumulativeProbabilities();
         verifyInverseCumulativeProbabilities();
+        Assert.assertEquals(dist.getSupportLowerBound(), 5);
+        Assert.assertEquals(dist.getSupportUpperBound(), 5);
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java
index 7fea4bc064..97dfa67302 100644
--- a/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java
@@ -38,7 +38,7 @@ public class HypergeometricDistributionTest extends IntegerDistributionAbstractT
     /** Creates the default discrete distribution instance to use in tests. */
     @Override
     public IntegerDistribution makeDistribution() {
-        return new HypergeometricDistribution(10,5, 5);
+        return new HypergeometricDistribution(10, 5, 5);
     }
 
     /** Creates the default probability density test input values */
@@ -77,7 +77,7 @@ public double[] makeInverseCumulativeTestPoints() {
     /** Creates the default inverse cumulative probability density test expected values */
     @Override
     public int[] makeInverseCumulativeTestValues() {
-        return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};
+        return new int[] {0, 0, 1, 1, 1, 1, 5, 4, 4, 4, 4, 5};
     }
 
     //-------------------- Additional test cases ------------------------------
@@ -85,46 +85,55 @@ public int[] makeInverseCumulativeTestValues() {
     /** Verify that if there are no failures, mass is concentrated on sampleSize */
     @Test
     public void testDegenerateNoFailures() throws Exception {
-        setDistribution(new HypergeometricDistribution(5,5,3));
+        HypergeometricDistribution dist = new HypergeometricDistribution(5,5,3);
+        setDistribution(dist);
         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
         setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
         setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
-        setInverseCumulativeTestValues(new int[] {2, 2});
+        setInverseCumulativeTestValues(new int[] {3, 3});
         verifyDensities();
         verifyCumulativeProbabilities();
         verifyInverseCumulativeProbabilities();
+        Assert.assertEquals(dist.getSupportLowerBound(), 3);
+        Assert.assertEquals(dist.getSupportUpperBound(), 3);
     }
 
     /** Verify that if there are no successes, mass is concentrated on 0 */
     @Test
     public void testDegenerateNoSuccesses() throws Exception {
-        setDistribution(new HypergeometricDistribution(5,0,3));
+        HypergeometricDistribution dist = new HypergeometricDistribution(5,0,3);
+        setDistribution(dist);
         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
         setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d});
         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
         setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d});
         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
-        setInverseCumulativeTestValues(new int[] {-1, -1});
+        setInverseCumulativeTestValues(new int[] {0, 0});
         verifyDensities();
         verifyCumulativeProbabilities();
         verifyInverseCumulativeProbabilities();
+        Assert.assertEquals(dist.getSupportLowerBound(), 0);
+        Assert.assertEquals(dist.getSupportUpperBound(), 0);
     }
 
     /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */
     @Test
     public void testDegenerateFullSample() throws Exception {
-        setDistribution(new HypergeometricDistribution(5,3,5));
+        HypergeometricDistribution dist = new HypergeometricDistribution(5,3,5);
+        setDistribution(dist);
         setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 });
         setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d});
         setDensityTestPoints(new int[] {-1, 0, 1, 3, 10});
         setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d});
         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
-        setInverseCumulativeTestValues(new int[] {2, 2});
+        setInverseCumulativeTestValues(new int[] {3, 3});
         verifyDensities();
         verifyCumulativeProbabilities();
         verifyInverseCumulativeProbabilities();
+        Assert.assertEquals(dist.getSupportLowerBound(), 3);
+        Assert.assertEquals(dist.getSupportUpperBound(), 3);
     }
 
     @Test
@@ -202,9 +211,9 @@ private void testHypergeometricDistributionProbabilities(int populationSize, int
         HypergeometricDistribution dist = new HypergeometricDistribution(populationSize, numberOfSucceses, sampleSize);
         for (int i = 0; i < data.length; ++i) {
             int x = (int)data[i][0];
-            double pdf = data[i][1];
-            double actualPdf = dist.probability(x);
-            TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> pdf",pdf, actualPdf, 1.0e-9);
+            double pmf = data[i][1];
+            double actualPmf = dist.probability(x);
+            TestUtils.assertRelativelyEquals("Expected equals for <"+x+"> pmf",pmf, actualPmf, 1.0e-9);
 
             double cdf = data[i][2];
             double actualCdf = dist.cumulativeProbability(x);
diff --git a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java
index 8af4f64ddc..d8216122c2 100644
--- a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java
@@ -193,6 +193,24 @@ public void testInverseCumulativeProbabilities() throws Exception {
         verifyInverseCumulativeProbabilities();
     }
 
+    @Test
+    public void testConsistencyAtSupportBounds() {
+        final int lower = distribution.getSupportLowerBound();
+        Assert.assertEquals("Cumulative probability mmust be 0 below support lower bound.",
+                0.0, distribution.cumulativeProbability(lower - 1), 0.0);
+        Assert.assertEquals("Cumulative probability of support lower bound must be equal to probability mass at this point.",
+                distribution.probability(lower), distribution.cumulativeProbability(lower), tolerance);
+        Assert.assertEquals("Inverse cumulative probability of 0 must be equal to support lower bound.",
+                lower, distribution.inverseCumulativeProbability(0.0));
+
+        final int upper = distribution.getSupportUpperBound();
+        if (upper != Integer.MAX_VALUE)
+            Assert.assertEquals("Cumulative probability of support upper bound must be equal to 1.",
+                    1.0, distribution.cumulativeProbability(upper), 0.0);
+        Assert.assertEquals("Inverse cumulative probability of 1 must be equal to support upper bound.",
+                upper, distribution.inverseCumulativeProbability(1.0));
+    }
+
     /**
      * Verifies that illegal arguments are correctly handled
      */
@@ -217,7 +235,7 @@ public void testIllegalArguments() throws Exception {
             // expected
         }
     }
-    
+
     /**
      * Test sampling
      */
diff --git a/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java
index 0ec7b73a22..691f7e9b1e 100644
--- a/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java
@@ -75,14 +75,14 @@ public double[] makeCumulativeTestValues() {
     /** Creates the default inverse cumulative probability test input values */
     @Override
     public double[] makeInverseCumulativeTestPoints() {
-      return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,
-          0.990d, 0.975d, 0.950d, 0.900d, 1};
+      return new double[] {0.0, 0.001, 0.010, 0.025, 0.050, 0.100, 0.999,
+          0.990, 0.975, 0.950, 0.900, 1.0};
         }
 
     /** Creates the default inverse cumulative probability density test expected values */
     @Override
     public int[] makeInverseCumulativeTestValues() {
-      return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE};
+      return new int[] {0, 0, 0, 0, 1, 1, 14, 11, 10, 9, 8, Integer.MAX_VALUE};
     }
 
     //----------------- Additional test cases ---------------------------------
@@ -90,13 +90,13 @@ public int[] makeInverseCumulativeTestValues() {
     /** Test degenerate case p = 0   */
     @Test
     public void testDegenerate0() throws Exception {
-        setDistribution(new PascalDistribution(5,0.0d));
+        setDistribution(new PascalDistribution(5, 0.0d));
         setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 });
         setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
         setDensityTestPoints(new int[] {-1, 0, 1, 10, 11});
         setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d});
         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
-        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});
+        setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE, Integer.MAX_VALUE});
         verifyDensities();
         verifyCumulativeProbabilities();
         verifyInverseCumulativeProbabilities();
@@ -105,13 +105,13 @@ public void testDegenerate0() throws Exception {
     /** Test degenerate case p = 1   */
     @Test
     public void testDegenerate1() throws Exception {
-        setDistribution(new PascalDistribution(5,1.0d));
+        setDistribution(new PascalDistribution(5, 1.0d));
         setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 });
         setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d});
         setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10});
         setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d});
         setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d});
-        setInverseCumulativeTestValues(new int[] {-1, -1});
+        setInverseCumulativeTestValues(new int[] {0, 0});
         verifyDensities();
         verifyCumulativeProbabilities();
         verifyInverseCumulativeProbabilities();
diff --git a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java
index 52a89b9625..c57ae7ba30 100644
--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java
@@ -87,15 +87,15 @@ public double[] makeCumulativeTestValues() {
 
     /**
      * Creates the default inverse cumulative probability test input values.
-     * Increased 3rd and 7th values slightly as computed cumulative
-     * probabilities for corresponding values exceeds the target value (still
-     * within tolerance).
      */
     @Override
     public double[] makeInverseCumulativeTestPoints() {
-        return new double[] { 0d,  0.018315638889d, 0.0915781944437d,
-                0.238103305554d, 0.433470120367d, 0.62883693518,
-                0.78513038704d,  0.99716023388d, 0.999999998077 };
+        IntegerDistribution dist = getDistribution();
+        return new double[] { 0d, 0.018315638886d, 0.018315638890d,
+                0.091578194441d, 0.091578194445d, 0.238103305552d,
+                0.238103305556d, dist.cumulativeProbability(3),
+                dist.cumulativeProbability(4), dist.cumulativeProbability(5),
+                dist.cumulativeProbability(10), dist.cumulativeProbability(20)};
     }
 
     /**
@@ -103,7 +103,7 @@ public double[] makeInverseCumulativeTestPoints() {
      */
     @Override
     public int[] makeInverseCumulativeTestValues() {
-        return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20};
+        return new int[] { 0, 0, 1, 1, 2, 2, 3, 3, 4, 5, 10, 20};
     }
 
     /**
@@ -132,7 +132,7 @@ public void testNormalApproximateProbability() throws Exception {
     public void testDegenerateInverseCumulativeProbability() throws Exception {
         PoissonDistribution dist = new PoissonDistribution(DEFAULT_TEST_POISSON_PARAMETER);
         Assert.assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));
-        Assert.assertEquals(-1, dist.inverseCumulativeProbability(0d));
+        Assert.assertEquals(0, dist.inverseCumulativeProbability(0d));
     }
 
     @Test(expected=NotStrictlyPositiveException.class)
@@ -209,8 +209,8 @@ public void testLargeMeanInverseCumulativeProbability() throws Exception {
                 try {
                     int ret = dist.inverseCumulativeProbability(p);
                     // Verify that returned value satisties definition
-                    Assert.assertTrue(p >= dist.cumulativeProbability(ret));
-                    Assert.assertTrue(p < dist.cumulativeProbability(ret + 1));
+                    Assert.assertTrue(p <= dist.cumulativeProbability(ret));
+                    Assert.assertTrue(p > dist.cumulativeProbability(ret - 1));
                 } catch (Exception ex) {
                     Assert.fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage());
                 }
diff --git a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java
index f6c963e811..07e22e1ed7 100644
--- a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java
+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java
@@ -79,14 +79,14 @@ public double[] makeCumulativeTestValues() {
     /** Creates the default inverse cumulative probability test input values */
     @Override
     public double[] makeInverseCumulativeTestPoints() {
-        return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.3414d, 0.3415d, 0.999d,
-                0.990d, 0.975d, 0.950d, 0.900d, 1};
+        return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.3413d, 0.3415d, 0.999d,
+                0.990d, 0.975d, 0.950d, 0.900d, 1d};
         }
 
     /** Creates the default inverse cumulative probability density test expected values */
     @Override
     public int[] makeInverseCumulativeTestValues() {
-        return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};
+        return new int[] {1, 1, 1, 1, 1, 1, 2, 10, 10, 10, 9, 8, 10};
     }
 
     @Test
diff --git a/src/test/java/org/apache/commons/math/random/ISAACTest.java b/src/test/java/org/apache/commons/math/random/ISAACTest.java
index 61eeb4fff3..d6346cc7f8 100644
--- a/src/test/java/org/apache/commons/math/random/ISAACTest.java
+++ b/src/test/java/org/apache/commons/math/random/ISAACTest.java
@@ -24,7 +24,7 @@ public final class ISAACTest extends RandomGeneratorAbstractTest {
 
     @Override
     protected RandomGenerator makeGenerator() {
-        return new ISAACRandom(1000);
+        return new ISAACRandom(500);
     }
 
     private static final int[] SEED_1 = {
diff --git a/src/test/java/org/apache/commons/math/random/RandomDataTest.java b/src/test/java/org/apache/commons/math/random/RandomDataTest.java
index 33632d857c..6d1df40533 100644
--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java
+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java
@@ -417,15 +417,15 @@ public void checkNextPoissonConsistency(double mean) throws Exception {
         }
 
         // Set bin width for interior bins.  For poisson, only need to look at end bins.
-        int binWidth = 1;
+        int binWidth = 0;
         boolean widthSufficient = false;
         double lowerBinMass = 0;
         double upperBinMass = 0;
         while (!widthSufficient) {
-            lowerBinMass = poissonDistribution.cumulativeProbability(lower, lower + binWidth - 1);
-            upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth + 1, upper);
-            widthSufficient = FastMath.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;
             binWidth++;
+            lowerBinMass = poissonDistribution.cumulativeProbability(lower - 1, lower + binWidth - 1);
+            upperBinMass = poissonDistribution.cumulativeProbability(upper - binWidth - 1, upper - 1);
+            widthSufficient = FastMath.min(lowerBinMass, upperBinMass) * sampleSize >= minExpectedCount;
         }
 
         /*
@@ -441,8 +441,7 @@ public void checkNextPoissonConsistency(double mean) throws Exception {
             binBounds.add(bound);
             bound += binWidth;
         }
-        binBounds.add(bound);
-        binBounds.add(upper);
+        binBounds.add(upper); // The size of bin [binBounds[binCount - 2], upper) satisfies binWidth <= size < 2*binWidth.
 
         // Compute observed and expected bin counts
         final int binCount = binBounds.size() + 1;
@@ -468,7 +467,7 @@ public void checkNextPoissonConsistency(double mean) throws Exception {
             observed[i] = 0;
             for (int j = binBounds.get(i - 1); j < binBounds.get(i); j++) {
                 observed[i] += frequency.getCount(j);
-            } // Expected count is (mass in [binBounds[i], binBounds[i+1])) * sampleSize
+            } // Expected count is (mass in [binBounds[i-1], binBounds[i])) * sampleSize
             expected[i] = (poissonDistribution.cumulativeProbability(binBounds.get(i) - 1) -
                 poissonDistribution.cumulativeProbability(binBounds.get(i - 1) -1)) * sampleSize;
         }
@@ -1226,7 +1225,7 @@ public void testNextZipf() throws Exception {
         }
         TestUtils.assertChiSquareAccept(densityPoints, expectedCounts, observedCounts, .001);
     }
-    
+
     @Test
     /**
      * MATH-720
diff --git a/src/test/java/org/apache/commons/math/random/RandomGeneratorAbstractTest.java b/src/test/java/org/apache/commons/math/random/RandomGeneratorAbstractTest.java
index cbbaa25a01..61707fdcb8 100644
--- a/src/test/java/org/apache/commons/math/random/RandomGeneratorAbstractTest.java
+++ b/src/test/java/org/apache/commons/math/random/RandomGeneratorAbstractTest.java
@@ -23,17 +23,17 @@
 import org.apache.commons.math.stat.descriptive.SummaryStatistics;
 import org.apache.commons.math.util.FastMath;
 import org.apache.commons.math.exception.MathIllegalArgumentException;
- 
+
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
 /**
  * Base class for RandomGenerator tests.
- * 
- * Tests RandomGenerator methods directly and also executes RandomDataTest 
+ *
+ * Tests RandomGenerator methods directly and also executes RandomDataTest
  * test cases against a RandomDataImpl created using the provided generator.
- * 
+ *
  * RandomGenerator test classes should extend this class, implementing
  * makeGenerator() to provide a concrete generator to test. The generator
  * returned by makeGenerator should be seeded with a fixed seed.
@@ -45,9 +45,9 @@ public abstract class RandomGeneratorAbstractTest extends RandomDataTest {
 
     /** RandomGenerator under test */
     protected RandomGenerator generator;
-    
-    /** 
-     * Override this method in subclasses to provide a concrete generator to test.  
+
+    /**
+     * Override this method in subclasses to provide a concrete generator to test.
      * Return a generator seeded with a fixed seed.
      */
     protected abstract RandomGenerator makeGenerator();
@@ -59,7 +59,7 @@ public RandomGeneratorAbstractTest() {
         generator = makeGenerator();
         randomData = new RandomDataImpl(generator);
     }
-    
+
     /**
      * Set a fixed seed for the tests
      */
@@ -96,7 +96,7 @@ public void testNextSecureHex() {}
      * the expected uniform distribution.  Tests are performed at the .01
      * level and an average failure rate higher than 2% (i.e. more than 20
      * null hypothesis rejections) causes the test case to fail.
-     * 
+     *
      * All random values are generated using the generator instance used by
      * other tests and the generator is not reseeded, so this is a fixed seed
      * test.
@@ -108,7 +108,7 @@ public void testNextIntDirect() throws Exception {
             final int val = generator.nextInt();
             testValues[i] = val < 0 ? -val : val + 1;
         }
-        
+
         final int numTests = 1000;
         for (int i = 0; i < testValues.length; i++) {
             final int n = testValues[i];
@@ -126,7 +126,7 @@ public void testNextIntDirect() throws Exception {
                     binUpperBounds[k] = (k + 1) * step;
                 }
                 binUpperBounds[9] = n - 1;
-            }  
+            }
             // Run the tests
             int numFailures = 0;
             final int binCount = binUpperBounds.length;
@@ -135,7 +135,7 @@ public void testNextIntDirect() throws Exception {
             expected[0] = binUpperBounds[0] == 0 ? (double) smallSampleSize / (double) n :
                 (double) ((binUpperBounds[0] + 1) * smallSampleSize) / (double) n;
             for (int k = 1; k < binCount; k++) {
-                expected[k] = (double) smallSampleSize * 
+                expected[k] = (double) smallSampleSize *
                 (double) (binUpperBounds[k] - binUpperBounds[k - 1]) / (double) n;
             }
             for (int j = 0; j < numTests; j++) {
@@ -152,7 +152,7 @@ public void testNextIntDirect() throws Exception {
                 }
                 if (testStatistic.chiSquareTest(expected, observed) < 0.01) {
                     numFailures++;
-                }  
+                }
             }
             if ((double) numFailures / (double) numTests > 0.02) {
                 Assert.fail("Too many failures for n = " + n +
@@ -160,7 +160,7 @@ public void testNextIntDirect() throws Exception {
             }
         }
     }
-    
+
     @Test(expected=MathIllegalArgumentException.class)
     public void testNextIntIAE() {
         try {
@@ -259,25 +259,27 @@ public void testNextFloatDirect() {
     @Test
     public void testDoubleDirect() {
         SummaryStatistics sample = new SummaryStatistics();
-        for (int i = 0; i < 10000; ++i) {
+        final int N = 10000;
+        for (int i = 0; i < N; ++i) {
             sample.addValue(generator.nextDouble());
         }
-        Assert.assertEquals(0.5, sample.getMean(), 0.02);
+        Assert.assertEquals("Note: This test will fail randomly about 1 in 100 times.",
+                0.5, sample.getMean(), FastMath.sqrt(N/12.0) * 2.576);
         Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),
-                     sample.getStandardDeviation(),
-                     0.01);
+                     sample.getStandardDeviation(), 0.01);
     }
 
     @Test
     public void testFloatDirect() {
         SummaryStatistics sample = new SummaryStatistics();
-        for (int i = 0; i < 1000; ++i) {
+        final int N = 1000;
+        for (int i = 0; i < N; ++i) {
             sample.addValue(generator.nextFloat());
         }
-        Assert.assertEquals(0.5, sample.getMean(), 0.01);
+        Assert.assertEquals("Note: This test will fail randomly about 1 in 100 times.",
+                0.5, sample.getMean(), FastMath.sqrt(N/12.0) * 2.576);
         Assert.assertEquals(1.0 / (2.0 * FastMath.sqrt(3.0)),
-                     sample.getStandardDeviation(),
-                     0.01);
+                     sample.getStandardDeviation(), 0.01);
     }
 
     @Test(expected=MathIllegalArgumentException.class)
@@ -288,40 +290,49 @@ public void testNextIntNeg() {
     @Test
     public void testNextInt2() {
         int walk = 0;
-        for (int k = 0; k < 10000; ++k) {
+        final int N = 10000;
+        for (int k = 0; k < N; ++k) {
            if (generator.nextInt() >= 0) {
                ++walk;
            } else {
                --walk;
            }
         }
-        Assert.assertTrue("Walked too far astray: " + walk, FastMath.abs(walk) < 120);
+        Assert.assertTrue("Walked too far astray: " + walk + "\nNote: This " +
+        		"test will fail randomly about 1 in 100 times.",
+                FastMath.abs(walk) < FastMath.sqrt(N) * 2.576);
     }
 
     @Test
     public void testNextLong2() {
         int walk = 0;
-        for (int k = 0; k < 1000; ++k) {
+        final int N = 1000;
+        for (int k = 0; k < N; ++k) {
            if (generator.nextLong() >= 0) {
                ++walk;
            } else {
                --walk;
            }
         }
-        Assert.assertTrue("Walked too far astray: " + walk, FastMath.abs(walk) < 100);
+        Assert.assertTrue("Walked too far astray: " + walk + "\nNote: This " +
+        		"test will fail randomly about 1 in 100 times.",
+                FastMath.abs(walk) < FastMath.sqrt(N) * 2.576);
     }
 
     @Test
     public void testNexBoolean2() {
         int walk = 0;
-        for (int k = 0; k < 10000; ++k) {
+        final int N = 10000;
+        for (int k = 0; k < N; ++k) {
            if (generator.nextBoolean()) {
                ++walk;
            } else {
                --walk;
            }
         }
-        Assert.assertTrue(FastMath.abs(walk) < 250);
+        Assert.assertTrue("Walked too far astray: " + walk + "\nNote: This " +
+        		"test will fail randomly about 1 in 100 times.",
+                FastMath.abs(walk) < FastMath.sqrt(N) * 2.576);
     }
 
     @Test
@@ -330,22 +341,22 @@ public void testNexBytes() throws Exception {
         byte[] bytes = new byte[10];
         double[] expected = new double[256];
         final int sampleSize = 100000;
-        
+
         for (int i = 0; i < 256; i++) {
             expected[i] = (double) sampleSize / 265f;
         }
-        
+
         for (int k = 0; k < sampleSize; ++k) {
            generator.nextBytes(bytes);
            for (byte b : bytes) {
                ++count[b + 128];
            }
         }
-        
+
         TestUtils.assertChiSquareAccept(expected, count, 0.001);
-        
+
     }
-    
+
     @Test
     public void testSeeding() throws Exception {
         // makeGenerator initializes with fixed seed
@@ -359,7 +370,7 @@ public void testSeeding() throws Exception {
         gen1.setSeed(100);
         checkSameSequence(gen, gen1);
     }
-    
+
     private void checkSameSequence(RandomGenerator gen1, RandomGenerator gen2) throws Exception {
         final int len = 11;  // Needs to be an odd number to check MATH-723
         final double[][] values = new double[2][len];
@@ -369,49 +380,49 @@ private void checkSameSequence(RandomGenerator gen1, RandomGenerator gen2) throw
         for (int i = 0; i < len; i++) {
             values[1][i] = gen2.nextDouble();
         }
-        Assert.assertTrue(Arrays.equals(values[0], values[1])); 
+        Assert.assertTrue(Arrays.equals(values[0], values[1]));
         for (int i = 0; i < len; i++) {
             values[0][i] = gen1.nextFloat();
         }
         for (int i = 0; i < len; i++) {
             values[1][i] = gen2.nextFloat();
         }
-        Assert.assertTrue(Arrays.equals(values[0], values[1])); 
+        Assert.assertTrue(Arrays.equals(values[0], values[1]));
         for (int i = 0; i < len; i++) {
             values[0][i] = gen1.nextInt();
         }
         for (int i = 0; i < len; i++) {
             values[1][i] = gen2.nextInt();
         }
-        Assert.assertTrue(Arrays.equals(values[0], values[1])); 
+        Assert.assertTrue(Arrays.equals(values[0], values[1]));
         for (int i = 0; i < len; i++) {
             values[0][i] = gen1.nextLong();
         }
         for (int i = 0; i < len; i++) {
             values[1][i] = gen2.nextLong();
         }
-        Assert.assertTrue(Arrays.equals(values[0], values[1])); 
+        Assert.assertTrue(Arrays.equals(values[0], values[1]));
         for (int i = 0; i < len; i++) {
             values[0][i] = gen1.nextInt(len);
         }
         for (int i = 0; i < len; i++) {
             values[1][i] = gen2.nextInt(len);
         }
-        Assert.assertTrue(Arrays.equals(values[0], values[1])); 
+        Assert.assertTrue(Arrays.equals(values[0], values[1]));
         for (int i = 0; i < len; i++) {
             values[0][i] = gen1.nextBoolean() ? 1 : 0;
         }
         for (int i = 0; i < len; i++) {
             values[1][i] = gen2.nextBoolean() ? 1 : 0;
         }
-        Assert.assertTrue(Arrays.equals(values[0], values[1]));  
+        Assert.assertTrue(Arrays.equals(values[0], values[1]));
         for (int i = 0; i < len; i++) {
             values[0][i] = gen1.nextGaussian();
         }
         for (int i = 0; i < len; i++) {
             values[1][i] = gen2.nextGaussian();
         }
-        Assert.assertTrue(Arrays.equals(values[0], values[1])); 
+        Assert.assertTrue(Arrays.equals(values[0], values[1]));
     }
 
 }
diff --git a/src/test/java/org/apache/commons/math/random/Well1024aTest.java b/src/test/java/org/apache/commons/math/random/Well1024aTest.java
index 05f66c804e..e8821bcc6f 100644
--- a/src/test/java/org/apache/commons/math/random/Well1024aTest.java
+++ b/src/test/java/org/apache/commons/math/random/Well1024aTest.java
@@ -24,9 +24,9 @@ public class Well1024aTest extends RandomGeneratorAbstractTest {
 
     @Override
     protected RandomGenerator makeGenerator() {
-        return new Well1024a(100);
+        return new Well1024a(1000);
     }
-    
+
     @Test
     public void testReferenceCode() {
         Well1024a mt = new Well1024a(new int[] {
