From c8ee9f781900f874b075433141de779723b3e110 Mon Sep 17 00:00:00 2001
From: Stefan Bodewig <bodewig@apache.org>
Date: Wed, 11 Jul 2018 18:50:01 +0200
Subject: [PATCH] COMPRESS-459 use ZipEncoding consistently

---
 .../archivers/cpio/CpioArchiveEntry.java      | 22 +++++++++++++------
 .../cpio/CpioArchiveOutputStream.java         |  5 ++---
 2 files changed, 17 insertions(+), 10 deletions(-)

diff --git a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java
index 79e7542dff5..6aeb7cefce3 100644
--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java
+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveEntry.java
@@ -18,11 +18,13 @@
  */
 package org.apache.commons.compress.archivers.cpio;
 
+import java.nio.ByteBuffer;
 import java.io.File;
-import java.nio.charset.Charset;
+import java.io.IOException;
 import java.util.Date;
 
 import org.apache.commons.compress.archivers.ArchiveEntry;
+import org.apache.commons.compress.archivers.zip.ZipEncoding;
 
 /**
  * A cpio archive consists of a sequence of files. There are several types of
@@ -468,7 +470,7 @@ public int getAlignmentBoundary() {
      * Get the number of bytes needed to pad the header to the alignment boundary.
      *
      * @deprecated This method doesn't properly work for multi-byte encodings. And
-     *             creates corrupt archives. Use {@link #getHeaderPadCount(Charset)}
+     *             creates corrupt archives. Use {@link #getHeaderPadCount(ZipEncoding)}
      *             or {@link #getHeaderPadCount(long)} in any case.
      * @return the number of bytes needed to pad the header (0,1,2,3)
      */
@@ -480,19 +482,25 @@ public int getHeaderPadCount(){
     /**
      * Get the number of bytes needed to pad the header to the alignment boundary.
      *
-     * @param charset
-     *             The character set used to encode the entry name in the stream.
+     * @param encoding
+     *             The encoding used to encode the entry name in the stream.
      * @return the number of bytes needed to pad the header (0,1,2,3)
      * @since 1.18
      */
-    public int getHeaderPadCount(Charset charset) {
+    public int getHeaderPadCount(ZipEncoding encoding) {
         if (name == null) {
             return 0;
         }
-        if (charset == null) {
+        if (encoding == null) {
             return getHeaderPadCount(name.length());
         }
-        return getHeaderPadCount(name.getBytes(charset).length);
+        try {
+            final ByteBuffer buf = encoding.encode(name);
+            return getHeaderPadCount(buf.limit() - buf.position());
+        } catch (IOException ex) {
+            // won't happen as the output stream has already encoded the name without error
+            throw new RuntimeException("cannot encode " + name, ex);
+        }
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
index afb57a28334..73cf71443b7 100644
--- a/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
+++ b/src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
@@ -22,7 +22,6 @@
 import java.io.IOException;
 import java.io.OutputStream;
 import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
 import java.util.Arrays;
 import java.util.HashMap;
 
@@ -305,7 +304,7 @@ private void writeNewEntry(final CpioArchiveEntry entry) throws IOException {
         writeAsciiLong(name.length + 1L, 8, 16);
         writeAsciiLong(entry.getChksum(), 8, 16);
         writeCString(name);
-        pad(entry.getHeaderPadCount(Charset.forName(encoding)));
+        pad(entry.getHeaderPadCount(zipEncoding));
     }
 
     private void writeOldAsciiEntry(final CpioArchiveEntry entry)
@@ -368,7 +367,7 @@ private void writeOldBinaryEntry(final CpioArchiveEntry entry,
         writeBinaryLong(name.length + 1L, 2, swapHalfWord);
         writeBinaryLong(entry.getSize(), 4, swapHalfWord);
         writeCString(name);
-        pad(entry.getHeaderPadCount(Charset.forName(encoding)));
+        pad(entry.getHeaderPadCount(zipEncoding));
     }
 
     /*(non-Javadoc)
