From f636e777079d6fc4dc10ac6f150e156302a71e95 Mon Sep 17 00:00:00 2001
From: Phil Steitz <psteitz@apache.org>
Date: Fri, 15 Mar 2013 04:51:34 +0000
Subject: [PATCH] Renamed Discrete*Distribution to Enumerated*Distribution,
 improved javadoc, made some exceptions more precise. JIRA: MATH-942.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1456769 13f79535-47bb-0310-9956-ffa450edef68
---
 ...ution.java => EnumeratedDistribution.java} | 111 +++++++++++-------
 ...ava => EnumeratedIntegerDistribution.java} |  68 ++++++-----
 ...n.java => EnumeratedRealDistribution.java} |  76 +++++++-----
 ...=> EnumeratedIntegerDistributionTest.java} |  43 +++----
 ...va => EnumeratedRealDistributionTest.java} |  43 +++----
 5 files changed, 194 insertions(+), 147 deletions(-)
 rename src/main/java/org/apache/commons/math3/distribution/{DiscreteDistribution.java => EnumeratedDistribution.java} (58%)
 rename src/main/java/org/apache/commons/math3/distribution/{DiscreteIntegerDistribution.java => EnumeratedIntegerDistribution.java} (70%)
 rename src/main/java/org/apache/commons/math3/distribution/{DiscreteRealDistribution.java => EnumeratedRealDistribution.java} (73%)
 rename src/test/java/org/apache/commons/math3/distribution/{DiscreteIntegerDistributionTest.java => EnumeratedIntegerDistributionTest.java} (77%)
 rename src/test/java/org/apache/commons/math3/distribution/{DiscreteRealDistributionTest.java => EnumeratedRealDistributionTest.java} (81%)

diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java b/src/main/java/org/apache/commons/math3/distribution/EnumeratedDistribution.java
similarity index 58%
rename from src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java
rename to src/main/java/org/apache/commons/math3/distribution/EnumeratedDistribution.java
index 81ec5f1d9a..96d52875b7 100644
--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java
+++ b/src/main/java/org/apache/commons/math3/distribution/EnumeratedDistribution.java
@@ -22,7 +22,8 @@
 import java.util.List;
 
 import org.apache.commons.math3.exception.MathArithmeticException;
-import org.apache.commons.math3.exception.MathIllegalArgumentException;
+import org.apache.commons.math3.exception.NotANumberException;
+import org.apache.commons.math3.exception.NotFiniteNumberException;
 import org.apache.commons.math3.exception.NotPositiveException;
 import org.apache.commons.math3.exception.NotStrictlyPositiveException;
 import org.apache.commons.math3.exception.NullArgumentException;
@@ -33,18 +34,27 @@
 import org.apache.commons.math3.util.Pair;
 
 /**
- * Generic implementation of the discrete distribution.
+ * <p>A generic implementation of a
+ * <a href="http://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution">
+ * discrete probability distribution (Wikipedia)</a> over a finite sample space,
+ * based on an enumerated list of &lt;value, probability&gt; pairs.  Input probabilities must all be non-negative,
+ * but zero values are allowed and their sum does not have to equal one. Constructors will normalize input
+ * probabilities to make them sum to one.</p>
  *
- * @param <T> type of the random variable.
- * @see <a href="http://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution">Discrete probability distribution (Wikipedia)</a>
- * @see <a href="http://mathworld.wolfram.com/DiscreteDistribution.html">Discrete Distribution (MathWorld)</a>
+ * <p>The list of <value, probability> pairs does not, strictly speaking, have to be a function and it can
+ * contain null values.  The pmf created by the constructor will combine probabilities of equal values and
+ * will treat null values as equal.  For example, if the list of pairs &lt;"dog", 0.2&gt;, &lt;null, 0.1&gt;,
+ * &lt;"pig", 0.2&gt;, &lt;"dog", 0.1&gt;, &lt;null, 0.4&gt; is provided to the constructor, the resulting
+ * pmf will assign mass of 0.5 to null, 0.3 to "dog" and 0.2 to null.</p>
+ *
+ * @param <T> type of the elements in the sample space.
  * @version $Id$
  * @since 3.2
  */
-public class DiscreteDistribution<T> implements Serializable {
+public class EnumeratedDistribution<T> implements Serializable {
 
     /** Serializable UID. */
-    private static final long serialVersionUID = -6817222602957985244L;
+    private static final long serialVersionUID = 20123308L;
 
     /**
      * RNG instance used to generate samples from the distribution.
@@ -55,56 +65,62 @@ public class DiscreteDistribution<T> implements Serializable {
      * List of random variable values.
      */
     private final List<T> singletons;
-
     /**
-     * Normalized array of probabilities of respective random variable values.
+     * Probabilities of respective random variable values. For i = 0, ..., singletons.size() - 1,
+     * probability[i] is the probability that a random variable following this distribution takes
+     * the value singletons[i].
      */
     private final double[] probabilities;
 
     /**
-     * Create a discrete distribution using the given probability mass function
-     * definition.
+     * Create an enumerated distribution using the given probability mass function
+     * enumeration.
      *
-     * @param samples definition of probability mass function in the format of
-     * list of pairs.
-     * @throws NotPositiveException if probability of at least one value is
-     * negative.
-     * @throws MathArithmeticException if the probabilities sum to zero.
-     * @throws MathIllegalArgumentException if probability of at least one value
-     * is infinite.
+     * @param pmf probability mass function enumerated as a list of <T, probability>
+     * pairs.
+     * @throws NotPositiveException if any of the probabilities are negative.
+     * @throws NotFiniteNumberException if any of the probabilities are infinite.
+     * @throws NotANumberException if any of the probabilities are NaN.
+     * @throws MathArithmeticException all of the probabilities are 0.
      */
-    public DiscreteDistribution(final List<Pair<T, Double>> samples)
-        throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
-        this(new Well19937c(), samples);
+    public EnumeratedDistribution(final List<Pair<T, Double>> pmf)
+        throws NotPositiveException, MathArithmeticException, NotFiniteNumberException, NotANumberException {
+        this(new Well19937c(), pmf);
     }
 
     /**
-     * Create a discrete distribution using the given random number generator
-     * and probability mass function definition.
+     * Create an enumerated distribution using the given random number generator
+     * and probability mass function enumeration.
      *
      * @param rng random number generator.
-     * @param samples definition of probability mass function in the format of
-     * list of pairs.
-     * @throws NotPositiveException if probability of at least one value is
-     * negative.
-     * @throws MathArithmeticException if the probabilities sum to zero.
-     * @throws MathIllegalArgumentException if probability of at least one value
-     * is infinite.
+     * @param pmf probability mass function enumerated as a list of <T, probability>
+     * pairs.
+     * @throws NotPositiveException if any of the probabilities are negative.
+     * @throws NotFiniteNumberException if any of the probabilities are infinite.
+     * @throws NotANumberException if any of the probabilities are NaN.
+     * @throws MathArithmeticException all of the probabilities are 0.
      */
-    public DiscreteDistribution(final RandomGenerator rng, final List<Pair<T, Double>> samples)
-        throws NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
+    public EnumeratedDistribution(final RandomGenerator rng, final List<Pair<T, Double>> pmf)
+        throws NotPositiveException, MathArithmeticException, NotFiniteNumberException, NotANumberException {
         random = rng;
 
-        singletons = new ArrayList<T>(samples.size());
-        final double[] probs = new double[samples.size()];
+        singletons = new ArrayList<T>(pmf.size());
+        final double[] probs = new double[pmf.size()];
 
-        for (int i = 0; i < samples.size(); i++) {
-            final Pair<T, Double> sample = samples.get(i);
+        for (int i = 0; i < pmf.size(); i++) {
+            final Pair<T, Double> sample = pmf.get(i);
             singletons.add(sample.getKey());
-            if (sample.getValue() < 0) {
+            final double p = sample.getValue();
+            if (p < 0) {
                 throw new NotPositiveException(sample.getValue());
             }
-            probs[i] = sample.getValue();
+            if (Double.isInfinite(p)) {
+                throw new NotFiniteNumberException(p);
+            }
+            if (Double.isNaN(p)) {
+                throw new NotANumberException();
+            }
+            probs[i] = p;
         }
 
         probabilities = MathArrays.normalizeArray(probs, 1.0);
@@ -120,10 +136,13 @@ public void reseedRandomGenerator(long seed) {
     }
 
     /**
-     * For a random variable {@code X} whose values are distributed according to
+     * <p>For a random variable {@code X} whose values are distributed according to
      * this distribution, this method returns {@code P(X = x)}. In other words,
      * this method represents the probability mass function (PMF) for the
-     * distribution.
+     * distribution.</p>
+     *
+     * <p>Note that if {@code x1} and {@code x2} satisfy {@code x1.equals(x2)},
+     * or both are null, then {@code probability(x1) = probability(x2)}.</p>
      *
      * @param x the point at which the PMF is evaluated
      * @return the value of the probability mass function at {@code x}
@@ -142,12 +161,16 @@ public void reseedRandomGenerator(long seed) {
     }
 
     /**
-     * Return the definition of probability mass function in the format of list
-     * of pairs.
+     * <p>Return the probability mass function as a list of <value, probability> pairs.</p>
+     *
+     * <p>Note that if duplicate and / or null values were provided to the constructor
+     * when creating this EnumeratedDistribution, the returned list will contain these
+     * values.  If duplicates values exist, what is returned will not represent
+     * a pmf (i.e., it is up to the caller to consolidate duplicate mass points).</p>
      *
-     * @return definition of probability mass function.
+     * @return the probability mass function.
      */
-    public List<Pair<T, Double>> getSamples() {
+    public List<Pair<T, Double>> getPmf() {
         final List<Pair<T, Double>> samples = new ArrayList<Pair<T, Double>>(probabilities.length);
 
         for (int i = 0; i < probabilities.length; i++) {
diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteIntegerDistribution.java b/src/main/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistribution.java
similarity index 70%
rename from src/main/java/org/apache/commons/math3/distribution/DiscreteIntegerDistribution.java
rename to src/main/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistribution.java
index 686451f159..4f6384bbca 100644
--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteIntegerDistribution.java
+++ b/src/main/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistribution.java
@@ -20,33 +20,34 @@
 import java.util.List;
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.MathArithmeticException;
-import org.apache.commons.math3.exception.MathIllegalArgumentException;
+import org.apache.commons.math3.exception.NotANumberException;
+import org.apache.commons.math3.exception.NotFiniteNumberException;
 import org.apache.commons.math3.exception.NotPositiveException;
 import org.apache.commons.math3.random.RandomGenerator;
 import org.apache.commons.math3.random.Well19937c;
 import org.apache.commons.math3.util.Pair;
 
 /**
- * Implementation of the integer-valued discrete distribution.
- * <p>
- * Note: values with zero-probability are allowed but they do not extend the support.
+ * <p>Implementation of an integer-valued {@link EnumeratedDistribution}.</p>
+ *
+ * <p>Values with zero-probability are allowed but they do not extend the
+ * support.<br/>
+ * Duplicate values are allowed. Probabilities of duplicate values are combined
+ * when computing cumulative probabilities and statistics.</p>
  *
- * @see <a href="http://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution">
- * Discrete probability distribution (Wikipedia)</a>
- * @see <a href="http://mathworld.wolfram.com/DiscreteDistribution.html">Discrete Distribution (MathWorld)</a>
  * @version $Id$
  * @since 3.2
  */
-public class DiscreteIntegerDistribution extends AbstractIntegerDistribution {
+public class EnumeratedIntegerDistribution extends AbstractIntegerDistribution {
 
     /** Serializable UID. */
     private static final long serialVersionUID = 20130308L;
 
     /**
-     * {@link DiscreteDistribution} instance (using the {@link Integer} wrapper)
-     * used to generate samples.
+     * {@link EnumeratedDistribution} instance (using the {@link Integer} wrapper)
+     * used to generate the pmf.
      */
-    protected final DiscreteDistribution<Integer> innerDistribution;
+    protected final EnumeratedDistribution<Integer> innerDistribution;
 
     /**
      * Create a discrete distribution using the given probability mass function
@@ -54,13 +55,16 @@ public class DiscreteIntegerDistribution extends AbstractIntegerDistribution {
      *
      * @param singletons array of random variable values.
      * @param probabilities array of probabilities.
-     * @throws DimensionMismatchException if {@code singletons.length != probabilities.length}
-     * @throws NotPositiveException if probability of at least one value is negative.
-     * @throws MathArithmeticException if the probabilities sum to zero.
-     * @throws MathIllegalArgumentException if probability of at least one value is infinite.
+     * @throws DimensionMismatchException if
+     * {@code singletons.length != probabilities.length}
+     * @throws NotPositiveException if any of the probabilities are negative.
+     * @throws NotFiniteNumberException if any of the probabilities are infinite.
+     * @throws NotANumberException if any of the probabilities are NaN.
+     * @throws MathArithmeticException all of the probabilities are 0.
      */
-    public DiscreteIntegerDistribution(final int[] singletons, final double[] probabilities)
-        throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
+    public EnumeratedIntegerDistribution(final int[] singletons, final double[] probabilities)
+    throws DimensionMismatchException, NotPositiveException, MathArithmeticException,
+           NotFiniteNumberException, NotANumberException{
         this(new Well19937c(), singletons, probabilities);
     }
 
@@ -71,14 +75,17 @@ public DiscreteIntegerDistribution(final int[] singletons, final double[] probab
      * @param rng random number generator.
      * @param singletons array of random variable values.
      * @param probabilities array of probabilities.
-     * @throws DimensionMismatchException if {@code singletons.length != probabilities.length}
-     * @throws NotPositiveException if probability of at least one value is negative.
-     * @throws MathArithmeticException if the probabilities sum to zero.
-     * @throws MathIllegalArgumentException if probability of at least one value is infinite.
+     * @throws DimensionMismatchException if
+     * {@code singletons.length != probabilities.length}
+     * @throws NotPositiveException if any of the probabilities are negative.
+     * @throws NotFiniteNumberException if any of the probabilities are infinite.
+     * @throws NotANumberException if any of the probabilities are NaN.
+     * @throws MathArithmeticException all of the probabilities are 0.
      */
-    public DiscreteIntegerDistribution(final RandomGenerator rng,
+    public EnumeratedIntegerDistribution(final RandomGenerator rng,
                                        final int[] singletons, final double[] probabilities)
-        throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
+        throws DimensionMismatchException, NotPositiveException, MathArithmeticException,
+                NotFiniteNumberException, NotANumberException {
         super(rng);
         if (singletons.length != probabilities.length) {
             throw new DimensionMismatchException(probabilities.length, singletons.length);
@@ -90,7 +97,7 @@ public DiscreteIntegerDistribution(final RandomGenerator rng,
             samples.add(new Pair<Integer, Double>(singletons[i], probabilities[i]));
         }
 
-        innerDistribution = new DiscreteDistribution<Integer>(rng, samples);
+        innerDistribution = new EnumeratedDistribution<Integer>(rng, samples);
     }
 
     /**
@@ -106,7 +113,7 @@ public double probability(final int x) {
     public double cumulativeProbability(final int x) {
         double probability = 0;
 
-        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {
             if (sample.getKey() <= x) {
                 probability += sample.getValue();
             }
@@ -123,7 +130,7 @@ public double cumulativeProbability(final int x) {
     public double getNumericalMean() {
         double mean = 0;
 
-        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {
             mean += sample.getValue() * sample.getKey();
         }
 
@@ -139,7 +146,7 @@ public double getNumericalVariance() {
         double mean = 0;
         double meanOfSquares = 0;
 
-        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {
             mean += sample.getValue() * sample.getKey();
             meanOfSquares += sample.getValue() * sample.getKey() * sample.getKey();
         }
@@ -156,7 +163,7 @@ public double getNumericalVariance() {
      */
     public int getSupportLowerBound() {
         int min = Integer.MAX_VALUE;
-        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {
             if (sample.getKey() < min && sample.getValue() > 0) {
                 min = sample.getKey();
             }
@@ -174,7 +181,7 @@ public int getSupportLowerBound() {
      */
     public int getSupportUpperBound() {
         int max = Integer.MIN_VALUE;
-        for (final Pair<Integer, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Integer, Double> sample : innerDistribution.getPmf()) {
             if (sample.getKey() > max && sample.getValue() > 0) {
                 max = sample.getKey();
             }
@@ -194,6 +201,9 @@ public boolean isSupportConnected() {
         return true;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public int sample() {
         return innerDistribution.sample();
diff --git a/src/main/java/org/apache/commons/math3/distribution/DiscreteRealDistribution.java b/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java
similarity index 73%
rename from src/main/java/org/apache/commons/math3/distribution/DiscreteRealDistribution.java
rename to src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java
index c3d9c599a3..d4574342e2 100644
--- a/src/main/java/org/apache/commons/math3/distribution/DiscreteRealDistribution.java
+++ b/src/main/java/org/apache/commons/math3/distribution/EnumeratedRealDistribution.java
@@ -20,66 +20,72 @@
 import java.util.List;
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.MathArithmeticException;
-import org.apache.commons.math3.exception.MathIllegalArgumentException;
+import org.apache.commons.math3.exception.NotANumberException;
+import org.apache.commons.math3.exception.NotFiniteNumberException;
 import org.apache.commons.math3.exception.NotPositiveException;
 import org.apache.commons.math3.random.RandomGenerator;
 import org.apache.commons.math3.random.Well19937c;
 import org.apache.commons.math3.util.Pair;
 
 /**
- * Implementation of the discrete distribution on the reals.
- * <p>
- * Note: values with zero-probability are allowed but they do not extend the support.
+ * <p>Implementation of a real-valued {@link EnumeratedDistribution}.
+ *
+ * <p>Values with zero-probability are allowed but they do not extend the
+ * support.<br/>
+ * Duplicate values are allowed. Probabilities of duplicate values are combined
+ * when computing cumulative probabilities and statistics.</p>
  *
- * @see <a href="http://en.wikipedia.org/wiki/Probability_distribution#Discrete_probability_distribution">
- * Discrete probability distribution (Wikipedia)</a>
- * @see <a href="http://mathworld.wolfram.com/DiscreteDistribution.html">Discrete Distribution (MathWorld)</a>
  * @version $Id$
  * @since 3.2
  */
-public class DiscreteRealDistribution extends AbstractRealDistribution {
+public class EnumeratedRealDistribution extends AbstractRealDistribution {
 
     /** Serializable UID. */
     private static final long serialVersionUID = 20130308L;
 
     /**
-     * {@link DiscreteDistribution} instance (using the {@link Double} wrapper)
-     * used to generate samples.
+     * {@link EnumeratedDistribution} (using the {@link Double} wrapper)
+     * used to generate the pmf.
      */
-    protected final DiscreteDistribution<Double> innerDistribution;
+    protected final EnumeratedDistribution<Double> innerDistribution;
 
     /**
      * Create a discrete distribution using the given probability mass function
-     * definition.
+     * enumeration.
      *
      * @param singletons array of random variable values.
      * @param probabilities array of probabilities.
-     * @throws DimensionMismatchException if {@code singletons.length != probabilities.length}
-     * @throws NotPositiveException if probability of at least one value is negative.
-     * @throws MathArithmeticException if the probabilities sum to zero.
-     * @throws MathIllegalArgumentException if probability of at least one value is infinite.
+     * @throws DimensionMismatchException if
+     * {@code singletons.length != probabilities.length}
+     * @throws NotPositiveException if any of the probabilities are negative.
+     * @throws NotFiniteNumberException if any of the probabilities are infinite.
+     * @throws NotANumberException if any of the probabilities are NaN.
+     * @throws MathArithmeticException all of the probabilities are 0.
      */
-    public DiscreteRealDistribution(final double[] singletons, final double[] probabilities)
-            throws DimensionMismatchException, NotPositiveException, MathArithmeticException,
-            MathIllegalArgumentException {
+    public EnumeratedRealDistribution(final double[] singletons, final double[] probabilities)
+    throws DimensionMismatchException, NotPositiveException, MathArithmeticException,
+           NotFiniteNumberException, NotANumberException {
         this(new Well19937c(), singletons, probabilities);
     }
 
     /**
      * Create a discrete distribution using the given random number generator
-     * and probability mass function definition.
+     * and probability mass function enumeration.
      *
      * @param rng random number generator.
      * @param singletons array of random variable values.
      * @param probabilities array of probabilities.
-     * @throws DimensionMismatchException if {@code singletons.length != probabilities.length}
-     * @throws NotPositiveException if probability of at least one value is negative.
-     * @throws MathArithmeticException if the probabilities sum to zero.
-     * @throws MathIllegalArgumentException if probability of at least one value is infinite.
+     * @throws DimensionMismatchException if
+     * {@code singletons.length != probabilities.length}
+     * @throws NotPositiveException if any of the probabilities are negative.
+     * @throws NotFiniteNumberException if any of the probabilities are infinite.
+     * @throws NotANumberException if any of the probabilities are NaN.
+     * @throws MathArithmeticException all of the probabilities are 0.
      */
-    public DiscreteRealDistribution(final RandomGenerator rng,
+    public EnumeratedRealDistribution(final RandomGenerator rng,
                                     final double[] singletons, final double[] probabilities)
-        throws DimensionMismatchException, NotPositiveException, MathArithmeticException, MathIllegalArgumentException {
+        throws DimensionMismatchException, NotPositiveException, MathArithmeticException,
+               NotFiniteNumberException, NotANumberException {
         super(rng);
         if (singletons.length != probabilities.length) {
             throw new DimensionMismatchException(probabilities.length, singletons.length);
@@ -91,9 +97,12 @@ public DiscreteRealDistribution(final RandomGenerator rng,
             samples.add(new Pair<Double, Double>(singletons[i], probabilities[i]));
         }
 
-        innerDistribution = new DiscreteDistribution<Double>(rng, samples);
+        innerDistribution = new EnumeratedDistribution<Double>(rng, samples);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public double probability(final double x) {
         return innerDistribution.probability(x);
@@ -118,7 +127,7 @@ public double density(final double x) {
     public double cumulativeProbability(final double x) {
         double probability = 0;
 
-        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {
             if (sample.getKey() <= x) {
                 probability += sample.getValue();
             }
@@ -135,7 +144,7 @@ public double cumulativeProbability(final double x) {
     public double getNumericalMean() {
         double mean = 0;
 
-        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {
             mean += sample.getValue() * sample.getKey();
         }
 
@@ -151,7 +160,7 @@ public double getNumericalVariance() {
         double mean = 0;
         double meanOfSquares = 0;
 
-        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {
             mean += sample.getValue() * sample.getKey();
             meanOfSquares += sample.getValue() * sample.getKey() * sample.getKey();
         }
@@ -168,7 +177,7 @@ public double getNumericalVariance() {
      */
     public double getSupportLowerBound() {
         double min = Double.POSITIVE_INFINITY;
-        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {
             if (sample.getKey() < min && sample.getValue() > 0) {
                 min = sample.getKey();
             }
@@ -186,7 +195,7 @@ public double getSupportLowerBound() {
      */
     public double getSupportUpperBound() {
         double max = Double.NEGATIVE_INFINITY;
-        for (final Pair<Double, Double> sample : innerDistribution.getSamples()) {
+        for (final Pair<Double, Double> sample : innerDistribution.getPmf()) {
             if (sample.getKey() > max && sample.getValue() > 0) {
                 max = sample.getKey();
             }
@@ -228,6 +237,9 @@ public boolean isSupportConnected() {
         return true;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public double sample() {
         return innerDistribution.sample();
diff --git a/src/test/java/org/apache/commons/math3/distribution/DiscreteIntegerDistributionTest.java b/src/test/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistributionTest.java
similarity index 77%
rename from src/test/java/org/apache/commons/math3/distribution/DiscreteIntegerDistributionTest.java
rename to src/test/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistributionTest.java
index 028486ffed..ec3ede645a 100644
--- a/src/test/java/org/apache/commons/math3/distribution/DiscreteIntegerDistributionTest.java
+++ b/src/test/java/org/apache/commons/math3/distribution/EnumeratedIntegerDistributionTest.java
@@ -18,66 +18,67 @@
 
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.MathArithmeticException;
-import org.apache.commons.math3.exception.MathIllegalArgumentException;
+import org.apache.commons.math3.exception.NotANumberException;
+import org.apache.commons.math3.exception.NotFiniteNumberException;
 import org.apache.commons.math3.exception.NotPositiveException;
 import org.apache.commons.math3.util.FastMath;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
- * Test class for {@link DiscreteIntegerDistribution}.
- * 
- * @version $Id: DiscreteIntegerDistributionTest.java 161 2013-03-07 09:47:32Z wydrych $
+ * Test class for {@link EnumeratedIntegerDistribution}.
+ *
+ * @version $Id$
  */
-public class DiscreteIntegerDistributionTest {
+public class EnumeratedIntegerDistributionTest {
 
     /**
      * The distribution object used for testing.
      */
-    private final DiscreteIntegerDistribution testDistribution;
+    private final EnumeratedIntegerDistribution testDistribution;
 
     /**
-     * Creates the default distribution object uded for testing.
+     * Creates the default distribution object used for testing.
      */
-    public DiscreteIntegerDistributionTest() {
+    public EnumeratedIntegerDistributionTest() {
         // Non-sorted singleton array with duplicates should be allowed.
         // Values with zero-probability do not extend the support.
-        testDistribution = new DiscreteIntegerDistribution(
+        testDistribution = new EnumeratedIntegerDistribution(
                 new int[]{3, -1, 3, 7, -2, 8},
                 new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0});
     }
 
     /**
-     * Tests if the {@link DiscreteIntegerDistribution} constructor throws
-     * exceptions for ivalid data.
+     * Tests if the EnumeratedIntegerDistribution constructor throws
+     * exceptions for invalid data.
      */
     @Test
     public void testExceptions() {
-        DiscreteIntegerDistribution invalid = null;
+        EnumeratedIntegerDistribution invalid = null;
         try {
-            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0});
+            new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0});
             Assert.fail("Expected DimensionMismatchException");
         } catch (DimensionMismatchException e) {
         }
         try {
-            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0, -1.0});
+            new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, -1.0});
             Assert.fail("Expected NotPositiveException");
         } catch (NotPositiveException e) {
         }
         try {
-            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0, 0.0});
+            new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, 0.0});
             Assert.fail("Expected MathArithmeticException");
         } catch (MathArithmeticException e) {
         }
         try {
-            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.NaN});
-            Assert.fail("Expected MathArithmeticException");
-        } catch (MathArithmeticException e) {
+          new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.NaN});
+            Assert.fail("Expected NotANumberException");
+        } catch (NotANumberException e) {
         }
         try {
-            invalid = new DiscreteIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.POSITIVE_INFINITY});
-            Assert.fail("Expected MathIllegalArgumentException");
-        } catch (MathIllegalArgumentException e) {
+        new EnumeratedIntegerDistribution(new int[]{1, 2}, new double[]{0.0, Double.POSITIVE_INFINITY});
+            Assert.fail("Expected NotFiniteNumberException");
+        } catch (NotFiniteNumberException e) {
         }
         Assert.assertNull("Expected non-initialized DiscreteRealDistribution", invalid);
     }
diff --git a/src/test/java/org/apache/commons/math3/distribution/DiscreteRealDistributionTest.java b/src/test/java/org/apache/commons/math3/distribution/EnumeratedRealDistributionTest.java
similarity index 81%
rename from src/test/java/org/apache/commons/math3/distribution/DiscreteRealDistributionTest.java
rename to src/test/java/org/apache/commons/math3/distribution/EnumeratedRealDistributionTest.java
index cd639f6a85..182a6c8397 100644
--- a/src/test/java/org/apache/commons/math3/distribution/DiscreteRealDistributionTest.java
+++ b/src/test/java/org/apache/commons/math3/distribution/EnumeratedRealDistributionTest.java
@@ -21,7 +21,8 @@
 
 import org.apache.commons.math3.exception.DimensionMismatchException;
 import org.apache.commons.math3.exception.MathArithmeticException;
-import org.apache.commons.math3.exception.MathIllegalArgumentException;
+import org.apache.commons.math3.exception.NotANumberException;
+import org.apache.commons.math3.exception.NotFiniteNumberException;
 import org.apache.commons.math3.exception.NotPositiveException;
 import org.apache.commons.math3.util.FastMath;
 import org.apache.commons.math3.util.Pair;
@@ -29,59 +30,59 @@
 import org.junit.Test;
 
 /**
- * Test class for {@link DiscreteRealDistribution}.
+ * Test class for {@link EnumeratedRealDistribution}.
  * 
- * @version $Id: DiscreteRealDistributionTest.java 161 2013-03-07 09:47:32Z wydrych $
+ * @version $Id$
  */
-public class DiscreteRealDistributionTest {
+public class EnumeratedRealDistributionTest {
 
     /**
      * The distribution object used for testing.
      */
-    private final DiscreteRealDistribution testDistribution;
+    private final EnumeratedRealDistribution testDistribution;
 
     /**
-     * Creates the default distribution object uded for testing.
+     * Creates the default distribution object used for testing.
      */
-    public DiscreteRealDistributionTest() {
+    public EnumeratedRealDistributionTest() {
         // Non-sorted singleton array with duplicates should be allowed.
         // Values with zero-probability do not extend the support.
-        testDistribution = new DiscreteRealDistribution(
+        testDistribution = new EnumeratedRealDistribution(
                 new double[]{3.0, -1.0, 3.0, 7.0, -2.0, 8.0},
                 new double[]{0.2, 0.2, 0.3, 0.3, 0.0, 0.0});
     }
 
     /**
-     * Tests if the {@link DiscreteRealDistribution} constructor throws
-     * exceptions for ivalid data.
+     * Tests if the {@link EnumeratedRealDistribution} constructor throws
+     * exceptions for invalid data.
      */
     @Test
     public void testExceptions() {
-        DiscreteRealDistribution invalid = null;
+        EnumeratedRealDistribution invalid = null;
         try {
-            invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0});
+            invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0});
             Assert.fail("Expected DimensionMismatchException");
         } catch (DimensionMismatchException e) {
         }
         try{
-        invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, -1.0});
+        invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, -1.0});
             Assert.fail("Expected NotPositiveException");
         } catch (NotPositiveException e) {
         }
         try {
-            invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, 0.0});
+            invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, 0.0});
             Assert.fail("Expected MathArithmeticException");
         } catch (MathArithmeticException e) {
         }
         try {
-            invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.NaN});
-            Assert.fail("Expected MathArithmeticException");
-        } catch (MathArithmeticException e) {
+            invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.NaN});
+            Assert.fail("Expected NotANumberException");
+        } catch (NotANumberException e) {
         }
         try {
-            invalid = new DiscreteRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.POSITIVE_INFINITY});
-            Assert.fail("Expected MathIllegalArgumentException");
-        } catch (MathIllegalArgumentException e) {
+            invalid = new EnumeratedRealDistribution(new double[]{1.0, 2.0}, new double[]{0.0, Double.POSITIVE_INFINITY});
+            Assert.fail("Expected NotFiniteNumberException");
+        } catch (NotFiniteNumberException e) {
         }
         Assert.assertNull("Expected non-initialized DiscreteRealDistribution", invalid);
     }
@@ -209,7 +210,7 @@ public void testIssue942() {
         List<Pair<Object,Double>> list = new ArrayList<Pair<Object, Double>>();
         list.add(new Pair<Object, Double>(new Object() {}, new Double(0)));
         list.add(new Pair<Object, Double>(new Object() {}, new Double(1)));
-        Assert.assertEquals(1, new DiscreteDistribution<Object>(list).sample(1).length);
+        Assert.assertEquals(1, new EnumeratedDistribution<Object>(list).sample(1).length);
     }
 
 }
