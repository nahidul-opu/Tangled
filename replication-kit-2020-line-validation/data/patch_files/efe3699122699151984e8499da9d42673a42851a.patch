From efe3699122699151984e8499da9d42673a42851a Mon Sep 17 00:00:00 2001
From: Jochen Wiedmann <jochen@apache.org>
Date: Wed, 14 Sep 2016 12:14:26 +0000
Subject: [PATCH] PR: CODEC-225

Fix minor resource leaks. GitHub PR

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1760691 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  1 +
 .../codec/language/DaitchMokotoffSoundex.java |  7 +++++--
 .../commons/codec/language/bm/Rule.java       | 19 ++++++++++++++++---
 3 files changed, 22 insertions(+), 5 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index b7a3d8bffa..fba8d09273 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -45,6 +45,7 @@ The <action> type attribute can be add,update,fix,remove.
     <release version="1.11" date="2016-MM-DD" description="Feature and fix release.">
       <!-- The first attribute below should be the issue id; makes it easier to navigate in the IDE outline -->
 
+	  <action issue="CODEC-225" dev="jochen" type="fix" due-to="Svetlin Zarev">Fix minor resource leaks</action>
       <action issue="CODEC-223" dev="sebb" type="remove">Drop obsolete Ant build</action>
       <action issue="CODEC-171" dev="sebb" type="add" due-to="Brett Okken">Add support for CRC32-C</action>
       <action issue="CODEC-221" dev="sebb" type="update">HmacUtils.updateHmac calls reset() unnecessarily</action>
diff --git a/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java b/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java
index 4b83f33d57..de94a73438 100644
--- a/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java
+++ b/src/main/java/org/apache/commons/codec/language/DaitchMokotoffSoundex.java
@@ -232,8 +232,11 @@ public String toString() {
         }
 
         final Scanner scanner = new Scanner(rulesIS, CharEncoding.UTF_8);
-        parseRules(scanner, RESOURCE_FILE, RULES, FOLDINGS);
-        scanner.close();
+        try {
+            parseRules(scanner, RESOURCE_FILE, RULES, FOLDINGS);
+        } finally {
+            scanner.close();
+        }
 
         // sort RULES by pattern length in descending order
         for (final Map.Entry<Character, List<Rule>> rule : RULES.entrySet()) {
diff --git a/src/main/java/org/apache/commons/codec/language/bm/Rule.java b/src/main/java/org/apache/commons/codec/language/bm/Rule.java
index 721cb48795..197cf0fb07 100644
--- a/src/main/java/org/apache/commons/codec/language/bm/Rule.java
+++ b/src/main/java/org/apache/commons/codec/language/bm/Rule.java
@@ -219,14 +219,22 @@ public boolean isMatch(final CharSequence input) {
 
                 final Languages ls = Languages.getInstance(s);
                 for (final String l : ls.getLanguages()) {
+                    final Scanner scanner = createScanner(s, rt, l);
                     try {
-                        rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));
+                        rs.put(l, parseRules(scanner, createResourceName(s, rt, l)));
                     } catch (final IllegalStateException e) {
                         throw new IllegalStateException("Problem processing " + createResourceName(s, rt, l), e);
+                    } finally {
+                        scanner.close();
                     }
                 }
                 if (!rt.equals(RuleType.RULES)) {
-                    rs.put("common", parseRules(createScanner(s, rt, "common"), createResourceName(s, rt, "common")));
+                    final Scanner scanner = createScanner(s, rt, "common");
+                    try {
+                        rs.put("common", parseRules(scanner, createResourceName(s, rt, "common")));
+                    } finally {
+                        scanner.close();
+                    }
                 }
 
                 rts.put(rt, Collections.unmodifiableMap(rs));
@@ -435,7 +443,12 @@ private static Map<String, List<Rule>> parseRules(final Scanner scanner, final S
                             throw new IllegalArgumentException("Malformed import statement '" + rawLine + "' in " +
                                                                location);
                         }
-                        lines.putAll(parseRules(createScanner(incl), location + "->" + incl));
+                        final Scanner hashIncludeScanner = createScanner(incl);
+                        try {
+                            lines.putAll(parseRules(hashIncludeScanner, location + "->" + incl));
+                        } finally {
+                            hashIncludeScanner.close();
+                        }
                     } else {
                         // rule
                         final String[] parts = line.split("\\s+");
