From ccf4ce767a6cc07f1a88a0c33393e394af3c328b Mon Sep 17 00:00:00 2001
From: Stefan Bodewig <bodewig@apache.org>
Date: Thu, 28 Dec 2017 17:02:43 +0100
Subject: [PATCH 1/2] COMPRESS-424 add array bounds checks, detect corrupted
 input

---
 .../bzip2/BZip2CompressorInputStream.java     | 74 +++++++++++++++----
 1 file changed, 58 insertions(+), 16 deletions(-)

diff --git a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
index 17937e873fe..06e2beea35d 100644
--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
@@ -399,12 +399,23 @@ private static int bsGetInt(BitInputStream bin) throws IOException {
         return bsR(bin, 32);
     }
 
+    private static void checkBounds(final int checkVal, final int limitInclusive, String name)
+        throws IOException {
+        if (checkVal < 0) {
+            throw new IOException("Corrupted input, " + name + " value negative");
+        }
+        if (checkVal > limitInclusive) {
+            throw new IOException("Corrupted input, " + name + " value too big");
+        }
+    }
+
     /**
      * Called by createHuffmanDecodingTables() exclusively.
      */
     private static void hbCreateDecodeTables(final int[] limit,
                                              final int[] base, final int[] perm, final char[] length,
-                                             final int minLen, final int maxLen, final int alphaSize) {
+                                             final int minLen, final int maxLen, final int alphaSize)
+        throws IOException {
         for (int i = minLen, pp = 0; i <= maxLen; i++) {
             for (int j = 0; j < alphaSize; j++) {
                 if (length[j] == i) {
@@ -419,7 +430,9 @@ private static void hbCreateDecodeTables(final int[] limit,
         }
 
         for (int i = 0; i < alphaSize; i++) {
-            base[length[i] + 1]++;
+            final int l = length[i];
+            checkBounds(l, MAX_ALPHA_SIZE - 1, "length");
+            base[l + 1]++;
         }
 
         for (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {
@@ -474,6 +487,9 @@ private void recvDecodingTables() throws IOException {
         /* Now the selectors */
         final int nGroups = bsR(bin, 3);
         final int nSelectors = bsR(bin, 15);
+        checkBounds(alphaSize, MAX_ALPHA_SIZE, "alphaSize");
+        checkBounds(nGroups, N_GROUPS, "nGroups");
+        checkBounds(nSelectors, MAX_SELECTORS, "nSelectors");
 
         for (int i = 0; i < nSelectors; i++) {
             int j = 0;
@@ -490,6 +506,7 @@ private void recvDecodingTables() throws IOException {
 
         for (int i = 0; i < nSelectors; i++) {
             int v = selectorMtf[i] & 0xff;
+            checkBounds(v, N_GROUPS - 1, "selectorMtf");
             final byte tmp = pos[v];
             while (v > 0) {
                 // nearly all times v is zero, 4 in most other cases
@@ -522,7 +539,7 @@ private void recvDecodingTables() throws IOException {
      * Called by recvDecodingTables() exclusively.
      */
     private void createHuffmanDecodingTables(final int alphaSize,
-                                             final int nGroups) {
+                                             final int nGroups) throws IOException {
         final Data dataShadow = this.data;
         final char[][] len = dataShadow.temp_charArray2d;
         final int[] minLens = dataShadow.minLens;
@@ -579,9 +596,10 @@ private void getAndMoveToFrontDecode() throws IOException {
         int groupNo = 0;
         int groupPos = G_SIZE - 1;
         final int eob = this.nInUse + 1;
-        int nextSym = getAndMoveToFrontDecode0(0);
+        int nextSym = getAndMoveToFrontDecode0();
         int lastShadow = -1;
         int zt = selector[groupNo] & 0xff;
+        checkBounds(zt, N_GROUPS - 1, "zt");
         int[] base_zt = base[zt];
         int[] limit_zt = limit[zt];
         int[] perm_zt = perm[zt];
@@ -602,7 +620,9 @@ private void getAndMoveToFrontDecode() throws IOException {
 
                     if (groupPos == 0) {
                         groupPos = G_SIZE - 1;
-                        zt = selector[++groupNo] & 0xff;
+                        checkBounds(++groupNo, MAX_SELECTORS - 1, "groupNo");
+                        zt = selector[groupNo] & 0xff;
+                        checkBounds(zt, N_GROUPS - 1, "zt");
                         base_zt = base[zt];
                         limit_zt = limit[zt];
                         perm_zt = perm[zt];
@@ -612,15 +632,20 @@ private void getAndMoveToFrontDecode() throws IOException {
                     }
 
                     int zn = minLens_zt;
+                    checkBounds(zn, MAX_ALPHA_SIZE - 1, "zn");
                     int zvec = bsR(bin, zn);
                     while(zvec > limit_zt[zn]) {
-                        zn++;
+                        checkBounds(++zn, MAX_ALPHA_SIZE - 1, "zn");
                         zvec = (zvec << 1) | bsR(bin, 1);
                     }
-                    nextSym = perm_zt[zvec - base_zt[zn]];
+                    final int tmp = zvec - base_zt[zn];
+                    checkBounds(tmp, MAX_ALPHA_SIZE - 1, "zvec");
+                    nextSym = perm_zt[tmp];
                 }
 
-                final byte ch = seqToUnseq[yy[0]];
+                final int yy_0 = yy[0];
+                checkBounds(yy_0, 255, "yy");
+                final byte ch = seqToUnseq[yy_0];
                 unzftab[ch & 0xff] += s + 1;
 
                 while (s-- >= 0) {
@@ -634,8 +659,10 @@ private void getAndMoveToFrontDecode() throws IOException {
                 if (++lastShadow >= limitLast) {
                     throw new IOException("block overrun");
                 }
+                checkBounds(nextSym, 256, "nextSym");
 
                 final char tmp = yy[nextSym - 1];
+                checkBounds(tmp, 255, "yy");
                 unzftab[seqToUnseq[tmp] & 0xff]++;
                 ll8[lastShadow] = seqToUnseq[tmp];
 
@@ -656,7 +683,9 @@ private void getAndMoveToFrontDecode() throws IOException {
 
                 if (groupPos == 0) {
                     groupPos = G_SIZE - 1;
-                    zt = selector[++groupNo] & 0xff;
+                    checkBounds(++groupNo, MAX_SELECTORS - 1, "groupNo");
+                    zt = selector[groupNo] & 0xff;
+                    checkBounds(zt, N_GROUPS - 1, "zt");
                     base_zt = base[zt];
                     limit_zt = limit[zt];
                     perm_zt = perm[zt];
@@ -666,30 +695,37 @@ private void getAndMoveToFrontDecode() throws IOException {
                 }
 
                 int zn = minLens_zt;
+                checkBounds(zn, MAX_ALPHA_SIZE - 1, "zn");
                 int zvec = bsR(bin, zn);
                 while(zvec > limit_zt[zn]) {
-                    zn++;
+                    checkBounds(++zn, MAX_ALPHA_SIZE - 1, "zn");
                     zvec = (zvec << 1) | bsR(bin, 1);
                 }
-                nextSym = perm_zt[zvec - base_zt[zn]];
+                final int idx = zvec - base_zt[zn];
+                checkBounds(idx, MAX_ALPHA_SIZE - 1, "zvec");
+                nextSym = perm_zt[idx];
             }
         }
 
         this.last = lastShadow;
     }
 
-    private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {
+    private int getAndMoveToFrontDecode0() throws IOException {
         final Data dataShadow = this.data;
-        final int zt = dataShadow.selector[groupNo] & 0xff;
+        final int zt = dataShadow.selector[0] & 0xff;
+        checkBounds(zt, N_GROUPS - 1, "zt");
         final int[] limit_zt = dataShadow.limit[zt];
         int zn = dataShadow.minLens[zt];
+        checkBounds(zn, MAX_ALPHA_SIZE - 1, "zn");
         int zvec = bsR(bin, zn);
         while (zvec > limit_zt[zn]) {
-            zn++;
+            checkBounds(++zn, MAX_ALPHA_SIZE - 1, "zn");
             zvec = (zvec << 1) | bsR(bin, 1);
         }
+        final int tmp = zvec - dataShadow.base[zt][zn];
+        checkBounds(tmp, MAX_ALPHA_SIZE - 1, "zvec");
 
-        return dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];
+        return dataShadow.perm[zt][tmp];
     }
 
     private int setupBlock() throws IOException {
@@ -709,7 +745,9 @@ private int setupBlock() throws IOException {
         }
 
         for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {
-            tt[cftab[ll8[i] & 0xff]++] = i;
+            final int tmp = cftab[ll8[i] & 0xff]++;
+            checkBounds(tmp, this.last, "tt index");
+            tt[tmp] = i;
         }
 
         if ((this.origPtr < 0) || (this.origPtr >= tt.length)) {
@@ -733,6 +771,7 @@ private int setupRandPartA() throws IOException {
         if (this.su_i2 <= this.last) {
             this.su_chPrev = this.su_ch2;
             int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
+            checkBounds(this.su_tPos, this.data.tt.length - 1, "su_tPos");
             this.su_tPos = this.data.tt[this.su_tPos];
             if (this.su_rNToGo == 0) {
                 this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
@@ -758,6 +797,7 @@ private int setupNoRandPartA() throws IOException {
             this.su_chPrev = this.su_ch2;
             final int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
             this.su_ch2 = su_ch2Shadow;
+            checkBounds(this.su_tPos, this.data.tt.length - 1, "su_tPos");
             this.su_tPos = this.data.tt[this.su_tPos];
             this.su_i2++;
             this.currentState = NO_RAND_PART_B_STATE;
@@ -777,6 +817,7 @@ private int setupRandPartB() throws IOException {
             return setupRandPartA();
         } else if (++this.su_count >= 4) {
             this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);
+            checkBounds(this.su_tPos, this.data.tt.length - 1, "su_tPos");
             this.su_tPos = this.data.tt[this.su_tPos];
             if (this.su_rNToGo == 0) {
                 this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
@@ -815,6 +856,7 @@ private int setupNoRandPartB() throws IOException {
             this.su_count = 1;
             return setupNoRandPartA();
         } else if (++this.su_count >= 4) {
+            checkBounds(this.su_tPos, this.data.ll8.length - 1, "su_tPos");
             this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);
             this.su_tPos = this.data.tt[this.su_tPos];
             this.su_j2 = 0;

From 0c75ccec267ce902ff36278ba928b4573f4fb937 Mon Sep 17 00:00:00 2001
From: Stefan Bodewig <bodewig@apache.org>
Date: Sat, 30 Dec 2017 10:53:34 +0100
Subject: [PATCH 2/2] change bounds check to greater-equals to avoid arithmetic
 in loops

---
 .../bzip2/BZip2CompressorInputStream.java     | 63 ++++++++++---------
 1 file changed, 32 insertions(+), 31 deletions(-)

diff --git a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
index 06e2beea35d..945ba3c9f87 100644
--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
@@ -399,12 +399,12 @@ private static int bsGetInt(BitInputStream bin) throws IOException {
         return bsR(bin, 32);
     }
 
-    private static void checkBounds(final int checkVal, final int limitInclusive, String name)
+    private static void checkBounds(final int checkVal, final int limitExclusive, String name)
         throws IOException {
         if (checkVal < 0) {
             throw new IOException("Corrupted input, " + name + " value negative");
         }
-        if (checkVal > limitInclusive) {
+        if (checkVal >= limitExclusive) {
             throw new IOException("Corrupted input, " + name + " value too big");
         }
     }
@@ -431,7 +431,7 @@ private static void hbCreateDecodeTables(final int[] limit,
 
         for (int i = 0; i < alphaSize; i++) {
             final int l = length[i];
-            checkBounds(l, MAX_ALPHA_SIZE - 1, "length");
+            checkBounds(l, MAX_ALPHA_SIZE, "length");
             base[l + 1]++;
         }
 
@@ -487,9 +487,9 @@ private void recvDecodingTables() throws IOException {
         /* Now the selectors */
         final int nGroups = bsR(bin, 3);
         final int nSelectors = bsR(bin, 15);
-        checkBounds(alphaSize, MAX_ALPHA_SIZE, "alphaSize");
-        checkBounds(nGroups, N_GROUPS, "nGroups");
-        checkBounds(nSelectors, MAX_SELECTORS, "nSelectors");
+        checkBounds(alphaSize, MAX_ALPHA_SIZE + 1, "alphaSize");
+        checkBounds(nGroups, N_GROUPS + 1, "nGroups");
+        checkBounds(nSelectors, MAX_SELECTORS + 1, "nSelectors");
 
         for (int i = 0; i < nSelectors; i++) {
             int j = 0;
@@ -506,7 +506,7 @@ private void recvDecodingTables() throws IOException {
 
         for (int i = 0; i < nSelectors; i++) {
             int v = selectorMtf[i] & 0xff;
-            checkBounds(v, N_GROUPS - 1, "selectorMtf");
+            checkBounds(v, N_GROUPS, "selectorMtf");
             final byte tmp = pos[v];
             while (v > 0) {
                 // nearly all times v is zero, 4 in most other cases
@@ -599,7 +599,7 @@ private void getAndMoveToFrontDecode() throws IOException {
         int nextSym = getAndMoveToFrontDecode0();
         int lastShadow = -1;
         int zt = selector[groupNo] & 0xff;
-        checkBounds(zt, N_GROUPS - 1, "zt");
+        checkBounds(zt, N_GROUPS, "zt");
         int[] base_zt = base[zt];
         int[] limit_zt = limit[zt];
         int[] perm_zt = perm[zt];
@@ -620,9 +620,9 @@ private void getAndMoveToFrontDecode() throws IOException {
 
                     if (groupPos == 0) {
                         groupPos = G_SIZE - 1;
-                        checkBounds(++groupNo, MAX_SELECTORS - 1, "groupNo");
+                        checkBounds(++groupNo, MAX_SELECTORS, "groupNo");
                         zt = selector[groupNo] & 0xff;
-                        checkBounds(zt, N_GROUPS - 1, "zt");
+                        checkBounds(zt, N_GROUPS, "zt");
                         base_zt = base[zt];
                         limit_zt = limit[zt];
                         perm_zt = perm[zt];
@@ -632,19 +632,19 @@ private void getAndMoveToFrontDecode() throws IOException {
                     }
 
                     int zn = minLens_zt;
-                    checkBounds(zn, MAX_ALPHA_SIZE - 1, "zn");
+                    checkBounds(zn, MAX_ALPHA_SIZE, "zn");
                     int zvec = bsR(bin, zn);
                     while(zvec > limit_zt[zn]) {
-                        checkBounds(++zn, MAX_ALPHA_SIZE - 1, "zn");
+                        checkBounds(++zn, MAX_ALPHA_SIZE, "zn");
                         zvec = (zvec << 1) | bsR(bin, 1);
                     }
                     final int tmp = zvec - base_zt[zn];
-                    checkBounds(tmp, MAX_ALPHA_SIZE - 1, "zvec");
+                    checkBounds(tmp, MAX_ALPHA_SIZE, "zvec");
                     nextSym = perm_zt[tmp];
                 }
 
                 final int yy_0 = yy[0];
-                checkBounds(yy_0, 255, "yy");
+                checkBounds(yy_0, 256, "yy");
                 final byte ch = seqToUnseq[yy_0];
                 unzftab[ch & 0xff] += s + 1;
 
@@ -659,10 +659,10 @@ private void getAndMoveToFrontDecode() throws IOException {
                 if (++lastShadow >= limitLast) {
                     throw new IOException("block overrun");
                 }
-                checkBounds(nextSym, 256, "nextSym");
+                checkBounds(nextSym, 256 + 1, "nextSym");
 
                 final char tmp = yy[nextSym - 1];
-                checkBounds(tmp, 255, "yy");
+                checkBounds(tmp, 256, "yy");
                 unzftab[seqToUnseq[tmp] & 0xff]++;
                 ll8[lastShadow] = seqToUnseq[tmp];
 
@@ -683,9 +683,9 @@ private void getAndMoveToFrontDecode() throws IOException {
 
                 if (groupPos == 0) {
                     groupPos = G_SIZE - 1;
-                    checkBounds(++groupNo, MAX_SELECTORS - 1, "groupNo");
+                    checkBounds(++groupNo, MAX_SELECTORS, "groupNo");
                     zt = selector[groupNo] & 0xff;
-                    checkBounds(zt, N_GROUPS - 1, "zt");
+                    checkBounds(zt, N_GROUPS, "zt");
                     base_zt = base[zt];
                     limit_zt = limit[zt];
                     perm_zt = perm[zt];
@@ -695,14 +695,14 @@ private void getAndMoveToFrontDecode() throws IOException {
                 }
 
                 int zn = minLens_zt;
-                checkBounds(zn, MAX_ALPHA_SIZE - 1, "zn");
+                checkBounds(zn, MAX_ALPHA_SIZE, "zn");
                 int zvec = bsR(bin, zn);
                 while(zvec > limit_zt[zn]) {
-                    checkBounds(++zn, MAX_ALPHA_SIZE - 1, "zn");
+                    checkBounds(++zn, MAX_ALPHA_SIZE, "zn");
                     zvec = (zvec << 1) | bsR(bin, 1);
                 }
                 final int idx = zvec - base_zt[zn];
-                checkBounds(idx, MAX_ALPHA_SIZE - 1, "zvec");
+                checkBounds(idx, MAX_ALPHA_SIZE, "zvec");
                 nextSym = perm_zt[idx];
             }
         }
@@ -713,17 +713,17 @@ private void getAndMoveToFrontDecode() throws IOException {
     private int getAndMoveToFrontDecode0() throws IOException {
         final Data dataShadow = this.data;
         final int zt = dataShadow.selector[0] & 0xff;
-        checkBounds(zt, N_GROUPS - 1, "zt");
+        checkBounds(zt, N_GROUPS, "zt");
         final int[] limit_zt = dataShadow.limit[zt];
         int zn = dataShadow.minLens[zt];
-        checkBounds(zn, MAX_ALPHA_SIZE - 1, "zn");
+        checkBounds(zn, MAX_ALPHA_SIZE, "zn");
         int zvec = bsR(bin, zn);
         while (zvec > limit_zt[zn]) {
-            checkBounds(++zn, MAX_ALPHA_SIZE - 1, "zn");
+            checkBounds(++zn, MAX_ALPHA_SIZE, "zn");
             zvec = (zvec << 1) | bsR(bin, 1);
         }
         final int tmp = zvec - dataShadow.base[zt][zn];
-        checkBounds(tmp, MAX_ALPHA_SIZE - 1, "zvec");
+        checkBounds(tmp, MAX_ALPHA_SIZE, "zvec");
 
         return dataShadow.perm[zt][tmp];
     }
@@ -734,7 +734,8 @@ private int setupBlock() throws IOException {
         }
 
         final int[] cftab = this.data.cftab;
-        final int[] tt = this.data.initTT(this.last + 1);
+        final int ttLen = this.last + 1;
+        final int[] tt = this.data.initTT(ttLen);
         final byte[] ll8 = this.data.ll8;
         cftab[0] = 0;
         System.arraycopy(this.data.unzftab, 0, cftab, 1, 256);
@@ -746,7 +747,7 @@ private int setupBlock() throws IOException {
 
         for (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {
             final int tmp = cftab[ll8[i] & 0xff]++;
-            checkBounds(tmp, this.last, "tt index");
+            checkBounds(tmp, ttLen, "tt index");
             tt[tmp] = i;
         }
 
@@ -771,7 +772,7 @@ private int setupRandPartA() throws IOException {
         if (this.su_i2 <= this.last) {
             this.su_chPrev = this.su_ch2;
             int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
-            checkBounds(this.su_tPos, this.data.tt.length - 1, "su_tPos");
+            checkBounds(this.su_tPos, this.data.tt.length, "su_tPos");
             this.su_tPos = this.data.tt[this.su_tPos];
             if (this.su_rNToGo == 0) {
                 this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
@@ -797,7 +798,7 @@ private int setupNoRandPartA() throws IOException {
             this.su_chPrev = this.su_ch2;
             final int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;
             this.su_ch2 = su_ch2Shadow;
-            checkBounds(this.su_tPos, this.data.tt.length - 1, "su_tPos");
+            checkBounds(this.su_tPos, this.data.tt.length, "su_tPos");
             this.su_tPos = this.data.tt[this.su_tPos];
             this.su_i2++;
             this.currentState = NO_RAND_PART_B_STATE;
@@ -817,7 +818,7 @@ private int setupRandPartB() throws IOException {
             return setupRandPartA();
         } else if (++this.su_count >= 4) {
             this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);
-            checkBounds(this.su_tPos, this.data.tt.length - 1, "su_tPos");
+            checkBounds(this.su_tPos, this.data.tt.length, "su_tPos");
             this.su_tPos = this.data.tt[this.su_tPos];
             if (this.su_rNToGo == 0) {
                 this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;
@@ -856,7 +857,7 @@ private int setupNoRandPartB() throws IOException {
             this.su_count = 1;
             return setupNoRandPartA();
         } else if (++this.su_count >= 4) {
-            checkBounds(this.su_tPos, this.data.ll8.length - 1, "su_tPos");
+            checkBounds(this.su_tPos, this.data.ll8.length, "su_tPos");
             this.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);
             this.su_tPos = this.data.tt[this.su_tPos];
             this.su_j2 = 0;
