From d182f07d6aa3e2e9685a126da5953fe7f0d8206c Mon Sep 17 00:00:00 2001
From: Gilles Sadowski <erans@apache.org>
Date: Wed, 4 Jul 2012 18:00:02 +0000
Subject: [PATCH] MATH-798 Added overridden "fit" method where one can specify
 the maximum number of function evaluations.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1357353 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  4 +
 .../fitting/PolynomialFitter.java             | 17 ++++
 .../optimization/fitting/CurveFitterTest.java | 63 --------------
 .../fitting/PolynomialFitterTest.java         | 85 +++++++++++++++++++
 4 files changed, 106 insertions(+), 63 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 0ec6fd2b02..609fa3314f 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -52,6 +52,10 @@ If the output is not quite correct, check for invisible trailing spaces!
   <body>
     <release version="3.1" date="TBD" description="
 ">
+      <action dev="erans" type="fix" issue="MATH-798">
+        Added overridden method in "PolynomialFitter" (package
+        "o.a.c.m.optimization.fitting") to limit the number of evaluations.
+      </action>
       <action dev="celestin" type="add" issue="MATH-807">
         Added a new constructor to o.a.c.m.utils.IterationManager, allowing
         for the specification of a callback function in case the maximum
diff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java
index 4f32da6999..2ae9fc5705 100644
--- a/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java
+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/PolynomialFitter.java
@@ -71,6 +71,23 @@ public double[] fit() {
         return fit(new PolynomialFunction.Parametric(), new double[degree + 1]);
     }
 
+    /**
+     * Get the coefficients of the polynomial fitting the weighted data points.
+     * The degree of the fitting polynomial is {@code guess.length - 1}.
+     *
+     * @param guess First guess for the coefficients. They must be sorted in
+     * increasing order of the polynomial's degree.
+     * @param maxEval Maximum number of evaluations of the polynomial.
+     * @return the coefficients of the polynomial that best fits the observed points.
+     * @throws org.apache.commons.math3.exception.TooManyEvaluationsException if
+     * the number of evaluations exceeds {@code maxEval}.
+     * @throws org.apache.commons.math3.exception.ConvergenceException
+     * if the algorithm failed to converge.
+     */
+    public double[] fit(int maxEval, double[] guess) {
+        return fit(maxEval, new PolynomialFunction.Parametric(), guess);
+    }
+
     /**
      * Get the coefficients of the polynomial fitting the weighted data points.
      * The degree of the fitting polynomial is {@code guess.length - 1}.
diff --git a/src/test/java/org/apache/commons/math3/optimization/fitting/CurveFitterTest.java b/src/test/java/org/apache/commons/math3/optimization/fitting/CurveFitterTest.java
index 8f40134e8f..c39cd43835 100644
--- a/src/test/java/org/apache/commons/math3/optimization/fitting/CurveFitterTest.java
+++ b/src/test/java/org/apache/commons/math3/optimization/fitting/CurveFitterTest.java
@@ -138,69 +138,6 @@ public double[] gradient(double x, double ... parameters) {
 
     }
 
-    @Test
-    public void testMath798() {
-        final double tol = 1e-14;
-        final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol);
-        final double[] init = new double[] { 0, 0 };
-        final int maxEval = 3;
-
-        final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init);
-        final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init);
-
-        for (int i = 0; i <= 1; i++) {
-            Assert.assertEquals(lm[i], gn[i], tol);
-        }
-    }
-
-    /**
-     * @param optimizer Optimizer.
-     * @param maxEval Maximum number of function evaluations.
-     * @param init First guess.
-     * @return the solution found by the given optimizer.
-     */
-    private double[] doMath798(DifferentiableMultivariateVectorOptimizer optimizer,
-                               int maxEval,
-                               double[] init) {
-        final CurveFitter fitter = new CurveFitter(optimizer);
-
-        fitter.addObservedPoint(-0.2, -7.12442E-13);
-        fitter.addObservedPoint(-0.199, -4.33397E-13);
-        fitter.addObservedPoint(-0.198, -2.823E-13);
-        fitter.addObservedPoint(-0.197, -1.40405E-13);
-        fitter.addObservedPoint(-0.196, -7.80821E-15);
-        fitter.addObservedPoint(-0.195, 6.20484E-14);
-        fitter.addObservedPoint(-0.194, 7.24673E-14);
-        fitter.addObservedPoint(-0.193, 1.47152E-13);
-        fitter.addObservedPoint(-0.192, 1.9629E-13);
-        fitter.addObservedPoint(-0.191, 2.12038E-13);
-        fitter.addObservedPoint(-0.19, 2.46906E-13);
-        fitter.addObservedPoint(-0.189, 2.77495E-13);
-        fitter.addObservedPoint(-0.188, 2.51281E-13);
-        fitter.addObservedPoint(-0.187, 2.64001E-13);
-        fitter.addObservedPoint(-0.186, 2.8882E-13);
-        fitter.addObservedPoint(-0.185, 3.13604E-13);
-        fitter.addObservedPoint(-0.184, 3.14248E-13);
-        fitter.addObservedPoint(-0.183, 3.1172E-13);
-        fitter.addObservedPoint(-0.182, 3.12912E-13);
-        fitter.addObservedPoint(-0.181, 3.06761E-13);
-        fitter.addObservedPoint(-0.18, 2.8559E-13);
-        fitter.addObservedPoint(-0.179, 2.86806E-13);
-        fitter.addObservedPoint(-0.178, 2.985E-13);
-        fitter.addObservedPoint(-0.177, 2.67148E-13);
-        fitter.addObservedPoint(-0.176, 2.94173E-13);
-        fitter.addObservedPoint(-0.175, 3.27528E-13);
-        fitter.addObservedPoint(-0.174, 3.33858E-13);
-        fitter.addObservedPoint(-0.173, 2.97511E-13);
-        fitter.addObservedPoint(-0.172, 2.8615E-13);
-        fitter.addObservedPoint(-0.171, 2.84624E-13);
-
-        final double[] coeff = fitter.fit(maxEval,
-                                          new PolynomialFunction.Parametric(),
-                                          init);
-        return coeff;
-    }
-
     private static class SimpleInverseFunction implements ParametricUnivariateFunction {
 
         public double value(double x, double ... parameters) {
diff --git a/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java b/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java
index cfc8436247..4976ae9262 100644
--- a/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java
+++ b/src/test/java/org/apache/commons/math3/optimization/fitting/PolynomialFitterTest.java
@@ -21,6 +21,7 @@
 
 import org.apache.commons.math3.analysis.polynomials.PolynomialFunction;
 import org.apache.commons.math3.exception.ConvergenceException;
+import org.apache.commons.math3.exception.TooManyEvaluationsException;
 import org.apache.commons.math3.optimization.DifferentiableMultivariateVectorOptimizer;
 import org.apache.commons.math3.optimization.general.GaussNewtonOptimizer;
 import org.apache.commons.math3.optimization.general.LevenbergMarquardtOptimizer;
@@ -107,6 +108,90 @@ public void testSmallError() {
         Assert.assertTrue(maxError > 0.01);
     }
 
+    @Test
+    public void testMath798() {
+        final double tol = 1e-14;
+        final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol);
+        final double[] init = new double[] { 0, 0 };
+        final int maxEval = 3;
+
+        final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init);
+        final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init);
+
+        for (int i = 0; i <= 1; i++) {
+            Assert.assertEquals(lm[i], gn[i], tol);
+        }
+    }
+
+    /**
+     * This test shows that the user can set the maximum number of iterations
+     * to avoid running for too long.
+     * But in the test case, the real problem is that the tolerance is way too
+     * stringent.
+     */
+    @Test(expected=TooManyEvaluationsException.class)
+    public void testMath798WithToleranceTooLow() {
+        final double tol = 1e-100;
+        final SimpleVectorValueChecker checker = new SimpleVectorValueChecker(tol, tol);
+        final double[] init = new double[] { 0, 0 };
+        final int maxEval = 10000; // Trying hard to fit.
+
+        final double[] lm = doMath798(new LevenbergMarquardtOptimizer(checker), maxEval, init);
+        final double[] gn = doMath798(new GaussNewtonOptimizer(checker), maxEval, init);
+
+        for (int i = 0; i <= 1; i++) {
+            Assert.assertEquals(lm[i], gn[i], tol);
+        }
+    }
+
+    /**
+     * @param optimizer Optimizer.
+     * @param maxEval Maximum number of function evaluations.
+     * @param init First guess.
+     * @return the solution found by the given optimizer.
+     */
+    private double[] doMath798(DifferentiableMultivariateVectorOptimizer optimizer,
+                               int maxEval,
+                               double[] init) {
+        final CurveFitter fitter = new CurveFitter(optimizer);
+
+        fitter.addObservedPoint(-0.2, -7.12442E-13);
+        fitter.addObservedPoint(-0.199, -4.33397E-13);
+        fitter.addObservedPoint(-0.198, -2.823E-13);
+        fitter.addObservedPoint(-0.197, -1.40405E-13);
+        fitter.addObservedPoint(-0.196, -7.80821E-15);
+        fitter.addObservedPoint(-0.195, 6.20484E-14);
+        fitter.addObservedPoint(-0.194, 7.24673E-14);
+        fitter.addObservedPoint(-0.193, 1.47152E-13);
+        fitter.addObservedPoint(-0.192, 1.9629E-13);
+        fitter.addObservedPoint(-0.191, 2.12038E-13);
+        fitter.addObservedPoint(-0.19, 2.46906E-13);
+        fitter.addObservedPoint(-0.189, 2.77495E-13);
+        fitter.addObservedPoint(-0.188, 2.51281E-13);
+        fitter.addObservedPoint(-0.187, 2.64001E-13);
+        fitter.addObservedPoint(-0.186, 2.8882E-13);
+        fitter.addObservedPoint(-0.185, 3.13604E-13);
+        fitter.addObservedPoint(-0.184, 3.14248E-13);
+        fitter.addObservedPoint(-0.183, 3.1172E-13);
+        fitter.addObservedPoint(-0.182, 3.12912E-13);
+        fitter.addObservedPoint(-0.181, 3.06761E-13);
+        fitter.addObservedPoint(-0.18, 2.8559E-13);
+        fitter.addObservedPoint(-0.179, 2.86806E-13);
+        fitter.addObservedPoint(-0.178, 2.985E-13);
+        fitter.addObservedPoint(-0.177, 2.67148E-13);
+        fitter.addObservedPoint(-0.176, 2.94173E-13);
+        fitter.addObservedPoint(-0.175, 3.27528E-13);
+        fitter.addObservedPoint(-0.174, 3.33858E-13);
+        fitter.addObservedPoint(-0.173, 2.97511E-13);
+        fitter.addObservedPoint(-0.172, 2.8615E-13);
+        fitter.addObservedPoint(-0.171, 2.84624E-13);
+
+        final double[] coeff = fitter.fit(maxEval,
+                                          new PolynomialFunction.Parametric(),
+                                          init);
+        return coeff;
+    }
+
     @Test
     public void testRedundantSolvable() {
         // Levenberg-Marquardt should handle redundant information gracefully
