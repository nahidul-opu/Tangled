From 21015931d11bae2a37e390ff70ae55606a692ac1 Mon Sep 17 00:00:00 2001
From: "Gary D. Gregory" <ggregory@apache.org>
Date: Mon, 26 Sep 2011 17:54:06 +0000
Subject: [PATCH] [CODEC-130] Base64InputStream.skip skips underlying stream,
 not output. Add tests for skip(long) edge cases for the Base32 version of the
 code.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1175974 13f79535-47bb-0310-9956-ffa450edef68
---
 .../codec/binary/Base32InputStreamTest.java   | 232 +++++++++++-------
 1 file changed, 139 insertions(+), 93 deletions(-)

diff --git a/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java b/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java
index db3142486c..147c38f6d2 100644
--- a/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java
+++ b/src/test/java/org/apache/commons/codec/binary/Base32InputStreamTest.java
@@ -17,6 +17,7 @@
 
 package org.apache.commons.codec.binary;
 
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -31,9 +32,11 @@
 
 public class Base32InputStreamTest {
 
-    private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
+    private static final String ENCODED_FOO = "MZXW6===";
 
-    private final static byte[] LF = {(byte) '\n'};
+    private final static byte[] CRLF = { (byte) '\r', (byte) '\n' };
+
+    private final static byte[] LF = { (byte) '\n' };
 
     /**
      * Tests the bug reported in CODEC-105. Bad interactions with InputStream when reading one byte at a time.
@@ -50,75 +53,71 @@ public void testCodec105() throws IOException {
         }
     }
 
-//    /**
-//     * Test for the CODEC-101 bug:  InputStream.read(byte[]) should never return 0
-//     * because Java's builtin InputStreamReader hates that.
-//     *
-//     * @throws Exception for some failure scenarios.
-//     */
-//    @Test
-//    public void testCodec101() throws Exception {
-//        byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);
-//        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);
-//        Base32InputStream in = new Base32InputStream(bais);
-//        byte[] result = new byte[8192];
-//        int c = in.read(result);
-//        assertTrue("Codec101: First read successful [c=" + c + "]", c > 0);
-//
-//        c = in.read(result);
-//        assertTrue("Codec101: Second read should report end-of-stream [c=" + c + "]", c < 0);
-//    }
+    // /**
+    // * Test for the CODEC-101 bug: InputStream.read(byte[]) should never return 0
+    // * because Java's builtin InputStreamReader hates that.
+    // *
+    // * @throws Exception for some failure scenarios.
+    // */
+    // @Test
+    // public void testCodec101() throws Exception {
+    // byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);
+    // ByteArrayInputStream bais = new ByteArrayInputStream(codec101);
+    // Base32InputStream in = new Base32InputStream(bais);
+    // byte[] result = new byte[8192];
+    // int c = in.read(result);
+    // assertTrue("Codec101: First read successful [c=" + c + "]", c > 0);
+    //
+    // c = in.read(result);
+    // assertTrue("Codec101: Second read should report end-of-stream [c=" + c + "]", c < 0);
+    // }
 
     /**
-     * Another test for the CODEC-101 bug:
-     * In commons-codec-1.4 this test shows InputStreamReader explicitly hating an
+     * Another test for the CODEC-101 bug: In commons-codec-1.4 this test shows InputStreamReader explicitly hating an
      * InputStream.read(byte[]) return of 0:
-     *
-     * java.io.IOException: Underlying input stream returned zero bytes
-     * at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268)
-     * at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306)
-     * at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158)
-     * at java.io.InputStreamReader.read(InputStreamReader.java:167)
-     * at java.io.BufferedReader.fill(BufferedReader.java:136)
-     * at java.io.BufferedReader.readLine(BufferedReader.java:299)
-     * at java.io.BufferedReader.readLine(BufferedReader.java:362)
-     * at org.apache.commons.codec.binary.Base32InputStreamTest.testInputStreamReader(Base32InputStreamTest.java:75)
-     *
-     * But in commons-codec-1.5 it's fixed.  :-)
-     *
-     * @throws Exception for some failure scenarios.
+     * 
+     * java.io.IOException: Underlying input stream returned zero bytes at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:268) at
+     * sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:306) at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:158) at
+     * java.io.InputStreamReader.read(InputStreamReader.java:167) at java.io.BufferedReader.fill(BufferedReader.java:136) at
+     * java.io.BufferedReader.readLine(BufferedReader.java:299) at java.io.BufferedReader.readLine(BufferedReader.java:362) at
+     * org.apache.commons.codec.binary.Base32InputStreamTest.testInputStreamReader(Base32InputStreamTest.java:75)
+     * 
+     * But in commons-codec-1.5 it's fixed. :-)
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
      */
-//    @Test
-//    public void testInputStreamReader() throws Exception {
-//        byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);
-//        ByteArrayInputStream bais = new ByteArrayInputStream(codec101);
-//        Base32InputStream in = new Base32InputStream(bais);
-//        InputStreamReader isr = new InputStreamReader(in);
-//        BufferedReader br = new BufferedReader(isr);
-//        String line = br.readLine();
-//        assertNotNull("Codec101:  InputStreamReader works!", line);
-//    }
+    // @Test
+    // public void testInputStreamReader() throws Exception {
+    // byte[] codec101 = StringUtils.getBytesUtf8(Base32TestData.CODEC_101_MULTIPLE_OF_3);
+    // ByteArrayInputStream bais = new ByteArrayInputStream(codec101);
+    // Base32InputStream in = new Base32InputStream(bais);
+    // InputStreamReader isr = new InputStreamReader(in);
+    // BufferedReader br = new BufferedReader(isr);
+    // String line = br.readLine();
+    // assertNotNull("Codec101:  InputStreamReader works!", line);
+    // }
 
     /**
-     * Test the Base32InputStream implementation against the special NPE inducing input
-     * identified in the CODEC-98 bug.
-     *
-     * @throws Exception for some failure scenarios.
+     * Test the Base32InputStream implementation against the special NPE inducing input identified in the CODEC-98 bug.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
      */
-//    @Test
-//    public void testCodec98NPE() throws Exception {
-//        byte[] codec98 = StringUtils.getBytesUtf8(Base32TestData.CODEC_98_NPE);
-//        ByteArrayInputStream data = new ByteArrayInputStream(codec98);
-//        Base32InputStream stream = new Base32InputStream(data);
-//
-//        // This line causes an NPE in commons-codec-1.4.jar:
-//        byte[] decodedBytes = Base32TestData.streamToBytes(stream, new byte[1024]);
-//
-//        String decoded = StringUtils.newStringUtf8(decodedBytes);
-//        assertEquals(
-//            "codec-98 NPE Base32InputStream", Base32TestData.CODEC_98_NPE_DECODED, decoded
-//        );
-//    }
+    // @Test
+    // public void testCodec98NPE() throws Exception {
+    // byte[] codec98 = StringUtils.getBytesUtf8(Base32TestData.CODEC_98_NPE);
+    // ByteArrayInputStream data = new ByteArrayInputStream(codec98);
+    // Base32InputStream stream = new Base32InputStream(data);
+    //
+    // // This line causes an NPE in commons-codec-1.4.jar:
+    // byte[] decodedBytes = Base32TestData.streamToBytes(stream, new byte[1024]);
+    //
+    // String decoded = StringUtils.newStringUtf8(decodedBytes);
+    // assertEquals(
+    // "codec-98 NPE Base32InputStream", Base32TestData.CODEC_98_NPE_DECODED, decoded
+    // );
+    // }
 
     /**
      * Tests the Base32InputStream implementation against empty input.
@@ -164,19 +163,19 @@ public void testBase32InputStreamByChunk() throws Exception {
 
         // Single Byte test.
         encoded = StringUtils.getBytesUtf8("AA======\r\n");
-        decoded = new byte[]{(byte) 0};
+        decoded = new byte[] { (byte) 0 };
         testByChunk(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);
 
-//        // OpenSSL interop test.
-//        encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE);
-//        decoded = Base32TestData.DECODED;
-//        testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF);
-//
-//        // Single Line test.
-//        String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("\n", "");
-//        encoded = StringUtils.getBytesUtf8(singleLine);
-//        decoded = Base32TestData.DECODED;
-//        testByChunk(encoded, decoded, 0, LF);
+        // // OpenSSL interop test.
+        // encoded = StringUtils.getBytesUtf8(Base32TestData.ENCODED_32_CHARS_PER_LINE);
+        // decoded = Base32TestData.DECODED;
+        // testByChunk(encoded, decoded, Base32.PEM_CHUNK_SIZE, LF);
+        //
+        // // Single Line test.
+        // String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("\n", "");
+        // encoded = StringUtils.getBytesUtf8(singleLine);
+        // decoded = Base32TestData.DECODED;
+        // testByChunk(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         BaseNCodec codec = new Base32();
@@ -203,14 +202,14 @@ public void testBase32InputStreamByteByByte() throws Exception {
 
         // Single Byte test.
         encoded = StringUtils.getBytesUtf8("AA======\r\n");
-        decoded = new byte[]{(byte) 0};
+        decoded = new byte[] { (byte) 0 };
         testByteByByte(encoded, decoded, BaseNCodec.MIME_CHUNK_SIZE, CRLF);
 
-//        // Single Line test.
-//        String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("\n", "");
-//        encoded = StringUtils.getBytesUtf8(singleLine);
-//        decoded = Base32TestData.DECODED;
-//        testByteByByte(encoded, decoded, 0, LF);
+        // // Single Line test.
+        // String singleLine = Base32TestData.ENCODED_32_CHARS_PER_LINE.replaceAll("\n", "");
+        // encoded = StringUtils.getBytesUtf8(singleLine);
+        // decoded = Base32TestData.DECODED;
+        // testByteByByte(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         BaseNCodec codec = new Base32();
@@ -223,11 +222,11 @@ public void testBase32InputStreamByteByByte() throws Exception {
     }
 
     /**
-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded
+     * ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base32InputStream wraps itself in encode and decode mode
-     * over and over again.
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base32InputStream wraps itself in encode and decode mode over and over
+     * again.
      * 
      * @param encoded
      *            base32 encoded data
@@ -274,11 +273,11 @@ private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] s
     }
 
     /**
-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]--> encoded 3. decoded
+     * ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base32InputStream wraps itself in encode and decode mode
-     * over and over again.
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base32InputStream wraps itself in encode and decode mode over and over
+     * again.
      * 
      * @param encoded
      *            base32 encoded data
@@ -342,7 +341,7 @@ private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[
     public void testMarkSupported() throws Exception {
         byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});
+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });
         // Always returns false for now.
         assertFalse("Base32InputStream.markSupported() is false", in.markSupported());
     }
@@ -358,7 +357,7 @@ public void testRead0() throws Exception {
         byte[] buf = new byte[1024];
         int bytesRead = 0;
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});
+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });
         bytesRead = in.read(buf, 0, 0);
         assertEquals("Base32InputStream.read(buf, 0, 0) returns 0", 0, bytesRead);
     }
@@ -373,7 +372,7 @@ public void testRead0() throws Exception {
     public void testReadNull() throws Exception {
         byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});
+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });
         try {
             in.read(null, 0, 0);
             fail("Base32InputStream.read(null, 0, 0) to throw a NullPointerException");
@@ -392,7 +391,7 @@ public void testReadOutOfBounds() throws Exception {
         byte[] decoded = StringUtils.getBytesUtf8(Base32TestData.STRING_FIXTURE);
         byte[] buf = new byte[1024];
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
-        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[]{0, 0, 0});
+        Base32InputStream in = new Base32InputStream(bin, true, 4, new byte[] { 0, 0, 0 });
 
         try {
             in.read(buf, -1, 0);
@@ -422,4 +421,51 @@ public void testReadOutOfBounds() throws Exception {
             // Expected
         }
     }
+
+    /**
+     * Tests skipping as a noop
+     * 
+     * @throws Throwable
+     */
+    @Test
+    public void testSkipNone() throws Throwable {
+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
+        Base32InputStream b32stream = new Base32InputStream(ins);
+        byte[] actualBytes = new byte[6];
+        assertEquals(0, b32stream.skip(0));
+        b32stream.read(actualBytes, 0, actualBytes.length);
+        assertArrayEquals(actualBytes, new byte[] { 102, 111, 111, 0, 0, 0 });
+        // End of stream reached
+        assertEquals(-1, b32stream.read());
+    }
+
+    /**
+     * Tests skipping past the end of a stream.
+     * 
+     * @throws Throwable
+     */
+    @Test
+    public void testSkipPastEnd() throws Throwable {
+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
+        Base32InputStream b32stream = new Base32InputStream(ins);
+        assertEquals(8, b32stream.skip(10));
+        // End of stream reached
+        assertEquals(-1, b32stream.read());
+        assertEquals(-1, b32stream.read());
+    }
+
+    /**
+     * Tests skipping to the end of a stream.
+     * 
+     * @throws Throwable
+     */
+    @Test
+    public void testSkipToEnd() throws Throwable {
+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_FOO));
+        Base32InputStream b32stream = new Base32InputStream(ins);
+        assertEquals(8, b32stream.skip(8));
+        // End of stream reached
+        assertEquals(-1, b32stream.read());
+        assertEquals(-1, b32stream.read());
+    }
 }
