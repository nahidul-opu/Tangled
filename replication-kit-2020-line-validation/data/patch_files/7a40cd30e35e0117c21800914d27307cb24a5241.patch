From 7a40cd30e35e0117c21800914d27307cb24a5241 Mon Sep 17 00:00:00 2001
From: Rahul Akolkar <rahul@apache.org>
Date: Tue, 4 Dec 2007 21:58:33 +0000
Subject: [PATCH] SCXML-58 Object model not stateless Tests (now pass)
 contributed by Mike Tillberg <mtillberg at comcast dot net>

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/scxml/trunk@601100 13f79535-47bb-0310-9956-ffa450edef68
---
 .../org/apache/commons/scxml/SCInstance.java  | 35 ++++++++
 .../org/apache/commons/scxml/model/State.java |  6 ++
 .../scxml/semantics/SCXMLSemanticsImpl.java   |  8 +-
 .../scxml/model/StatelessModelTest.java       | 88 ++++++++++++++++++-
 .../scxml/model/stateless-parallel-01.xml     | 54 ++++++++++++
 5 files changed, 184 insertions(+), 7 deletions(-)
 create mode 100644 src/test/java/org/apache/commons/scxml/model/stateless-parallel-01.xml

diff --git a/src/main/java/org/apache/commons/scxml/SCInstance.java b/src/main/java/org/apache/commons/scxml/SCInstance.java
index c8c5dd054..1ad3acfe3 100644
--- a/src/main/java/org/apache/commons/scxml/SCInstance.java
+++ b/src/main/java/org/apache/commons/scxml/SCInstance.java
@@ -58,6 +58,12 @@ public class SCInstance implements Serializable {
      */
     private Map histories;
 
+    /**
+     * <code>Map</code> for recording the run to completion status of
+     * composite states.
+     */
+    private Map completions;
+
     /**
      * The <code>Invoker</code> classes <code>Map</code>, keyed by
      * &lt;invoke&gt; target types (specified using "targettype" attribute).
@@ -96,6 +102,7 @@ public class SCInstance implements Serializable {
         this.histories = Collections.synchronizedMap(new HashMap());
         this.invokerClasses = Collections.synchronizedMap(new HashMap());
         this.invokers = Collections.synchronizedMap(new HashMap());
+        this.completions = Collections.synchronizedMap(new HashMap());
         this.evaluator = null;
         this.rootContext = null;
         this.executor = executor;
@@ -356,5 +363,33 @@ public Map getInvokers() {
         return invokers;
     }
 
+    /**
+     * Get the completion status for this composite
+     * {@link TransitionTarget}.
+     *
+     * @param transitionTarget The <code>TransitionTarget</code>.
+     * @return The completion status.
+     */
+    public boolean isDone(final TransitionTarget transitionTarget) {
+        Boolean done = (Boolean) completions.get(transitionTarget);
+        if (done == null) {
+            return false;
+        } else {
+            return done.booleanValue();
+        }
+    }
+
+    /**
+     * Set the completion status for this composite
+     * {@link TransitionTarget}.
+     *
+     * @param transitionTarget The TransitionTarget.
+     * @param done The completion status.
+     */
+    public void setDone(final TransitionTarget transitionTarget,
+            final boolean done) {
+        completions.put(transitionTarget, done ? Boolean.TRUE : Boolean.FALSE);
+    }
+
 }
 
diff --git a/src/main/java/org/apache/commons/scxml/model/State.java b/src/main/java/org/apache/commons/scxml/model/State.java
index 8d8380db6..5fb079d13 100644
--- a/src/main/java/org/apache/commons/scxml/model/State.java
+++ b/src/main/java/org/apache/commons/scxml/model/State.java
@@ -78,6 +78,8 @@ public class State extends TransitionTarget {
      * Applies to composite states only. If one of its final children is
      * active, its parent is marked done. This property is reset upon
      * re-entry.
+     *
+     * @deprecated Will be removed in v1.0
      */
     private boolean done = false;
 
@@ -350,6 +352,8 @@ public final boolean isOrthogonal() {
      * is active.
      *
      * @return Returns the done.
+     * @deprecated Will be removed in v1.0, in favor of
+     *             <code>SCInstance#isDone(TransitionTarget)</code>
      */
     public final boolean isDone() {
         return done;
@@ -360,6 +364,8 @@ public final boolean isDone() {
      * and one its final states is active.
      *
      * @param done The done to set.
+     * @deprecated Will be removed in v1.0, in favor of
+     *             <code>SCInstance#setDone(TransitionTarget)</code>
      */
     public final void setDone(final boolean done) {
         this.done = done;
diff --git a/src/main/java/org/apache/commons/scxml/semantics/SCXMLSemanticsImpl.java b/src/main/java/org/apache/commons/scxml/semantics/SCXMLSemanticsImpl.java
index 1cbde2b82..b4be968d6 100644
--- a/src/main/java/org/apache/commons/scxml/semantics/SCXMLSemanticsImpl.java
+++ b/src/main/java/org/apache/commons/scxml/semantics/SCXMLSemanticsImpl.java
@@ -254,7 +254,7 @@ public void executeActions(final Step step, final SCXML stateMachine,
                             TriggerEvent.CHANGE_EVENT);
                     internalEvents.add(te);
                     if (parent != null) {
-                        parent.setDone(true);
+                        scInstance.setDone(parent, true);
                     }
                     if (parent != null && parent.isRegion()) {
                         //3.4 we got a region, which is finalized
@@ -265,7 +265,7 @@ public void executeActions(final Step step, final SCXML stateMachine,
                         for (Iterator regions = p.getChildren().iterator();
                                 regions.hasNext();) {
                             State reg = (State) regions.next();
-                            if (reg.isDone()) {
+                            if (scInstance.isDone(reg)) {
                                 finCount++;
                             }
                         }
@@ -277,7 +277,7 @@ public void executeActions(final Step step, final SCXML stateMachine,
                                 + ".done", TriggerEvent.CHANGE_EVENT);
                             internalEvents.add(te);
                             //this is not in the specs, but is makes sense
-                            p.getParentState().setDone(true);
+                            scInstance.setDone(p.getParentState(), true);
                         }
                     }
                 }
@@ -704,7 +704,7 @@ public void followTransitions(final Step step,
         for (Iterator reset = entering.iterator(); reset.hasNext();) {
             Object o = reset.next();
             if (o instanceof State) {
-                ((State) o).setDone(false);
+                scInstance.setDone((State) o, false);
             }
         }
     }
diff --git a/src/test/java/org/apache/commons/scxml/model/StatelessModelTest.java b/src/test/java/org/apache/commons/scxml/model/StatelessModelTest.java
index d7ce1462e..4d9acd728 100644
--- a/src/test/java/org/apache/commons/scxml/model/StatelessModelTest.java
+++ b/src/test/java/org/apache/commons/scxml/model/StatelessModelTest.java
@@ -17,6 +17,7 @@
 package org.apache.commons.scxml.model;
 
 import java.net.URL;
+import java.util.Iterator;
 import java.util.Set;
 
 import junit.framework.Test;
@@ -48,9 +49,9 @@ public static Test suite() {
     }
 
     // Test data
-    private URL stateless01jexl, stateless01jsp;
-    private SCXML scxml01jexl, scxml01jsp;
-    private SCXMLExecutor exec01, exec02;
+    private URL stateless01jexl, stateless01jsp, stateless01par;
+    private SCXML scxml01jexl, scxml01jsp, scxml01par, scxml02par;
+    private SCXMLExecutor exec01, exec02, exec03;
 
     /**
      * Set up instance variables required by this test case.
@@ -60,8 +61,12 @@ public void setUp() {
             getResource("org/apache/commons/scxml/env/jexl/stateless-01.xml");
         stateless01jsp = this.getClass().getClassLoader().
             getResource("org/apache/commons/scxml/env/jsp/stateless-01.xml");
+        stateless01par = this.getClass().getClassLoader().
+            getResource("org/apache/commons/scxml/model/stateless-parallel-01.xml");
         scxml01jexl = SCXMLTestHelper.digest(stateless01jexl);
         scxml01jsp = SCXMLTestHelper.digest(stateless01jsp);
+        scxml01par = SCXMLTestHelper.digest(stateless01par);
+        scxml02par = SCXMLTestHelper.digest(stateless01par);
     }
 
     /**
@@ -124,6 +129,83 @@ public void testStatelessModelSequentialEl() {
         }
     }
 
+    /**
+     * Test sharing a single SCXML object between two executors
+     */
+    public void testStatelessModelParallelSharedSCXML() {
+        exec01 = SCXMLTestHelper.getExecutor(scxml01par);
+        assertNotNull(exec01);
+        exec02 = SCXMLTestHelper.getExecutor(scxml01par);
+        assertNotNull(exec02);
+        assertFalse(exec01 == exec02);
+
+        Set currentStates = exec01.getCurrentStatus().getStates();
+        checkParallelStates(currentStates, "state1.init", "state2.init", "exec01");
+
+        currentStates = exec02.getCurrentStatus().getStates();
+        checkParallelStates(currentStates, "state1.init", "state2.init", "exec02");
+
+        currentStates = fireEvent("state1.event", exec01);
+        checkParallelStates(currentStates, "state1.final", "state2.init", "exec01");
+
+        currentStates = fireEvent("state2.event", exec02);
+        checkParallelStates(currentStates, "state1.init", "state2.final", "exec02");
+
+        currentStates = fireEvent("state2.event", exec01);
+        checkParallelStates(currentStates, "next", null, "exec01");
+
+        currentStates = fireEvent("state1.event", exec02);
+        checkParallelStates(currentStates, "next", null, "exec02");
+    }
+
+    /**
+     * Test sharing two SCXML objects between one executor (not recommended)
+     */
+    public void testStatelessModelParallelSwapSCXML() {
+        exec01 = SCXMLTestHelper.getExecutor(scxml01par);
+        assertNotNull(exec01);
+        assertTrue(scxml01par != scxml02par);
+
+        Set currentStates = exec01.getCurrentStatus().getStates();
+        checkParallelStates(currentStates, "state1.init", "state2.init", "exec01");
+
+        currentStates = fireEvent("state1.event", exec01);
+        checkParallelStates(currentStates, "state1.final", "state2.init", "exec01");
+        exec01.setStateMachine(scxml02par);
+
+        currentStates = fireEvent("state2.event", exec01);
+        checkParallelStates(currentStates, "next", null, "exec01");
+    }
+
+    private void checkParallelStates(Set currentStates, String s1, String s2,
+            String label) {
+        Iterator i = currentStates.iterator();
+        assertTrue("Not enough states", i.hasNext());
+        String cs1 = ((State) i.next()).getId();
+        String cs2 = null;
+        if (s2 != null) {
+            assertTrue("Not enough states, found one state: " + cs1, i.hasNext());
+            cs2 = ((State) i.next()).getId();
+            assertFalse("Too many states", i.hasNext());
+            if (s2.equals(cs2)) {
+                cs2 = null;
+            } else if (s1.equals(cs2)) {
+                cs2 = null;
+            } else {
+                fail(label + " in unexpected state " + cs2);
+            }
+        } else {
+            assertFalse("Too many states", i.hasNext());
+        }
+        if (s1 != null && s1.equals(cs1)) {
+            return;
+        }
+        if (s2 != null && s2.equals(cs1)) {
+            return;
+        }
+        fail(label + " in unexpected state " + cs1);
+    }
+
     private void runSimultaneousTest() {
         try {
             //// Interleaved
diff --git a/src/test/java/org/apache/commons/scxml/model/stateless-parallel-01.xml b/src/test/java/org/apache/commons/scxml/model/stateless-parallel-01.xml
new file mode 100644
index 000000000..f2e901728
--- /dev/null
+++ b/src/test/java/org/apache/commons/scxml/model/stateless-parallel-01.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0"?>
+<!--
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+-->
+<scxml xmlns="http://www.w3.org/2005/07/scxml"
+       version="1.0"
+       initialstate="main">
+
+    <state id="main">
+
+        <parallel id="main.parallel">
+
+            <state id="state1">
+                <initial>
+                    <transition target="state1.init"/>
+                </initial>
+                <state id="state1.init">
+                    <transition event="state1.event" target="state1.final" />
+                </state>
+                <state id="state1.final" final="true" />
+            </state>
+
+            <state id="state2">
+                <initial>
+                    <transition target="state2.init"/>
+                </initial>
+                <state id="state2.init">
+                    <transition event="state2.event" target="state2.final" />
+                </state>
+                <state id="state2.final" final="true" />
+            </state>
+
+        </parallel>
+
+        <transition event="main.parallel.done" target="next" />
+
+    </state>
+
+    <state id="next" final="true"/>
+
+</scxml>
