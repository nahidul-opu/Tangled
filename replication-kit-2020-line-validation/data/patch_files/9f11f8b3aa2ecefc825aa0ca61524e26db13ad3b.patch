From 9f11f8b3aa2ecefc825aa0ca61524e26db13ad3b Mon Sep 17 00:00:00 2001
From: Thomas Vandahl <tv@apache.org>
Date: Sun, 30 Oct 2011 21:02:22 +0000
Subject: [PATCH] Use oos.writeUnshared(), remove scheduled OOS reset. Fixes
 JCS-82

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/jcs/trunk@1195243 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  3 ++
 .../lateral/socket/tcp/LateralTCPSender.java  | 38 +------------------
 2 files changed, 5 insertions(+), 36 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 604264fe3..98d294f4f 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -20,6 +20,9 @@
 	</properties>
 	<body>
 		<release version="2.0" date="unreleased" description="JDK 1.5 based major release">
+            <action dev="tv" type="fix" issue="JCS-82" due-to="Nikunj Trivedi">
+                Use oos.writeUnshared() for LateralTCPSender
+            </action>
             <action dev="tv" type="fix" issue="JCS-69" due-to="Michael Stevens">
                 Ensure shutdown of LateralCacheMonitor
             </action>
diff --git a/src/java/org/apache/jcs/auxiliary/lateral/socket/tcp/LateralTCPSender.java b/src/java/org/apache/jcs/auxiliary/lateral/socket/tcp/LateralTCPSender.java
index c7993faaa..8a15fcd74 100644
--- a/src/java/org/apache/jcs/auxiliary/lateral/socket/tcp/LateralTCPSender.java
+++ b/src/java/org/apache/jcs/auxiliary/lateral/socket/tcp/LateralTCPSender.java
@@ -58,23 +58,9 @@ public class LateralTCPSender
     /** The socket connection with the server. */
     private Socket socket;
 
-    /** counter, for periodic OOS reset. */
-    int counter = 0;
-
     /** how many messages sent */
     private int sendCnt = 0;
 
-    // reset the ObjectOutputStream every 70 calls
-    // private static final int RESET_FREQUENCY = 70;
-    // Perhaps we need to reset every time until we move to jdk 1.4
-    // then we can call writeUnshared to make sure
-    // that the object definetely gets across and not
-    // a stream cached version.
-    // I can't replicate an issue that was reported, so I'm not changing the
-    // reset frequency for now.
-    /** How often we need to reset the stream. */
-    private final static int RESET_FREQUENCY = 70;
-
     /** Use to synchronize multiple threads that may be trying to get. */
     private final Object getLock = new int[0];
 
@@ -216,19 +202,8 @@ public void send( LateralElementDescriptor led )
             {
                 try
                 {
-                    oos.writeObject( led );
+                    oos.writeUnshared( led );
                     oos.flush();
-                    if ( ++counter >= RESET_FREQUENCY )
-                    {
-                        counter = 0;
-                        // Failing to reset the object output stream every now and
-                        // then creates a serious memory leak.
-                        if ( log.isDebugEnabled() )
-                        {
-                            log.debug( "Doing oos.reset()" );
-                        }
-                        oos.reset();
-                    }
                 }
                 catch ( IOException e )
                 {
@@ -292,7 +267,7 @@ public Object sendAndReceive( LateralElementDescriptor led )
                     }
 
                     // write object to listener
-                    oos.writeObject( led );
+                    oos.writeUnshared( led );
                     oos.flush();
 
                     try
@@ -313,15 +288,6 @@ public Object sendAndReceive( LateralElementDescriptor led )
                     {
                         log.error( e );
                     }
-
-                    if ( ++counter >= RESET_FREQUENCY )
-                    {
-                        counter = 0;
-                        // Failing to reset the object output stream every now
-                        // and then creates a serious memory leak.
-                        log.info( "Doing oos.reset()" );
-                        oos.reset();
-                    }
                 }
                 catch ( IOException e )
                 {
