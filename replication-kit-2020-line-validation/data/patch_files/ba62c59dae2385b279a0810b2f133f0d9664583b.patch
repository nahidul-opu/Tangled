From ba62c59dae2385b279a0810b2f133f0d9664583b Mon Sep 17 00:00:00 2001
From: Luc Maisonobe <luc@apache.org>
Date: Fri, 13 Jun 2014 14:20:05 +0000
Subject: [PATCH] Fixed overflow in Precision.equals with ulps.

Both double and float versions were affected.

JIRA: MATH-1127

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1602438 13f79535-47bb-0310-9956-ffa450edef68
---
 src/changes/changes.xml                       |  3 +
 .../apache/commons/math3/util/Precision.java  | 98 ++++++++++++++-----
 .../commons/math3/util/PrecisionTest.java     |  9 ++
 3 files changed, 83 insertions(+), 27 deletions(-)

diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index a1596e8baf..7603631716 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -73,6 +73,9 @@ Users are encouraged to upgrade to this version as this release not
   2. A few methods in the FastMath class are in fact slower that their
   counterpart in either Math or StrictMath (cf. MATH-740 and MATH-901).
 ">
+      <action dev="luc" type="fix" issue="MATH-1127">
+        Fixed overflow in Precision.equals with ulps (both double and float versions).
+      </action>
       <action dev="tn" type="fix" issue="MATH-1125" due-to="Ajo Fod">
         Performance improvements for Student's t-distribution.
       </action>
diff --git a/src/main/java/org/apache/commons/math3/util/Precision.java b/src/main/java/org/apache/commons/math3/util/Precision.java
index d08947617b..fa938c0083 100644
--- a/src/main/java/org/apache/commons/math3/util/Precision.java
+++ b/src/main/java/org/apache/commons/math3/util/Precision.java
@@ -62,6 +62,14 @@ public class Precision {
     private static final int SGN_MASK_FLOAT = 0x80000000;
     /** Positive zero. */
     private static final double POSITIVE_ZERO = 0d;
+    /** Positive zero bits. */
+    private static final long POSITIVE_ZERO_DOUBLE_BITS = Double.doubleToRawLongBits(+0.0);
+    /** Negative zero bits. */
+    private static final long NEGATIVE_ZERO_DOUBLE_BITS = Double.doubleToRawLongBits(-0.0);
+    /** Positive zero bits. */
+    private static final int POSITIVE_ZERO_FLOAT_BITS   = Float.floatToRawIntBits(+0.0f);
+    /** Negative zero bits. */
+    private static final int NEGATIVE_ZERO_FLOAT_BITS   = Float.floatToRawIntBits(-0.0f);
 
     static {
         /*
@@ -109,7 +117,7 @@ public static int compareTo(double x, double y, double eps) {
      * (or fewer) floating point numbers between them, i.e. two adjacent floating
      * point numbers are considered equal.
      * Adapted from <a
-     * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">
+     * href="http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">
      * Bruce Dawson</a>
      *
      * @param x first value
@@ -190,7 +198,7 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {
      * (or fewer) floating point numbers between them, i.e. two adjacent floating
      * point numbers are considered equal.
      * Adapted from <a
-     * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">
+     * href="http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">
      * Bruce Dawson</a>
      *
      * @param x first value
@@ -201,21 +209,37 @@ public static boolean equalsIncludingNaN(float x, float y, float eps) {
      * point values between {@code x} and {@code y}.
      * @since 2.2
      */
-    public static boolean equals(float x, float y, int maxUlps) {
-        int xInt = Float.floatToIntBits(x);
-        int yInt = Float.floatToIntBits(y);
+    public static boolean equals(final float x, final float y, final int maxUlps) {
+
+        final int xInt = Float.floatToRawIntBits(x);
+        final int yInt = Float.floatToRawIntBits(y);
+
+        final boolean isEqual;
+        if (((xInt ^ yInt) & SGN_MASK_FLOAT) == 0) {
+            // number have same sign, there is no risk of overflow
+            isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
+        } else {
+            // number have opposite signs, take care of overflow
+            final int deltaPlus;
+            final int deltaMinus;
+            if (xInt < yInt) {
+                deltaPlus  = yInt - POSITIVE_ZERO_FLOAT_BITS;
+                deltaMinus = xInt - NEGATIVE_ZERO_FLOAT_BITS;
+            } else {
+                deltaPlus  = xInt - POSITIVE_ZERO_FLOAT_BITS;
+                deltaMinus = yInt - NEGATIVE_ZERO_FLOAT_BITS;
+            }
 
-        // Make lexicographically ordered as a two's-complement integer.
-        if (xInt < 0) {
-            xInt = SGN_MASK_FLOAT - xInt;
-        }
-        if (yInt < 0) {
-            yInt = SGN_MASK_FLOAT - yInt;
-        }
+            if (deltaPlus > maxUlps) {
+                isEqual = false;
+            } else {
+                isEqual = deltaMinus <= (maxUlps - deltaPlus);
+            }
 
-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
+        }
 
         return isEqual && !Float.isNaN(x) && !Float.isNaN(y);
+
     }
 
     /**
@@ -315,12 +339,16 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {
     /**
      * Returns true if both arguments are equal or within the range of allowed
      * error (inclusive).
+     * <p>
      * Two float numbers are considered equal if there are {@code (maxUlps - 1)}
-     * (or fewer) floating point numbers between them, i.e. two adjacent floating
-     * point numbers are considered equal.
+     * (or fewer) floating point numbers between them, i.e. two adjacent
+     * floating point numbers are considered equal.
+     * </p>
+     * <p>
      * Adapted from <a
-     * href="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">
+     * href="http://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/">
      * Bruce Dawson</a>
+     * </p>
      *
      * @param x first value
      * @param y second value
@@ -329,21 +357,37 @@ public static boolean equalsIncludingNaN(double x, double y, double eps) {
      * @return {@code true} if there are fewer than {@code maxUlps} floating
      * point values between {@code x} and {@code y}.
      */
-    public static boolean equals(double x, double y, int maxUlps) {
-        long xInt = Double.doubleToLongBits(x);
-        long yInt = Double.doubleToLongBits(y);
+    public static boolean equals(final double x, final double y, final int maxUlps) {
+
+        final long xInt = Double.doubleToRawLongBits(x);
+        final long yInt = Double.doubleToRawLongBits(y);
+
+        final boolean isEqual;
+        if (((xInt ^ yInt) & SGN_MASK) == 0l) {
+            // number have same sign, there is no risk of overflow
+            isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
+        } else {
+            // number have opposite signs, take care of overflow
+            final long deltaPlus;
+            final long deltaMinus;
+            if (xInt < yInt) {
+                deltaPlus  = yInt - POSITIVE_ZERO_DOUBLE_BITS;
+                deltaMinus = xInt - NEGATIVE_ZERO_DOUBLE_BITS;
+            } else {
+                deltaPlus  = xInt - POSITIVE_ZERO_DOUBLE_BITS;
+                deltaMinus = yInt - NEGATIVE_ZERO_DOUBLE_BITS;
+            }
 
-        // Make lexicographically ordered as a two's-complement integer.
-        if (xInt < 0) {
-            xInt = SGN_MASK - xInt;
-        }
-        if (yInt < 0) {
-            yInt = SGN_MASK - yInt;
-        }
+            if (deltaPlus > maxUlps) {
+                isEqual = false;
+            } else {
+                isEqual = deltaMinus <= (maxUlps - deltaPlus);
+            }
 
-        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;
+        }
 
         return isEqual && !Double.isNaN(x) && !Double.isNaN(y);
+
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/math3/util/PrecisionTest.java b/src/test/java/org/apache/commons/math3/util/PrecisionTest.java
index 6b102eb5ef..dd3d31f77a 100644
--- a/src/test/java/org/apache/commons/math3/util/PrecisionTest.java
+++ b/src/test/java/org/apache/commons/math3/util/PrecisionTest.java
@@ -540,4 +540,13 @@ public void testMath843() {
         // b) 1 + "the number after EPSILON" is not equal to 1.
         Assert.assertFalse(1 + afterEpsilon == 1);
     }
+
+    @Test
+    public void testMath1127() {
+        Assert.assertFalse(Precision.equals(2.0, -2.0, 1));
+        Assert.assertTrue(Precision.equals(0.0, -0.0, 0));
+        Assert.assertFalse(Precision.equals(2.0f, -2.0f, 1));
+        Assert.assertTrue(Precision.equals(0.0f, -0.0f, 0));
+    }
+
 }
