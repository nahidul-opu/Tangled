From 48426e0049b01d86b2af3b0cd4c7452a98bbcaaf Mon Sep 17 00:00:00 2001
From: Chas Honton <chas@apache.org>
Date: Sat, 18 Jul 2015 04:56:40 +0000
Subject: [PATCH] BCEL-187 Verification error when an invoke references a
 method defined in superclass

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/bcel/trunk@1691680 13f79535-47bb-0310-9956-ffa450edef68
---
 pom.xml                                       |   4 +-
 src/changes/changes.xml                       |   3 +
 .../bcel/verifier/statics/Pass3aVerifier.java | 105 ++++++++++--------
 .../verifier/AbstractVerifierTestCase.java    |   4 +-
 .../bcel/verifier/VerifierInvokeTestCase.java |  41 +++++++
 .../tests/TestLegalInvokeInterface01.java     |  12 ++
 .../tests/TestLegalInvokeSpecial01.java       |   9 ++
 .../tests/TestLegalInvokeSpecial02.java       |  11 ++
 .../tests/TestLegalInvokeStatic01.java        |   9 ++
 .../tests/TestLegalInvokeVirtual01.java       |   9 ++
 .../tests/TestLegalInvokeVirtual02.java       |  11 ++
 11 files changed, 170 insertions(+), 48 deletions(-)
 create mode 100644 src/test/java/org/apache/bcel/verifier/VerifierInvokeTestCase.java
 create mode 100755 src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeInterface01.java
 create mode 100755 src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeSpecial01.java
 create mode 100755 src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeSpecial02.java
 create mode 100755 src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeStatic01.java
 create mode 100755 src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeVirtual01.java
 create mode 100755 src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeVirtual02.java

diff --git a/pom.xml b/pom.xml
index b4ca4e24bd..ea292e5658 100644
--- a/pom.xml
+++ b/pom.xml
@@ -41,8 +41,8 @@
   <properties>
     <project.build.sourceEncoding>ISO-8859-1</project.build.sourceEncoding>
     <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
-    <maven.compiler.source>1.7</maven.compiler.source>
-    <maven.compiler.target>1.7</maven.compiler.target>
+    <maven.compiler.source>1.5</maven.compiler.source>
+    <maven.compiler.target>1.5</maven.compiler.target>
     <commons.componentid>bcel</commons.componentid>
     <commons.release.version>6.0</commons.release.version>
     <commons.release.desc>(Java 5.0+)</commons.release.desc>
diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index ac5df1d68b..df3e9534a1 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -63,6 +63,9 @@ The <action> type attribute can be add,update,fix,remove.
 
   <body>
     <release version="6.0" date="TBA" description="Major release with Java 7 and 8 support">
+      <action issue="BCEL-187" type="fix" due-to="Jérôme Leroux">
+        Verification error when an invoke references a method defined in superclass
+      </action>
       <action issue="BCEL-218" type="fix" due-to="chas">
         Remove ObjectType cache.
       </action>
diff --git a/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java b/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
index bdef8de329..4d13b0a30b 100644
--- a/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
+++ b/src/main/java/org/apache/bcel/verifier/statics/Pass3aVerifier.java
@@ -1079,18 +1079,9 @@ public void visitINVOKEINTERFACE(INVOKEINTERFACE o){
             // too. So are the allowed method names.
             String classname = o.getClassName(cpg);
             JavaClass jc = Repository.lookupClass(classname);
-            Method[] ms = jc.getMethods();
-            Method m = null;
-            for (Method element : ms) {
-                if ( (element.getName().equals(o.getMethodName(cpg))) &&
-                     (Type.getReturnType(element.getSignature()).equals(o.getReturnType(cpg))) &&
-                     (objarrayequals(Type.getArgumentTypes(element.getSignature()), o.getArgumentTypes(cpg))) ){
-                    m = element;
-                    break;
-                }
-            }
+            Method m = getMethodRecursive(jc, o);
             if (m == null){
-                constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' with expected signature '"+o.getSignature(cpg)+"' not found in class '"+jc.getClassName()+"'. The native verifier does allow the method to be declared in some superinterface, which the Java Virtual Machine Specification, Second Edition does not.");
+                constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' with expected signature '"+o.getSignature(cpg)+"' not found in class '"+jc.getClassName()+"'.");
             }
             if (jc.isClass()){
                 constraintViolated(o, "Referenced class '"+jc.getClassName()+"' is a class, but not an interface as expected.");
@@ -1101,6 +1092,59 @@ public void visitINVOKEINTERFACE(INVOKEINTERFACE o){
             }
         }
 
+        /**
+         * Looks for the method referenced by the given invoke instruction in the given class or its super classes and super interfaces.
+         * @param jc the class that defines the referenced method
+         * @param invoke the instruction that references the method
+         * @return the referenced method or null if not found.
+         */
+        private Method getMethodRecursive(JavaClass jc, InvokeInstruction invoke) throws ClassNotFoundException{
+            Method m;
+            //look in the given class
+            m = getMethod(jc, invoke);
+            if(m != null){
+                //method found in given class
+                return m;
+            }
+            //method not found, look in super classes
+            for(JavaClass superclass : jc.getSuperClasses()){
+                m = getMethod(superclass, invoke);
+                if(m != null){
+                    //method found in super class
+                    return m;
+                }
+            }
+            //method not found, look in super interfaces
+            for(JavaClass superclass : jc.getInterfaces()){
+                m = getMethod(superclass, invoke);
+                if(m != null){
+                    //method found in super interface
+                    return m;
+                }
+            }
+            //method not found in the hierarchy
+            return null;
+        }
+        /**
+         * Looks for the method referenced by the given invoke instruction in the given class.
+         * @param jc the class that defines the referenced method
+         * @param invoke the instruction that references the method
+         * @return the referenced method or null if not found.
+         */
+        private Method getMethod(JavaClass jc, InvokeInstruction invoke){
+            Method[] ms = jc.getMethods();
+            Method m = null;
+            for (Method element : ms) {
+                if ( (element.getName().equals(invoke.getMethodName(cpg))) &&
+                     (Type.getReturnType(element.getSignature()).equals(invoke.getReturnType(cpg))) &&
+                     (objarrayequals(Type.getArgumentTypes(element.getSignature()), invoke.getArgumentTypes(cpg))) ){
+                    return element;
+                }
+            }
+            
+            return null;
+        }
+
         /** Checks if the constraints of operands of the said instruction(s) are satisfied. */
         @Override
         public void visitINVOKESPECIAL(INVOKESPECIAL o){
@@ -1111,18 +1155,9 @@ public void visitINVOKESPECIAL(INVOKESPECIAL o){
             // too. So are the allowed method names.
             String classname = o.getClassName(cpg);
             JavaClass jc = Repository.lookupClass(classname);
-            Method[] ms = jc.getMethods();
-            Method m = null;
-            for (Method element : ms) {
-                if ( (element.getName().equals(o.getMethodName(cpg))) &&
-                     (Type.getReturnType(element.getSignature()).equals(o.getReturnType(cpg))) &&
-                     (objarrayequals(Type.getArgumentTypes(element.getSignature()), o.getArgumentTypes(cpg))) ){
-                    m = element;
-                    break;
-                }
-            }
+            Method m = getMethodRecursive(jc, o);
             if (m == null){
-                constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' with expected signature '"+o.getSignature(cpg)+"' not found in class '"+jc.getClassName()+"'. The native verifier does allow the method to be declared in some superclass or implemented interface, which the Java Virtual Machine Specification, Second Edition does not.");
+                constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' with expected signature '"+o.getSignature(cpg)+"' not found in class '"+jc.getClassName()+"'.");
             }
 
             JavaClass current = Repository.lookupClass(myOwner.getClassName());
@@ -1177,18 +1212,9 @@ public void visitINVOKESTATIC(INVOKESTATIC o){
             // too. So are the allowed method names.
             String classname = o.getClassName(cpg);
             JavaClass jc = Repository.lookupClass(classname);
-            Method[] ms = jc.getMethods();
-            Method m = null;
-            for (Method element : ms) {
-                if ( (element.getName().equals(o.getMethodName(cpg))) &&
-                     (Type.getReturnType(element.getSignature()).equals(o.getReturnType(cpg))) &&
-                     (objarrayequals(Type.getArgumentTypes(element.getSignature()), o.getArgumentTypes(cpg))) ){
-                    m = element;
-                    break;
-                }
-            }
+            Method m = getMethodRecursive(jc, o);
             if (m == null){
-                constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' with expected signature '"+o.getSignature(cpg) +"' not found in class '"+jc.getClassName()+"'. The native verifier possibly allows the method to be declared in some superclass or implemented interface, which the Java Virtual Machine Specification, Second Edition does not.");
+                constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' with expected signature '"+o.getSignature(cpg) +"' not found in class '"+jc.getClassName()+"'.");
             } else if (! (m.isStatic())){ // implies it's not abstract, verified in pass 2.
                 constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' has ACC_STATIC unset.");
             }
@@ -1210,18 +1236,9 @@ public void visitINVOKEVIRTUAL(INVOKEVIRTUAL o){
             // too. So are the allowed method names.
             String classname = o.getClassName(cpg);
             JavaClass jc = Repository.lookupClass(classname);
-            Method[] ms = jc.getMethods();
-            Method m = null;
-            for (Method element : ms) {
-                if ( (element.getName().equals(o.getMethodName(cpg))) &&
-                     (Type.getReturnType(element.getSignature()).equals(o.getReturnType(cpg))) &&
-                     (objarrayequals(Type.getArgumentTypes(element.getSignature()), o.getArgumentTypes(cpg))) ){
-                    m = element;
-                    break;
-                }
-            }
+            Method m = getMethodRecursive(jc, o);
             if (m == null){
-                constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' with expected signature '"+o.getSignature(cpg)+"' not found in class '"+jc.getClassName()+"'. The native verifier does allow the method to be declared in some superclass or implemented interface, which the Java Virtual Machine Specification, Second Edition does not.");
+                constraintViolated(o, "Referenced method '"+o.getMethodName(cpg)+"' with expected signature '"+o.getSignature(cpg)+"' not found in class '"+jc.getClassName()+"'.");
             }
             if (! (jc.isClass())){
                 constraintViolated(o, "Referenced class '"+jc.getClassName()+"' is an interface, but not a class as expected.");
diff --git a/src/test/java/org/apache/bcel/verifier/AbstractVerifierTestCase.java b/src/test/java/org/apache/bcel/verifier/AbstractVerifierTestCase.java
index 9eab88d9d7..da5257bf13 100644
--- a/src/test/java/org/apache/bcel/verifier/AbstractVerifierTestCase.java
+++ b/src/test/java/org/apache/bcel/verifier/AbstractVerifierTestCase.java
@@ -18,11 +18,11 @@
 
 package org.apache.bcel.verifier;
 
-import junit.framework.TestCase;
-
 import org.apache.bcel.Repository;
 import org.apache.bcel.classfile.JavaClass;
 
+import junit.framework.TestCase;
+
 public abstract class AbstractVerifierTestCase extends TestCase {
 
     public static final String TEST_PACKAGE = "org.apache.bcel.verifier.tests.";
diff --git a/src/test/java/org/apache/bcel/verifier/VerifierInvokeTestCase.java b/src/test/java/org/apache/bcel/verifier/VerifierInvokeTestCase.java
new file mode 100644
index 0000000000..c93a0d4711
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/VerifierInvokeTestCase.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * 
+ */
+
+package org.apache.bcel.verifier;
+
+
+public class VerifierInvokeTestCase extends AbstractVerifierTestCase {
+
+    public void testLegalInvokeVirtual() {
+        assertVerifyOK("TestLegalInvokeVirtual01", "Verification of invokevirtual on method defined in superclass must pass.");
+        assertVerifyOK("TestLegalInvokeVirtual02", "Verification of invokevirtual on method defined in superinterface must pass.");
+    }
+    
+    public void testLegalInvokeStatic() {
+        assertVerifyOK("TestLegalInvokeStatic01", "Verification of invokestatic on method defined in superclass must pass.");
+    }
+    
+    public void testLegalInvokeInterface() {
+        assertVerifyOK("TestLegalInvokeInterface01", "Verification of invokeinterface on method defined in superinterface must pass.");
+    }
+    
+    public void testLegalInvokeSpecial() {
+        assertVerifyOK("TestLegalInvokeSpecial01", "Verification of invokespecial on method defined in superclass must pass.");
+        assertVerifyOK("TestLegalInvokeSpecial02", "Verification of invokespecial on method defined in superclass must pass.");
+    }
+}
diff --git a/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeInterface01.java b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeInterface01.java
new file mode 100755
index 0000000000..72ca5606d0
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeInterface01.java
@@ -0,0 +1,12 @@
+package org.apache.bcel.verifier.tests;
+
+public class TestLegalInvokeInterface01{
+
+    public static void test1(Interface01 t){
+        t.run();
+    }
+}
+
+interface Interface01 extends Runnable {
+    
+}
\ No newline at end of file
diff --git a/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeSpecial01.java b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeSpecial01.java
new file mode 100755
index 0000000000..25f2d9557f
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeSpecial01.java
@@ -0,0 +1,9 @@
+package org.apache.bcel.verifier.tests;
+
+public class TestLegalInvokeSpecial01{
+
+    public static void test1(){
+       new TestLegalInvokeSpecial01().getClass();
+    }
+    
+}
diff --git a/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeSpecial02.java b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeSpecial02.java
new file mode 100755
index 0000000000..e5f7372288
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeSpecial02.java
@@ -0,0 +1,11 @@
+package org.apache.bcel.verifier.tests;
+
+abstract public class TestLegalInvokeSpecial02 implements Runnable{
+
+    public static void test1(TestLegalInvokeSpecial02 t, int i){
+        if(i > 0){
+            t.run();
+        }
+    }
+    
+}
diff --git a/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeStatic01.java b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeStatic01.java
new file mode 100755
index 0000000000..592f769279
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeStatic01.java
@@ -0,0 +1,9 @@
+package org.apache.bcel.verifier.tests;
+
+public class TestLegalInvokeStatic01 extends Thread{
+
+    public static void test1() throws InterruptedException{
+       Thread.sleep(0);
+    }
+    
+}
diff --git a/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeVirtual01.java b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeVirtual01.java
new file mode 100755
index 0000000000..81e23cef0f
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeVirtual01.java
@@ -0,0 +1,9 @@
+package org.apache.bcel.verifier.tests;
+
+public class TestLegalInvokeVirtual01 {
+
+    public static void test1(){
+        new TestLegalInvokeVirtual01().toString();
+    }
+    
+}
diff --git a/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeVirtual02.java b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeVirtual02.java
new file mode 100755
index 0000000000..a45cba17a9
--- /dev/null
+++ b/src/test/java/org/apache/bcel/verifier/tests/TestLegalInvokeVirtual02.java
@@ -0,0 +1,11 @@
+package org.apache.bcel.verifier.tests;
+
+abstract public class TestLegalInvokeVirtual02 implements Runnable{
+
+    public static void test1(TestLegalInvokeVirtual02 t, int i){
+        if(i > 0){
+            t.run();
+        }
+    }
+    
+}
