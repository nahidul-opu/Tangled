From faf997271b36b80d9a342bb1a5a666e8a7a1fb56 Mon Sep 17 00:00:00 2001
From: Luc Maisonobe <luc@apache.org>
Date: Thu, 30 Jan 2014 16:31:08 +0000
Subject: [PATCH] Partly fixed MATH-1096.

The 2D cases seem to work now, but there are still problems with the 3D
cases.

git-svn-id: https://svn.apache.org/repos/asf/commons/proper/math/trunk@1562882 13f79535-47bb-0310-9956-ffa450edef68
---
 .../math3/geometry/enclosing/Encloser.java    |  4 +--
 .../geometry/enclosing/WelzlEncloser.java     | 25 +++++++++++--------
 .../enclosing/WelzlEncloser2DTest.java        | 14 ++++++++---
 3 files changed, 25 insertions(+), 18 deletions(-)

diff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java
index 4e92704303..a2e168455f 100644
--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java
+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/Encloser.java
@@ -16,8 +16,6 @@
  */
 package org.apache.commons.math3.geometry.enclosing;
 
-import java.util.List;
-
 import org.apache.commons.math3.geometry.Point;
 import org.apache.commons.math3.geometry.Space;
 
@@ -34,6 +32,6 @@ public interface Encloser<S extends Space, P extends Point<S>> {
      * @param points points to enclose
      * @return enclosing ball
      */
-    EnclosingBall<S, P> enclose(List<P> points);
+    EnclosingBall<S, P> enclose(Iterable<P> points);
 
 }
diff --git a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java
index ce5c58cb55..b8ea5d6bb1 100644
--- a/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java
+++ b/src/main/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser.java
@@ -65,9 +65,9 @@ protected WelzlEncloser(final double tolerance, final int dimension,
     }
 
     /** {@inheritDoc} */
-    public EnclosingBall<S, P> enclose(final List<P> points) {
+    public EnclosingBall<S, P> enclose(final Iterable<P> points) {
 
-        if (points == null || points.isEmpty()) {
+        if (points == null || !points.iterator().hasNext()) {
             // return an empty ball
             return generator.ballOnSupport(new ArrayList<P>());
         }
@@ -81,14 +81,14 @@ public EnclosingBall<S, P> enclose(final List<P> points) {
      * @param points points to be enclosed
      * @return enclosing ball
      */
-    private EnclosingBall<S, P> pivotingBall(final List<P> points) {
+    private EnclosingBall<S, P> pivotingBall(final Iterable<P> points) {
 
         List<P> extreme = new ArrayList<P>(max);
         List<P> support = new ArrayList<P>(max);
 
         // start with only first point selected as a candidate support
-        extreme.add(points.get(0));
-        EnclosingBall<S, P> ball = moveToFrontBall(extreme, support);
+        extreme.add(points.iterator().next());
+        EnclosingBall<S, P> ball = moveToFrontBall(extreme, extreme.size(), support);
 
         while (true) {
 
@@ -103,7 +103,7 @@ private EnclosingBall<S, P> pivotingBall(final List<P> points) {
             support.clear();
             support.add(farthest);
             EnclosingBall<S, P> savedBall = ball;
-            ball = moveToFrontBall(extreme, support);
+            ball = moveToFrontBall(extreme, extreme.size(), support);
             if (ball.getRadius() < savedBall.getRadius()) {
                 // TODO: fix this, it should never happen but it does!
                 throw new MathInternalError();
@@ -122,28 +122,31 @@ private EnclosingBall<S, P> pivotingBall(final List<P> points) {
 
     /** Compute enclosing ball using Welzl's move to front heuristic.
      * @param extreme subset of extreme points
+     * @param nbExtreme number of extreme points to consider
      * @param support points that must belong to the ball support
      * @return enclosing ball, for the extreme subset only
      */
-    private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P> support) {
+    private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final int nbExtreme,
+                                                final List<P> support) {
 
         // create a new ball on the prescribed support
         EnclosingBall<S, P> ball = generator.ballOnSupport(support);
 
         if (ball.getSupportSize() < max) {
 
-            for (int i = 0; i < extreme.size(); ++i) {
+            for (int i = 0; i < nbExtreme; ++i) {
                 final P pi = extreme.get(i);
                 if (!ball.contains(pi, tolerance)) {
 
                     // we have found an outside point,
                     // enlarge the ball by adding it to the support
                     support.add(pi);
-                    ball = moveToFrontBall(extreme.subList(i + 1, extreme.size()), support);
+                    ball = moveToFrontBall(extreme, i, support);
+                    support.remove(support.size() - 1);
 
                     // it was an interesting point, move it to the front
                     // according to Welzl's heuristic
-                    for (int j = i; j > 1; --j) {
+                    for (int j = i; j > 0; --j) {
                         extreme.set(j, extreme.get(j - 1));
                     }
                     extreme.set(0, pi);
@@ -162,7 +165,7 @@ private EnclosingBall<S, P> moveToFrontBall(final List<P> extreme, final List<P>
      * @param ball current ball
      * @return farthest point
      */
-    public P selectFarthest(final List<P> points, final EnclosingBall<S, P> ball) {
+    public P selectFarthest(final Iterable<P> points, final EnclosingBall<S, P> ball) {
 
         final P center = ball.getCenter();
         P farthest   = null;
diff --git a/src/test/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser2DTest.java b/src/test/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser2DTest.java
index d35854f870..40c8d9c17e 100644
--- a/src/test/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser2DTest.java
+++ b/src/test/java/org/apache/commons/math3/geometry/enclosing/WelzlEncloser2DTest.java
@@ -26,7 +26,6 @@
 import org.apache.commons.math3.random.RandomGenerator;
 import org.apache.commons.math3.random.Well1024a;
 import org.junit.Assert;
-import org.junit.Ignore;
 import org.junit.Test;
 
 
@@ -63,8 +62,7 @@ public void testSolutionOnDiameter() {
     }
 
     @Test
-    @Ignore // this test currently fails, it generate a ball that reduces at one iteration
-    public void testReducingBall() {
+    public void testReducingBall1() {
         List<Vector2D> list = buildList(0.05380958511396061, 0.57332359658700000,
                                         0.99348810731127870, 0.02056421361521466,
                                         0.01203950647796437, 0.99779675042261860,
@@ -74,7 +72,15 @@ public void testReducingBall() {
     }
 
     @Test
-    @Ignore // this test currently fails, it generate balls that reduce at some iterations
+    public void testReducingBall2() {
+        List<Vector2D> list = buildList(0.016930586154703, 0.333955448537779,
+                                        0.987189104892331, 0.969778855274507,
+                                        0.983696889599935, 0.012904580013266,
+                                        0.013114499572905, 0.034740156356895);
+        checkDisk(list, Arrays.asList(list.get(1), list.get(2), list.get(3)));
+    }
+
+    @Test
     public void testLargeSamples() {
         RandomGenerator random = new Well1024a(0xa2a63cad12c01fb2l);
         for (int k = 0; k < 100; ++k) {
