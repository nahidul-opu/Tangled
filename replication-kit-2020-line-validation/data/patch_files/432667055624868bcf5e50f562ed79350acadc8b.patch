From 432667055624868bcf5e50f562ed79350acadc8b Mon Sep 17 00:00:00 2001
From: Maarten Coene <maartenc@apache.org>
Date: Thu, 27 Sep 2007 22:00:10 +0000
Subject: [PATCH] FIX: EmptyStackException when upgrading from 1.4 to 2.0
 (IVY-610)

git-svn-id: https://svn.apache.org/repos/asf/incubator/ivy/core/trunk@580172 13f79535-47bb-0310-9956-ffa450edef68
---
 CHANGES.txt                                   |   1 +
 src/java/org/apache/ivy/core/IvyContext.java  |  16 -
 .../resolver/AbstractResourceResolver.java    |   2 +-
 .../ivy/plugins/resolver/BasicResolver.java   | 612 +++++++++---------
 .../plugins/resolver/RepositoryResolver.java  |   4 +-
 5 files changed, 303 insertions(+), 332 deletions(-)

diff --git a/CHANGES.txt b/CHANGES.txt
index 99c7c97d2..e7d3ddbba 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -51,6 +51,7 @@ for detailed view of each issue, please consult http://issues.apache.org/jira/br
 
    version in SVN
 =====================================
+- FIX: EmptyStackException when upgrading from 1.4 to 2.0 (IVY-610)
 - FIX: Ivy:retrieve fails through proxy server (IVY-529)
 - FIX: java.lang.IllegalArgumentException: Invalid uri when working with version ranges (IVY-390)
 - FIX: Ivy settings include -tag url attribute does not work correctly (IVY-601)
diff --git a/src/java/org/apache/ivy/core/IvyContext.java b/src/java/org/apache/ivy/core/IvyContext.java
index 3f4ccd3ff..f99bbf713 100644
--- a/src/java/org/apache/ivy/core/IvyContext.java
+++ b/src/java/org/apache/ivy/core/IvyContext.java
@@ -23,14 +23,12 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.Stack;
 
 import org.apache.ivy.Ivy;
 import org.apache.ivy.core.cache.CacheManager;
 import org.apache.ivy.core.event.EventManager;
 import org.apache.ivy.core.settings.IvySettings;
 import org.apache.ivy.plugins.circular.CircularDependencyStrategy;
-import org.apache.ivy.plugins.resolver.DependencyResolver;
 import org.apache.ivy.util.MessageImpl;
 
 /**
@@ -51,8 +49,6 @@ public class IvyContext {
 
     private MessageImpl messageImpl;
 
-    private Stack resolver = new Stack(); // Stack(DependencyResolver)
-
     private Map contextMap = new HashMap();
 
     private Thread operatingThread;
@@ -270,18 +266,6 @@ public void checkInterrupted() {
         getIvy().checkInterrupted();
     }
 
-    public DependencyResolver getResolver() {
-        return (DependencyResolver) resolver.peek();
-    }
-
-    public void pushResolver(DependencyResolver resolver) {
-        this.resolver.push(resolver);
-    }
-
-    public void popResolver() {
-        resolver.pop();
-    }
-
     // should be better to use context to store this kind of information, but not yet ready to do
     // so...
     // private WeakReference _root = new WeakReference(null);
diff --git a/src/java/org/apache/ivy/plugins/resolver/AbstractResourceResolver.java b/src/java/org/apache/ivy/plugins/resolver/AbstractResourceResolver.java
index 53fd26dfd..b38884d4d 100644
--- a/src/java/org/apache/ivy/plugins/resolver/AbstractResourceResolver.java
+++ b/src/java/org/apache/ivy/plugins/resolver/AbstractResourceResolver.java
@@ -112,7 +112,7 @@ protected ResolvedResource findResourceUsingPatterns(ModuleRevisionId moduleRevi
     protected abstract ResolvedResource findResourceUsingPattern(ModuleRevisionId mrid,
             String pattern, Artifact artifact, ResourceMDParser rmdparser, Date date);
 
-    public static ResolvedResource findResource(ResolvedResource[] rress, String name,
+    public ResolvedResource findResource(ResolvedResource[] rress, String name,
             LatestStrategy strategy, VersionMatcher versionMatcher, ResourceMDParser rmdparser,
             ModuleRevisionId mrid, Date date) {
         ResolvedResource found = null;
diff --git a/src/java/org/apache/ivy/plugins/resolver/BasicResolver.java b/src/java/org/apache/ivy/plugins/resolver/BasicResolver.java
index 3a54b8985..c6ec02beb 100644
--- a/src/java/org/apache/ivy/plugins/resolver/BasicResolver.java
+++ b/src/java/org/apache/ivy/plugins/resolver/BasicResolver.java
@@ -149,231 +149,226 @@ public void setCheckmodified(boolean check) {
 
     public ResolvedModuleRevision getDependency(DependencyDescriptor dd, ResolveData data)
             throws ParseException {
-        IvyContext.getContext().pushResolver(this);
-        try {
-            DependencyDescriptor systemDd = dd;
-            dd = fromSystem(dd);
-
-            clearIvyAttempts();
-            clearArtifactAttempts();
-            boolean downloaded = false;
-            boolean searched = false;
-            ModuleRevisionId mrid = dd.getDependencyRevisionId();
-            // check revision
-            int index = mrid.getRevision().indexOf("@");
-            if (index != -1 && !mrid.getRevision().substring(index + 1).equals(workspaceName)) {
-                Message.verbose("\t" + getName() + ": unhandled revision => " + mrid.getRevision());
-                return null;
-            }
+        DependencyDescriptor systemDd = dd;
+        dd = fromSystem(dd);
 
-            boolean isDynamic = getSettings().getVersionMatcher().isDynamic(mrid);
-            if (isDynamic && !acceptLatest()) {
-                Message.error("dynamic revisions not handled by " + getClass().getName()
-                        + ". impossible to resolve " + mrid);
-                return null;
-            }
+        clearIvyAttempts();
+        clearArtifactAttempts();
+        boolean downloaded = false;
+        boolean searched = false;
+        ModuleRevisionId mrid = dd.getDependencyRevisionId();
+        // check revision
+        int index = mrid.getRevision().indexOf("@");
+        if (index != -1 && !mrid.getRevision().substring(index + 1).equals(workspaceName)) {
+            Message.verbose("\t" + getName() + ": unhandled revision => " + mrid.getRevision());
+            return null;
+        }
 
-            boolean isChangingRevision = getChangingMatcher().matches(mrid.getRevision());
-            boolean isChangingDependency = isChangingRevision || dd.isChanging();
+        boolean isDynamic = getSettings().getVersionMatcher().isDynamic(mrid);
+        if (isDynamic && !acceptLatest()) {
+            Message.error("dynamic revisions not handled by " + getClass().getName()
+                    + ". impossible to resolve " + mrid);
+            return null;
+        }
 
-            // if we do not have to check modified and if the revision is exact and not changing,
-            // we first search for it in cache
-            ResolvedModuleRevision cachedRmr = null;
-            boolean checkedCache = false;
-            if (!isDynamic && !isCheckmodified() && !isChangingDependency) {
-                cachedRmr = findModuleInCache(data, mrid);
-                checkedCache = true;
-                if (cachedRmr != null) {
-                    if (cachedRmr.getDescriptor().isDefault() && cachedRmr.getResolver() != this) {
-                        Message.verbose("\t" + getName() + ": found revision in cache: " + mrid
-                                + " (resolved by " + cachedRmr.getResolver().getName()
-                                + "): but it's a default one, maybe we can find a better one");
-                    } else {
-                        Message.verbose("\t" + getName() + ": revision in cache: " + mrid);
-                        return toSystem(cachedRmr);
-                    }
+        boolean isChangingRevision = getChangingMatcher().matches(mrid.getRevision());
+        boolean isChangingDependency = isChangingRevision || dd.isChanging();
+        
+        // if we do not have to check modified and if the revision is exact and not changing,
+        // we first search for it in cache
+        ResolvedModuleRevision cachedRmr = null;
+        boolean checkedCache = false;
+        if (!isDynamic && !isCheckmodified() && !isChangingDependency) {
+            cachedRmr = findModuleInCache(data, mrid);
+            checkedCache = true;
+            if (cachedRmr != null) {
+                if (cachedRmr.getDescriptor().isDefault() && cachedRmr.getResolver() != this) {
+                    Message.verbose("\t" + getName() + ": found revision in cache: " + mrid
+                            + " (resolved by " + cachedRmr.getResolver().getName()
+                            + "): but it's a default one, maybe we can find a better one");
+                } else {
+                    Message.verbose("\t" + getName() + ": revision in cache: " + mrid);
+                    return toSystem(cachedRmr);
                 }
             }
+        }
+        checkInterrupted();
+        URL cachedIvyURL = null;
+        ResolvedResource ivyRef = findIvyFileRef(dd, data);
+        checkInterrupted();
+        searched = true;
+
+        // get module descriptor
+        ModuleDescriptorParser parser;
+        ModuleDescriptor md;
+        ModuleDescriptor systemMd = null;
+        if (ivyRef == null) {
+            if (!isAllownomd()) {
+                Message.verbose("\t" + getName() + ": no ivy file found for " + mrid);
+                return null;
+            }
+            parser = XmlModuleDescriptorParser.getInstance();
+            md = DefaultModuleDescriptor.newDefaultInstance(mrid, dd
+                    .getAllDependencyArtifacts());
+            ResolvedResource artifactRef = findFirstArtifactRef(md, dd, data);
             checkInterrupted();
-            URL cachedIvyURL = null;
-            ResolvedResource ivyRef = findIvyFileRef(dd, data);
-            checkInterrupted();
-            searched = true;
-
-            // get module descriptor
-            ModuleDescriptorParser parser;
-            ModuleDescriptor md;
-            ModuleDescriptor systemMd = null;
-            if (ivyRef == null) {
-                if (!isAllownomd()) {
-                    Message.verbose("\t" + getName() + ": no ivy file found for " + mrid);
-                    return null;
+            if (artifactRef == null) {
+                Message.verbose("\t" + getName() + ": no ivy file nor artifact found for "
+                        + mrid);
+                if (!checkedCache) {
+                    cachedRmr = findModuleInCache(data, mrid);
                 }
-                parser = XmlModuleDescriptorParser.getInstance();
-                md = DefaultModuleDescriptor.newDefaultInstance(mrid, dd
-                        .getAllDependencyArtifacts());
-                ResolvedResource artifactRef = findFirstArtifactRef(md, dd, data);
-                checkInterrupted();
-                if (artifactRef == null) {
-                    Message.verbose("\t" + getName() + ": no ivy file nor artifact found for "
-                            + mrid);
-                    if (!checkedCache) {
-                        cachedRmr = findModuleInCache(data, mrid);
-                    }
-                    if (cachedRmr != null) {
-                        Message.verbose("\t" + getName() + ": revision in cache: " + mrid);
-                        return toSystem(cachedRmr);
-                    }
-                    return null;
-                } else {
-                    long lastModified = artifactRef.getLastModified();
-                    if (lastModified != 0 && md instanceof DefaultModuleDescriptor) {
-                        ((DefaultModuleDescriptor) md).setLastModified(lastModified);
-                    }
-                    Message.verbose("\t" + getName() + ": no ivy file found for " + mrid
-                            + ": using default data");
-                    if (isDynamic) {
-                        md.setResolvedModuleRevisionId(ModuleRevisionId.newInstance(mrid,
-                            artifactRef.getRevision()));
-                    }
+                if (cachedRmr != null) {
+                    Message.verbose("\t" + getName() + ": revision in cache: " + mrid);
+                    return toSystem(cachedRmr);
                 }
+                return null;
             } else {
-                ResolvedModuleRevision rmr = null;
-                if (ivyRef instanceof MDResolvedResource) {
-                    rmr = ((MDResolvedResource) ivyRef).getResolvedModuleRevision();
+                long lastModified = artifactRef.getLastModified();
+                if (lastModified != 0 && md instanceof DefaultModuleDescriptor) {
+                    ((DefaultModuleDescriptor) md).setLastModified(lastModified);
+                }
+                Message.verbose("\t" + getName() + ": no ivy file found for " + mrid
+                        + ": using default data");
+                if (isDynamic) {
+                    md.setResolvedModuleRevisionId(ModuleRevisionId.newInstance(mrid,
+                        artifactRef.getRevision()));
                 }
+            }
+        } else {
+            ResolvedModuleRevision rmr = null;
+            if (ivyRef instanceof MDResolvedResource) {
+                rmr = ((MDResolvedResource) ivyRef).getResolvedModuleRevision();
+            }
+            if (rmr == null) {
+                rmr = parse(ivyRef, dd, data);
                 if (rmr == null) {
-                    rmr = parse(ivyRef, dd, data);
-                    if (rmr == null) {
-                        return null;
-                    }
+                    return null;
                 }
-                if (!rmr.isDownloaded()) {
-                    return toSystem(rmr);
+            }
+            if (!rmr.isDownloaded()) {
+                return toSystem(rmr);
+            } else {
+                md = rmr.getDescriptor();
+                parser = ModuleDescriptorParserRegistry.getInstance().getParser(
+                    ivyRef.getResource());
+                cachedIvyURL = rmr.getLocalMDUrl();
+
+                // check descriptor data is in sync with resource revision and names
+                systemMd = toSystem(md);
+                if (checkconsistency) {
+                    checkDescriptorConsistency(mrid, md, ivyRef);
+                    checkDescriptorConsistency(systemDd.getDependencyRevisionId(), systemMd,
+                        ivyRef);
                 } else {
-                    md = rmr.getDescriptor();
-                    parser = ModuleDescriptorParserRegistry.getInstance().getParser(
-                        ivyRef.getResource());
-                    cachedIvyURL = rmr.getLocalMDUrl();
-
-                    // check descriptor data is in sync with resource revision and names
-                    systemMd = toSystem(md);
-                    if (checkconsistency) {
-                        checkDescriptorConsistency(mrid, md, ivyRef);
-                        checkDescriptorConsistency(systemDd.getDependencyRevisionId(), systemMd,
-                            ivyRef);
+                    if (md instanceof DefaultModuleDescriptor) {
+                        String revision = getRevision(ivyRef, mrid, md);
+                        ((DefaultModuleDescriptor) md).setModuleRevisionId(ModuleRevisionId
+                                .newInstance(mrid, revision));
                     } else {
-                        if (md instanceof DefaultModuleDescriptor) {
-                            String revision = getRevision(ivyRef, mrid, md);
-                            ((DefaultModuleDescriptor) md).setModuleRevisionId(ModuleRevisionId
-                                    .newInstance(mrid, revision));
-                        } else {
-                            Message.warn(
-                              "consistency disabled with instance of non DefaultModuleDescriptor..."
-                              + " module info can't be updated, so consistency check will be done");
-                            checkDescriptorConsistency(mrid, md, ivyRef);
-                            checkDescriptorConsistency(systemDd.getDependencyRevisionId(),
-                                systemMd, ivyRef);
-                        }
+                        Message.warn(
+                          "consistency disabled with instance of non DefaultModuleDescriptor..."
+                          + " module info can't be updated, so consistency check will be done");
+                        checkDescriptorConsistency(mrid, md, ivyRef);
+                        checkDescriptorConsistency(systemDd.getDependencyRevisionId(),
+                            systemMd, ivyRef);
                     }
                 }
             }
+        }
 
-            if (systemMd == null) {
-                systemMd = toSystem(md);
-            }
+        if (systemMd == null) {
+            systemMd = toSystem(md);
+        }
 
-            // resolve revision
-            ModuleRevisionId resolvedMrid = mrid;
-            if (isDynamic) {
-                resolvedMrid = md.getResolvedModuleRevisionId();
-                if (resolvedMrid.getRevision() == null 
-                        || resolvedMrid.getRevision().length() == 0) {
-                    if (ivyRef.getRevision() == null || ivyRef.getRevision().length() == 0) {
-                        resolvedMrid = ModuleRevisionId.newInstance(resolvedMrid, "working@"
-                                + getName());
-                    } else {
-                        resolvedMrid = ModuleRevisionId.newInstance(resolvedMrid, ivyRef
-                                .getRevision());
-                    }
+        // resolve revision
+        ModuleRevisionId resolvedMrid = mrid;
+        if (isDynamic) {
+            resolvedMrid = md.getResolvedModuleRevisionId();
+            if (resolvedMrid.getRevision() == null 
+                    || resolvedMrid.getRevision().length() == 0) {
+                if (ivyRef.getRevision() == null || ivyRef.getRevision().length() == 0) {
+                    resolvedMrid = ModuleRevisionId.newInstance(resolvedMrid, "working@"
+                            + getName());
+                } else {
+                    resolvedMrid = ModuleRevisionId.newInstance(resolvedMrid, ivyRef
+                            .getRevision());
                 }
-                Message.verbose("\t\t[" + resolvedMrid.getRevision() + "] " + mrid.getModuleId());
-            }
-            md.setResolvedModuleRevisionId(resolvedMrid);
-            systemMd.setResolvedModuleRevisionId(toSystem(resolvedMrid)); // keep system md in
-            // sync with md
-
-            // check module descriptor revision
-            if (!getSettings().getVersionMatcher().accept(mrid, md)) {
-                Message.info("\t" + getName() + ": unacceptable revision => was="
-                        + md.getModuleRevisionId().getRevision() + " required="
-                        + mrid.getRevision());
-                return null;
             }
+            Message.verbose("\t\t[" + resolvedMrid.getRevision() + "] " + mrid.getModuleId());
+        }
+        md.setResolvedModuleRevisionId(resolvedMrid);
+        systemMd.setResolvedModuleRevisionId(toSystem(resolvedMrid)); // keep system md in
+        // sync with md
+
+        // check module descriptor revision
+        if (!getSettings().getVersionMatcher().accept(mrid, md)) {
+            Message.info("\t" + getName() + ": unacceptable revision => was="
+                    + md.getModuleRevisionId().getRevision() + " required="
+                    + mrid.getRevision());
+            return null;
+        }
 
-            // resolve and check publication date
-            if (data.getDate() != null) {
-                long pubDate = getPublicationDate(md, dd, data);
-                if (pubDate > data.getDate().getTime()) {
-                    Message.info("\t" + getName() + ": unacceptable publication date => was="
-                            + new Date(pubDate) + " required=" + data.getDate());
-                    return null;
-                } else if (pubDate == -1) {
-                    Message.info("\t" + getName()
-                            + ": impossible to guess publication date: artifact missing for "
-                            + mrid);
-                    return null;
-                }
-                md.setResolvedPublicationDate(new Date(pubDate));
-                systemMd.setResolvedPublicationDate(new Date(pubDate)); // keep system md in sync
-                // with md
+        // resolve and check publication date
+        if (data.getDate() != null) {
+            long pubDate = getPublicationDate(md, dd, data);
+            if (pubDate > data.getDate().getTime()) {
+                Message.info("\t" + getName() + ": unacceptable publication date => was="
+                        + new Date(pubDate) + " required=" + data.getDate());
+                return null;
+            } else if (pubDate == -1) {
+                Message.info("\t" + getName()
+                        + ": impossible to guess publication date: artifact missing for "
+                        + mrid);
+                return null;
             }
+            md.setResolvedPublicationDate(new Date(pubDate));
+            systemMd.setResolvedPublicationDate(new Date(pubDate)); // keep system md in sync
+            // with md
+        }
 
-            try {
-                File ivyFile = data.getCacheManager().getIvyFileInCache(
-                    systemMd.getResolvedModuleRevisionId());
-                if (ivyRef == null) {
-                    // a basic ivy file is written containing default data
-                    XmlModuleDescriptorWriter.write(systemMd, ivyFile);
-                } else {
-                    if (md instanceof DefaultModuleDescriptor) {
-                        DefaultModuleDescriptor dmd = (DefaultModuleDescriptor) md;
-                        if (data.getSettings().logNotConvertedExclusionRule()
-                                && dmd.isNamespaceUseful()) {
-                            Message.warn(
-                                "the module descriptor "
-                                + ivyRef.getResource()
-                                + " has information which can't be converted into "
-                                + "the system namespace. "
-                                + "It will require the availability of the namespace '"
-                                + getNamespace().getName() + "' to be fully usable.");
-                        }
-                    }
-                    // copy and update ivy file from source to cache
-                    parser.toIvyFile(cachedIvyURL.openStream(), ivyRef.getResource(), ivyFile,
-                        systemMd);
-                    long repLastModified = ivyRef.getLastModified();
-                    if (repLastModified > 0) {
-                        ivyFile.setLastModified(repLastModified);
+        try {
+            File ivyFile = data.getCacheManager().getIvyFileInCache(
+                systemMd.getResolvedModuleRevisionId());
+            if (ivyRef == null) {
+                // a basic ivy file is written containing default data
+                XmlModuleDescriptorWriter.write(systemMd, ivyFile);
+            } else {
+                if (md instanceof DefaultModuleDescriptor) {
+                    DefaultModuleDescriptor dmd = (DefaultModuleDescriptor) md;
+                    if (data.getSettings().logNotConvertedExclusionRule()
+                            && dmd.isNamespaceUseful()) {
+                        Message.warn(
+                            "the module descriptor "
+                            + ivyRef.getResource()
+                            + " has information which can't be converted into "
+                            + "the system namespace. "
+                            + "It will require the availability of the namespace '"
+                            + getNamespace().getName() + "' to be fully usable.");
                     }
                 }
-            } catch (Exception e) {
-                if (ivyRef == null) {
-                    Message.warn("impossible to create ivy file in cache for module : "
-                            + resolvedMrid);
-                } else {
-                    e.printStackTrace();
-                    Message.warn("impossible to copy ivy file to cache : " + ivyRef.getResource());
+                // copy and update ivy file from source to cache
+                parser.toIvyFile(cachedIvyURL.openStream(), ivyRef.getResource(), ivyFile,
+                    systemMd);
+                long repLastModified = ivyRef.getLastModified();
+                if (repLastModified > 0) {
+                    ivyFile.setLastModified(repLastModified);
                 }
             }
-
-            data.getCacheManager().saveResolver(systemMd, getName());
-            data.getCacheManager().saveArtResolver(systemMd, getName());
-            return new DefaultModuleRevision(this, this, systemMd, searched, downloaded,
-                    cachedIvyURL);
-        } finally {
-            IvyContext.getContext().popResolver();
+        } catch (Exception e) {
+            if (ivyRef == null) {
+                Message.warn("impossible to create ivy file in cache for module : "
+                        + resolvedMrid);
+            } else {
+                e.printStackTrace();
+                Message.warn("impossible to copy ivy file to cache : " + ivyRef.getResource());
+            }
         }
+
+        data.getCacheManager().saveResolver(systemMd, getName());
+        data.getCacheManager().saveArtResolver(systemMd, getName());
+        return new DefaultModuleRevision(this, this, systemMd, searched, downloaded,
+                cachedIvyURL);
     }
 
     private String getRevision(ResolvedResource ivyRef, ModuleRevisionId askedMrid,
@@ -674,16 +669,12 @@ protected void logArtifactAttempt(Artifact art, String attempt) {
         Message.verbose("\t\ttried " + attempt);
     }
 
-    protected static void logAttempt(String attempt) {
-        DependencyResolver resolver = IvyContext.getContext().getResolver();
-        if (resolver instanceof BasicResolver) {
-            Artifact currentArtifact = (Artifact) IvyContext.getContext().get(
-                resolver.getName() + ".artifact");
-            if (currentArtifact != null) {
-                ((BasicResolver) resolver).logArtifactAttempt(currentArtifact, attempt);
-            } else {
-                ((BasicResolver) resolver).logIvyAttempt(attempt);
-            }
+    protected void logAttempt(String attempt) {
+        Artifact currentArtifact = (Artifact) IvyContext.getContext().get(getName() + ".artifact");
+        if (currentArtifact != null) {
+            logArtifactAttempt(currentArtifact, attempt);
+        } else {
+            logIvyAttempt(attempt);
         }
     }
 
@@ -722,123 +713,118 @@ protected boolean acceptLatest() {
     }
 
     public DownloadReport download(Artifact[] artifacts, DownloadOptions options) {
-        IvyContext.getContext().pushResolver(this);
-        try {
-            CacheManager cacheManager = options.getCacheManager();
-            EventManager eventManager = options.getEventManager();
-
-            boolean useOrigin = options.isUseOrigin();
-
-            clearArtifactAttempts();
-            DownloadReport dr = new DownloadReport();
-            for (int i = 0; i < artifacts.length; i++) {
-                final ArtifactDownloadReport adr = new ArtifactDownloadReport(artifacts[i]);
-                dr.addArtifactReport(adr);
-                if (eventManager != null) {
-                    eventManager.fireIvyEvent(new NeedArtifactEvent(this, artifacts[i]));
+        CacheManager cacheManager = options.getCacheManager();
+        EventManager eventManager = options.getEventManager();
+
+        boolean useOrigin = options.isUseOrigin();
+
+        clearArtifactAttempts();
+        DownloadReport dr = new DownloadReport();
+        for (int i = 0; i < artifacts.length; i++) {
+            final ArtifactDownloadReport adr = new ArtifactDownloadReport(artifacts[i]);
+            dr.addArtifactReport(adr);
+            if (eventManager != null) {
+                eventManager.fireIvyEvent(new NeedArtifactEvent(this, artifacts[i]));
+            }
+            ArtifactOrigin origin = cacheManager.getSavedArtifactOrigin(artifacts[i]);
+            // if we can use origin file, we just ask ivy for the file in cache, and it will
+            // return
+            // the original one if possible. If we are not in useOrigin mode, we use the
+            // getArchivePath
+            // method which always return a path in the actual cache
+            File archiveFile = cacheManager.getArchiveFileInCache(artifacts[i], origin, options
+                    .isUseOrigin());
+
+            if (archiveFile.exists()) {
+                Message.verbose("\t[NOT REQUIRED] " + artifacts[i]);
+                adr.setDownloadStatus(DownloadStatus.NO);
+                adr.setSize(archiveFile.length());
+                adr.setArtifactOrigin(origin);
+            } else {
+                Artifact artifact = fromSystem(artifacts[i]);
+                if (!artifact.equals(artifacts[i])) {
+                    Message.verbose("\t" + getName() + "looking for artifact " + artifact
+                            + " (is " + artifacts[i] + " in system namespace)");
                 }
-                ArtifactOrigin origin = cacheManager.getSavedArtifactOrigin(artifacts[i]);
-                // if we can use origin file, we just ask ivy for the file in cache, and it will
-                // return
-                // the original one if possible. If we are not in useOrigin mode, we use the
-                // getArchivePath
-                // method which always return a path in the actual cache
-                File archiveFile = cacheManager.getArchiveFileInCache(artifacts[i], origin, options
-                        .isUseOrigin());
-
-                if (archiveFile.exists()) {
-                    Message.verbose("\t[NOT REQUIRED] " + artifacts[i]);
-                    adr.setDownloadStatus(DownloadStatus.NO);
-                    adr.setSize(archiveFile.length());
-                    adr.setArtifactOrigin(origin);
-                } else {
-                    Artifact artifact = fromSystem(artifacts[i]);
-                    if (!artifact.equals(artifacts[i])) {
-                        Message.verbose("\t" + getName() + "looking for artifact " + artifact
-                                + " (is " + artifacts[i] + " in system namespace)");
-                    }
-                    long start = System.currentTimeMillis();
-                    try {
-                        ResolvedResource artifactRef = getArtifactRef(artifact, null);
-                        if (artifactRef != null) {
-                            origin = new ArtifactOrigin(artifactRef.getResource().isLocal(),
-                                    artifactRef.getResource().getName());
-                            if (useOrigin && artifactRef.getResource().isLocal()) {
-                                Message.verbose("\t[NOT REQUIRED] " + artifacts[i]);
-                                cacheManager.saveArtifactOrigin(artifacts[i], origin);
-                                archiveFile = cacheManager.getArchiveFileInCache(artifacts[i],
-                                    origin);
-                                adr.setDownloadStatus(DownloadStatus.NO);
-                                adr.setSize(archiveFile.length());
-                                adr.setArtifactOrigin(origin);
-                            } else {
-                                // refresh archive file now that we better now its origin
-                                archiveFile = cacheManager.getArchiveFileInCache(artifacts[i],
-                                    origin, useOrigin);
-                                if (ResourceHelper.equals(artifactRef.getResource(), archiveFile)) {
-                                    Message.error("invalid configuration for resolver '"
-                                            + getName()
-                                            + "': pointing artifacts to ivy cache is forbidden !");
-                                    return null;
-                                }
-                                Message.info("downloading " + artifactRef.getResource() + " ...");
-                                if (eventManager != null) {
-                                    eventManager.fireIvyEvent(new StartArtifactDownloadEvent(this,
-                                            artifacts[i], origin));
-                                }
+                long start = System.currentTimeMillis();
+                try {
+                    ResolvedResource artifactRef = getArtifactRef(artifact, null);
+                    if (artifactRef != null) {
+                        origin = new ArtifactOrigin(artifactRef.getResource().isLocal(),
+                                artifactRef.getResource().getName());
+                        if (useOrigin && artifactRef.getResource().isLocal()) {
+                            Message.verbose("\t[NOT REQUIRED] " + artifacts[i]);
+                            cacheManager.saveArtifactOrigin(artifacts[i], origin);
+                            archiveFile = cacheManager.getArchiveFileInCache(artifacts[i],
+                                origin);
+                            adr.setDownloadStatus(DownloadStatus.NO);
+                            adr.setSize(archiveFile.length());
+                            adr.setArtifactOrigin(origin);
+                        } else {
+                            // refresh archive file now that we better now its origin
+                            archiveFile = cacheManager.getArchiveFileInCache(artifacts[i],
+                                origin, useOrigin);
+                            if (ResourceHelper.equals(artifactRef.getResource(), archiveFile)) {
+                                Message.error("invalid configuration for resolver '"
+                                        + getName()
+                                        + "': pointing artifacts to ivy cache is forbidden !");
+                                return null;
+                            }
+                            Message.info("downloading " + artifactRef.getResource() + " ...");
+                            if (eventManager != null) {
+                                eventManager.fireIvyEvent(new StartArtifactDownloadEvent(this,
+                                        artifacts[i], origin));
+                            }
 
-                                File tmp = cacheManager.getArchiveFileInCache(new DefaultArtifact(
-                                        artifacts[i].getModuleRevisionId(), artifacts[i]
-                                                .getPublicationDate(), artifacts[i].getName(),
-                                        artifacts[i].getType(), artifacts[i].getExt() + ".part",
-                                        artifacts[i].getExtraAttributes()), origin, useOrigin);
-
-                                // deal with artifact with url special case
-                                if (artifactRef.getResource().getName().equals(
-                                    String.valueOf(artifacts[i].getUrl()))) {
-                                    Message.verbose("\t" + getName() + ": downloading "
-                                            + artifactRef.getResource().getName());
-                                    Message.debug("\t\tto " + tmp);
-                                    if (tmp.getParentFile() != null) {
-                                        tmp.getParentFile().mkdirs();
-                                    }
-                                    extartifactrep.get(artifactRef.getResource().getName(), tmp);
-                                    adr.setSize(tmp.length());
-                                } else {
-                                    adr.setSize(getAndCheck(artifactRef.getResource(), tmp));
-                                }
-                                if (!tmp.renameTo(archiveFile)) {
-                                    Message.warn("\t[FAILED     ] " + artifacts[i]
-                                            + " impossible to move temp file to definitive one ("
-                                            + (System.currentTimeMillis() - start) + "ms)");
-                                    adr.setDownloadStatus(DownloadStatus.FAILED);
-                                } else {
-                                    cacheManager.saveArtifactOrigin(artifacts[i], origin);
-                                    Message.info("\t[SUCCESSFUL ] " + artifacts[i] + " ("
-                                            + (System.currentTimeMillis() - start) + "ms)");
-                                    adr.setDownloadStatus(DownloadStatus.SUCCESSFUL);
-                                    adr.setArtifactOrigin(origin);
+                            File tmp = cacheManager.getArchiveFileInCache(new DefaultArtifact(
+                                    artifacts[i].getModuleRevisionId(), artifacts[i]
+                                            .getPublicationDate(), artifacts[i].getName(),
+                                    artifacts[i].getType(), artifacts[i].getExt() + ".part",
+                                    artifacts[i].getExtraAttributes()), origin, useOrigin);
+
+                            // deal with artifact with url special case
+                            if (artifactRef.getResource().getName().equals(
+                                String.valueOf(artifacts[i].getUrl()))) {
+                                Message.verbose("\t" + getName() + ": downloading "
+                                        + artifactRef.getResource().getName());
+                                Message.debug("\t\tto " + tmp);
+                                if (tmp.getParentFile() != null) {
+                                    tmp.getParentFile().mkdirs();
                                 }
+                                extartifactrep.get(artifactRef.getResource().getName(), tmp);
+                                adr.setSize(tmp.length());
+                            } else {
+                                adr.setSize(getAndCheck(artifactRef.getResource(), tmp));
+                            }
+                            if (!tmp.renameTo(archiveFile)) {
+                                Message.warn("\t[FAILED     ] " + artifacts[i]
+                                        + " impossible to move temp file to definitive one ("
+                                        + (System.currentTimeMillis() - start) + "ms)");
+                                adr.setDownloadStatus(DownloadStatus.FAILED);
+                            } else {
+                                cacheManager.saveArtifactOrigin(artifacts[i], origin);
+                                Message.info("\t[SUCCESSFUL ] " + artifacts[i] + " ("
+                                        + (System.currentTimeMillis() - start) + "ms)");
+                                adr.setDownloadStatus(DownloadStatus.SUCCESSFUL);
+                                adr.setArtifactOrigin(origin);
                             }
-                        } else {
-                            adr.setDownloadStatus(DownloadStatus.FAILED);
                         }
-                    } catch (Exception ex) {
-                        Message.warn("\t[FAILED     ] " + artifacts[i] + " : " + ex.getMessage()
-                                + " (" + (System.currentTimeMillis() - start) + "ms)");
+                    } else {
                         adr.setDownloadStatus(DownloadStatus.FAILED);
                     }
-                    checkInterrupted();
-                }
-                if (eventManager != null) {
-                    eventManager.fireIvyEvent(new EndArtifactDownloadEvent(this, artifacts[i], adr,
-                            archiveFile));
+                } catch (Exception ex) {
+                    Message.warn("\t[FAILED     ] " + artifacts[i] + " : " + ex.getMessage()
+                            + " (" + (System.currentTimeMillis() - start) + "ms)");
+                    adr.setDownloadStatus(DownloadStatus.FAILED);
                 }
+                checkInterrupted();
+            }
+            if (eventManager != null) {
+                eventManager.fireIvyEvent(new EndArtifactDownloadEvent(this, artifacts[i], adr,
+                        archiveFile));
             }
-            return dr;
-        } finally {
-            IvyContext.getContext().popResolver();
         }
+        return dr;
     }
 
     protected void clearArtifactAttempts() {
diff --git a/src/java/org/apache/ivy/plugins/resolver/RepositoryResolver.java b/src/java/org/apache/ivy/plugins/resolver/RepositoryResolver.java
index db3c07234..12e169bad 100644
--- a/src/java/org/apache/ivy/plugins/resolver/RepositoryResolver.java
+++ b/src/java/org/apache/ivy/plugins/resolver/RepositoryResolver.java
@@ -80,7 +80,7 @@ protected ResolvedResource findResourceUsingPattern(ModuleRevisionId mrid, Strin
             isAlwaysCheckExactRevision());
     }
 
-    public static ResolvedResource findResourceUsingPattern(String name, Repository repository,
+    public ResolvedResource findResourceUsingPattern(String name, Repository repository,
             LatestStrategy strategy, VersionMatcher versionMatcher, ResourceMDParser rmdparser,
             ModuleRevisionId mrid, String pattern, Artifact artifact, Date date,
             boolean alwaysCheckExactRevision) {
@@ -113,7 +113,7 @@ public static ResolvedResource findResourceUsingPattern(String name, Repository
         }
     }
 
-    private static ResolvedResource findDynamicResourceUsingPattern(String name,
+    private ResolvedResource findDynamicResourceUsingPattern(String name,
             Repository repository, LatestStrategy strategy, VersionMatcher versionMatcher,
             ResourceMDParser rmdparser, ModuleRevisionId mrid, String pattern, Artifact artifact,
             Date date) {
