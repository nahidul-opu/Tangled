From 2f861bcfac177afe6802a3c2f826d60eb568339e Mon Sep 17 00:00:00 2001
From: Oliver Heger <oheger@apache.org>
Date: Thu, 21 Jun 2007 19:57:25 +0000
Subject: [PATCH] CONFIGURATION-281: Cycles in the JNDI tree no longer cause a
 stack overflow in JNDIConfiguration

git-svn-id: https://svn.apache.org/repos/asf/jakarta/commons/proper/configuration/trunk@549591 13f79535-47bb-0310-9956-ffa450edef68
---
 .../configuration/JNDIConfiguration.java      | 12 ++-
 .../MockInitialContextFactory.java            | 98 ++++++++++++++++---
 .../configuration/TestJNDIConfiguration.java  | 19 ++++
 xdocs/changes.xml                             |  4 +
 4 files changed, 119 insertions(+), 14 deletions(-)

diff --git a/src/java/org/apache/commons/configuration/JNDIConfiguration.java b/src/java/org/apache/commons/configuration/JNDIConfiguration.java
index 1a76fc293c..98e2e22a2a 100644
--- a/src/java/org/apache/commons/configuration/JNDIConfiguration.java
+++ b/src/java/org/apache/commons/configuration/JNDIConfiguration.java
@@ -115,10 +115,12 @@ public JNDIConfiguration(Context context, String prefix)
      * @param keys All the keys that have been found.
      * @param context The parent context
      * @param prefix What prefix we are building on.
+     * @param processedCtx a set with the so far processed objects
      * @throws NamingException If JNDI has an issue.
      */
-    private void recursiveGetKeys(Set keys, Context context, String prefix) throws NamingException
+    private void recursiveGetKeys(Set keys, Context context, String prefix, Set processedCtx) throws NamingException
     {
+        processedCtx.add(context);
         NamingEnumeration elements = null;
 
         try
@@ -145,7 +147,11 @@ private void recursiveGetKeys(Set keys, Context context, String prefix) throws N
                 {
                     // add the keys of the sub context
                     Context subcontext = (Context) object;
-                    recursiveGetKeys(keys, subcontext, key.toString());
+                    if (!processedCtx.contains(subcontext))
+                    {
+                        recursiveGetKeys(keys, subcontext, key.toString(),
+                                processedCtx);
+                    }
                 }
                 else
                 {
@@ -202,7 +208,7 @@ public Iterator getKeys(String prefix)
             Set keys = new HashSet();
             if (context != null)
             {
-                recursiveGetKeys(keys, context, prefix);
+                recursiveGetKeys(keys, context, prefix, new HashSet());
             }
             else if (containsKey(prefix))
             {
diff --git a/src/test/org/apache/commons/configuration/MockInitialContextFactory.java b/src/test/org/apache/commons/configuration/MockInitialContextFactory.java
index f231cdda2b..4102f90758 100644
--- a/src/test/org/apache/commons/configuration/MockInitialContextFactory.java
+++ b/src/test/org/apache/commons/configuration/MockInitialContextFactory.java
@@ -39,12 +39,21 @@
  */
 public class MockInitialContextFactory implements InitialContextFactory
 {
+    /**
+     * Constant for the use cycles environment property. If this property is
+     * present in the environment, a cyclic context will be created.
+     */
+    public static final String PROP_CYCLES = "useCycles";
+
     /** Constant for the lookup method. */
     private static final String METHOD_LOOKUP = "lookup";
 
     /** Constant for the list method. */
     private static final String METHOD_LIST = "list";
 
+    /** Constant for the close method.*/
+    private static final String METHOD_CLOSE = "close";
+
     /** Constant for the name of the missing property. */
     private static final String MISSING_PROP = "/missing";
 
@@ -75,7 +84,10 @@ public class MockInitialContextFactory implements InitialContextFactory
      */
     public Context getInitialContext(Hashtable env) throws NamingException
     {
+        boolean useCycles = env.containsKey(PROP_CYCLES);
+
         Mock mockTopCtx = createCtxMock(PREFIX);
+        Mock mockCycleCtx = createCtxMock("");
         Mock mockPrfxCtx = createCtxMock("");
         Mock mockBaseCtx = new Mock(Context.class);
         mockBaseCtx.matchAndReturn(METHOD_LOOKUP, C.eq(""), mockTopCtx.proxy());
@@ -83,12 +95,33 @@ public Context getInitialContext(Hashtable env) throws NamingException
                 .proxy());
         mockTopCtx.matchAndReturn(METHOD_LOOKUP, C.eq("test"), mockPrfxCtx
                 .proxy());
-        mockTopCtx.matchAndReturn(METHOD_LIST, C.eq(""), createEnumMock(
-                mockTopCtx, new String[]
-                { "test" }, new Object[]
-                { mockPrfxCtx.proxy() }).proxy());
         mockPrfxCtx.matchAndReturn(METHOD_LIST, C.eq(""), createEnumMock(
                 mockPrfxCtx, PROP_NAMES, PROP_VALUES).proxy());
+
+        if (useCycles)
+        {
+            mockTopCtx.matchAndReturn(METHOD_LOOKUP, C.eq("cycle"),
+                    mockCycleCtx.proxy());
+            mockTopCtx.matchAndReturn(METHOD_LIST, C.eq(""), createEnumMock(
+                    mockTopCtx, new String[]
+                    { "test", "cycle" }, new Object[]
+                    { mockPrfxCtx.proxy(), mockCycleCtx.proxy() }).proxy());
+            Mock mockEnum = createEnumMock(mockCycleCtx, PROP_NAMES,
+                    PROP_VALUES, false);
+            addEnumPair(mockEnum, "cycleCtx", mockCycleCtx.proxy());
+            closeEnum(mockEnum);
+            mockCycleCtx
+                    .matchAndReturn(METHOD_LIST, C.eq(""), mockEnum.proxy());
+            mockCycleCtx.matchAndReturn(METHOD_LOOKUP, C.eq("cycleCtx"),
+                    mockCycleCtx.proxy());
+        }
+        else
+        {
+            mockTopCtx.matchAndReturn(METHOD_LIST, C.eq(""), createEnumMock(
+                    mockTopCtx, new String[]
+                    { "test" }, new Object[]
+                    { mockPrfxCtx.proxy() }).proxy());
+        }
         return (Context) mockBaseCtx.proxy();
     }
 
@@ -112,6 +145,8 @@ private Mock createCtxMock(String prefix)
         {
             bindError(mockCtx, MISSING_NAMES[i]);
         }
+        mockCtx.matchAndReturn("hashCode", System.identityHashCode(mockCtx.proxy()));
+        
         return mockCtx;
     }
 
@@ -146,20 +181,61 @@ private void bindError(Mock mockCtx, String name)
      * @param mockCtx the mock representing the context
      * @param names the names contained in the iteration
      * @param values the corresponding values
+     * @param close a flag whether the enumeration should expect to be closed
      * @return the mock for the enumeration
      */
-    private Mock createEnumMock(Mock mockCtx, String[] names, Object[] values)
+    private Mock createEnumMock(Mock mockCtx, String[] names, Object[] values,
+            boolean close)
     {
         Mock mockEnum = new Mock(NamingEnumeration.class);
         for (int i = 0; i < names.length; i++)
         {
-            NameClassPair ncp = new NameClassPair(names[i], values[i]
-                    .getClass().getName());
-            mockEnum.expectAndReturn("hasMore", true);
-            mockEnum.expectAndReturn("next", ncp);
+            addEnumPair(mockEnum, names[i], values[i]);
+        }
+        if (close)
+        {
+            closeEnum(mockEnum);
         }
-        mockEnum.expectAndReturn("hasMore", false);
-        mockEnum.expect("close");
         return mockEnum;
     }
+
+    /**
+     * Creates and initializes a mock for a naming enumeration that expects to
+     * be closed. This is a shortcut of createEnumMock(mockCtx, names, values,
+     * true);
+     *
+     * @param mockCtx the mock representing the context
+     * @param names the names contained in the iteration
+     * @param values the corresponding values
+     * @return the mock for the enumeration
+     */
+    private Mock createEnumMock(Mock mockCtx, String[] names, Object[] values)
+    {
+        return createEnumMock(mockCtx, names, values, true);
+    }
+
+    /**
+     * Adds a new name-and-value pair to an enum mock.
+     *
+     * @param mockEnum the enum mock
+     * @param name the name
+     * @param value the value
+     */
+    private void addEnumPair(Mock mockEnum, String name, Object value)
+    {
+        NameClassPair ncp = new NameClassPair(name, value.getClass().getName());
+        mockEnum.expectAndReturn("hasMore", true);
+        mockEnum.expectAndReturn("next", ncp);
+    }
+
+    /**
+     * Closes an enumeration mock.
+     *
+     * @param mockEnum the mock
+     */
+    private void closeEnum(Mock mockEnum)
+    {
+        mockEnum.expectAndReturn("hasMore", false);
+        mockEnum.expect(METHOD_CLOSE);
+    }
 }
diff --git a/src/test/org/apache/commons/configuration/TestJNDIConfiguration.java b/src/test/org/apache/commons/configuration/TestJNDIConfiguration.java
index 3a00902be0..8f46446fe3 100644
--- a/src/test/org/apache/commons/configuration/TestJNDIConfiguration.java
+++ b/src/test/org/apache/commons/configuration/TestJNDIConfiguration.java
@@ -17,6 +17,8 @@
 
 package org.apache.commons.configuration;
 
+import java.util.Hashtable;
+
 import junit.framework.TestCase;
 
 import javax.naming.Context;
@@ -258,6 +260,18 @@ public void testGetPropertyError()
                 null);
     }
 
+    /**
+     * Tests the getKeys() method when there are cycles in the tree.
+     */
+    public void testGetKeysWithCycles() throws NamingException
+    {
+        Hashtable env = new Hashtable();
+        env.put(MockInitialContextFactory.PROP_CYCLES, Boolean.TRUE);
+        InitialContext initCtx = new InitialContext(env);
+        conf = new JNDIConfiguration(initCtx);
+        conf.getKeys("cycle");
+    }
+
     /**
      * A special JNDI configuration implementation that can be configured to
      * throw an exception when accessing the base context. Used for testing the
@@ -273,6 +287,11 @@ public PotentialErrorJNDIConfiguration() throws NamingException
             super();
         }
 
+        public PotentialErrorJNDIConfiguration(Context ctx) throws NamingException
+        {
+            super(ctx);
+        }
+
         public Context getBaseContext() throws NamingException
         {
             if (failOnGetCtx)
diff --git a/xdocs/changes.xml b/xdocs/changes.xml
index 0bce4aaee0..bd0300f7ad 100644
--- a/xdocs/changes.xml
+++ b/xdocs/changes.xml
@@ -23,6 +23,10 @@
 
   <body>
     <release version="1.5-SNAPSHOT" date="in SVN" description="">
+      <action dev="oheger" type="fix" issue="CONFIGURATION-281">
+        Cycles in the JNDI tree no longer cause a stack overflow in
+        JNDIConfiguration.
+      </action>
       <action dev="oheger" type="add" issue="CONFIGURATION-277">
         The base implementation of clear() in AbstractConfiguration now checks
         for a potential UnsupportedOperationException when iterating over the
