From bf5d8de222878e3dc81a16cc98a28f9a9194b74b Mon Sep 17 00:00:00 2001
From: Maarten Coene <maartenc@apache.org>
Date: Fri, 28 Mar 2008 22:10:53 +0000
Subject: [PATCH] FIX: buildlist evicts modules with the same name, but
 different organisation (IVY-731)

git-svn-id: https://svn.apache.org/repos/asf/ant/ivy/core/trunk@642405 13f79535-47bb-0310-9956-ffa450edef68
---
 CHANGES.txt                                   |  1 +
 src/java/org/apache/ivy/ant/IvyBuildList.java | 53 +++++++++++-------
 test/buildlist/E2/build.xml                   | 18 +++++++
 test/buildlist/E2/ivy.xml                     | 21 ++++++++
 .../org/apache/ivy/ant/IvyBuildListTest.java  | 54 +++++++++++++++++--
 5 files changed, 125 insertions(+), 22 deletions(-)
 create mode 100644 test/buildlist/E2/build.xml
 create mode 100644 test/buildlist/E2/ivy.xml

diff --git a/CHANGES.txt b/CHANGES.txt
index bf780a3bb..487b46bb7 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -75,6 +75,7 @@ for detailed view of each issue, please consult http://issues.apache.org/jira/br
 - IMPROVEMENT: Parse description and home page from poms (IVY-767)
 - IMPROVEMENT: Smarter determination if an expression is exact or not for RegexpPatternMatcher and GlobPatternMatcher
 
+- FIX: buildlist evicts modules with the same name, but different organisation (IVY-731)
 - FIX: Out of memory/Stack overflow for new highly coupled project (IVY-595)
 - FIX: Compatibility with maven's dependencyMangement (IVY-753) (not completed yet)
 - FIX: ivy:settings fails when override is not set to 'true' (IVY-771)
diff --git a/src/java/org/apache/ivy/ant/IvyBuildList.java b/src/java/org/apache/ivy/ant/IvyBuildList.java
index b6b00f13d..6f9bbdc5b 100644
--- a/src/java/org/apache/ivy/ant/IvyBuildList.java
+++ b/src/java/org/apache/ivy/ant/IvyBuildList.java
@@ -22,8 +22,8 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Iterator;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.ListIterator;
@@ -153,8 +153,8 @@ public void doExecute() throws BuildException {
         Path path = new Path(getProject());
 
         Map buildFiles = new HashMap(); // Map (ModuleDescriptor -> File buildFile)
-        Map mdsMap = new LinkedHashMap(); // Map (String moduleName -> ModuleDescriptor)
         List independent = new ArrayList();
+        Collection mds = new ArrayList();
 
         Set rootModuleNames = new LinkedHashSet();
         if (!"*".equals(root)) {
@@ -202,7 +202,7 @@ public void doExecute() throws BuildException {
                         ModuleDescriptor md = ModuleDescriptorParserRegistry.getInstance()
                                 .parseDescriptor(settings, ivyFile.toURL(), doValidate(settings));
                         buildFiles.put(md, buildFile);
-                        mdsMap.put(md.getModuleRevisionId().getModuleId().getName(), md);
+                        mds.add(md);
                         Message.debug("Add " + md.getModuleRevisionId().getModuleId());
                     } catch (Exception ex) {
                         if (haltOnError) {
@@ -220,13 +220,12 @@ public void doExecute() throws BuildException {
         }
 
         List leafModuleDescriptors = 
-            convertModuleNamesToModuleDescriptors(mdsMap, leafModuleNames, "leaf");
+            convertModuleNamesToModuleDescriptors(mds, leafModuleNames, "leaf");
         List rootModuleDescriptors = 
-            convertModuleNamesToModuleDescriptors(mdsMap, rootModuleNames, "root");
+            convertModuleNamesToModuleDescriptors(mds, rootModuleNames, "root");
         List restartFromModuleDescriptors = 
-            convertModuleNamesToModuleDescriptors(mdsMap, restartFromModuleNames, "restartFrom");
+            convertModuleNamesToModuleDescriptors(mds, restartFromModuleNames, "restartFrom");
 
-        Collection mds = new ArrayList(mdsMap.values());
         if (!rootModuleDescriptors.isEmpty()) {
             Message.info("Filtering modules based on roots " + rootModuleNames);
             mds = filterModulesFromRoot(mds, rootModuleDescriptors);
@@ -248,7 +247,7 @@ public void doExecute() throws BuildException {
             Collections.reverse(sortedModules);
         }
         // Remove modules that are before the restartFrom point
-        // Independant modules (without valid ivy file) can not be addressed
+        // Independent modules (without valid ivy file) can not be addressed
         // so they are not removed from build path.
         if (!restartFromModuleDescriptors.isEmpty()) {
             boolean foundRestartFrom = false;
@@ -280,19 +279,37 @@ public void doExecute() throws BuildException {
         getProject().addReference(getReference(), path);
         getProject().setProperty("ivy.sorted.modules", order.toString());
     }
+    
+    private List convertModuleNamesToModuleDescriptors(Collection mds, Set moduleNames, String kind) {
+        List result = new ArrayList();
+        Set foundModuleNames = new HashSet();
+        
+        for (Iterator it = mds.iterator(); it.hasNext(); ) {
+            ModuleDescriptor md = (ModuleDescriptor) it.next();
+            String name = md.getModuleRevisionId().getModuleId().getName();
+            if (moduleNames.contains(name)) {
+                foundModuleNames.add(name);
+                result.add(md);
+            }
+        }
 
-    private List convertModuleNamesToModuleDescriptors(Map mdsMap, Set moduleNames, String kind) {
-        List mds = new ArrayList();
-        for (Iterator iter = moduleNames.iterator(); iter.hasNext();) {
-            String name = (String) iter.next();
-            ModuleDescriptor md = (ModuleDescriptor) mdsMap.get(name);
-            if (md == null) {
-                throw new BuildException("unable to find " + kind + " module " + name
-                        + " in build fileset");
+        if (foundModuleNames.size() < moduleNames.size()) {
+            Set missingModules = new HashSet(moduleNames);
+            missingModules.removeAll(foundModuleNames);
+            
+            StringBuffer missingNames = new StringBuffer();
+            String sep = "";
+            for (Iterator it = missingModules.iterator(); it.hasNext(); ) {
+                missingNames.append(sep);
+                missingNames.append(it.next());
+                sep = ", ";
             }
-            mds.add(md);
+            
+            throw new BuildException("unable to find " + kind + " module(s) " + missingNames.toString()
+                + " in build fileset");
         }
-        return mds;
+
+        return result;
     }
 
     /**
diff --git a/test/buildlist/E2/build.xml b/test/buildlist/E2/build.xml
new file mode 100644
index 000000000..84312b7a8
--- /dev/null
+++ b/test/buildlist/E2/build.xml
@@ -0,0 +1,18 @@
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   "License"); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.    
+-->
diff --git a/test/buildlist/E2/ivy.xml b/test/buildlist/E2/ivy.xml
new file mode 100644
index 000000000..f2103e377
--- /dev/null
+++ b/test/buildlist/E2/ivy.xml
@@ -0,0 +1,21 @@
+<!--
+   Licensed to the Apache Software Foundation (ASF) under one
+   or more contributor license agreements.  See the NOTICE file
+   distributed with this work for additional information
+   regarding copyright ownership.  The ASF licenses this file
+   to you under the Apache License, Version 2.0 (the
+   "License"); you may not use this file except in compliance
+   with the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing,
+   software distributed under the License is distributed on an
+   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+   KIND, either express or implied.  See the License for the
+   specific language governing permissions and limitations
+   under the License.    
+-->
+<ivy-module version="1.2">
+	<info organisation="apache2" module="E"/>
+</ivy-module>
diff --git a/test/java/org/apache/ivy/ant/IvyBuildListTest.java b/test/java/org/apache/ivy/ant/IvyBuildListTest.java
index adc9a1993..daec743b7 100644
--- a/test/java/org/apache/ivy/ant/IvyBuildListTest.java
+++ b/test/java/org/apache/ivy/ant/IvyBuildListTest.java
@@ -40,7 +40,7 @@ public class IvyBuildListTest extends TestCase {
      */
 
     //CheckStyle:MagicNumber| OFF   
-    //The test very often use MagicNumber.  Using a constant is less expessif.
+    //The test very often use MagicNumber.  Using a constant is less expressive.
 
     
     public void testSimple() {
@@ -52,7 +52,7 @@ public void testSimple() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
-        fs.setExcludes("F/build.xml,G/build.xml");
+        fs.setExcludes("E2/build.xml,F/build.xml,G/build.xml");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -91,7 +91,7 @@ public void testReverse() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
-        fs.setExcludes("F/build.xml,G/build.xml");
+        fs.setExcludes("E2/build.xml,F/build.xml,G/build.xml");
         buildlist.addFileset(fs);
 
         buildlist.setReference("reverse.ordered.build.files");
@@ -131,6 +131,7 @@ public void testWithRoot() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
+        fs.setExcludes("E2/**");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -188,6 +189,7 @@ public void testWithTwoRoots() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
+        fs.setExcludes("E2/**");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -224,6 +226,7 @@ public void testWithRootExclude() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
+        fs.setExcludes("E2/**");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -255,6 +258,7 @@ public void testWithRootAndOnlyDirectDep() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
+        fs.setExcludes("E2/**");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -287,6 +291,7 @@ public void testWithLeaf() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
+        fs.setExcludes("E2/**");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -349,6 +354,7 @@ public void testWithTwoLeafs() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
+        fs.setExcludes("E2/**");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -387,6 +393,7 @@ public void testWithLeafExclude() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
+        fs.setExcludes("E2/**");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -420,6 +427,7 @@ public void testWithLeafAndOnlyDirectDep() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
+        fs.setExcludes("E2/**");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -452,7 +460,7 @@ public void testRestartFrom() {
         FileSet fs = new FileSet();
         fs.setDir(new File("test/buildlist"));
         fs.setIncludes("**/build.xml");
-        fs.setExcludes("F/build.xml,G/build.xml");
+        fs.setExcludes("E2/build.xml,F/build.xml,G/build.xml");
         buildlist.addFileset(fs);
 
         buildlist.setReference("ordered.build.files");
@@ -479,7 +487,45 @@ public void testRestartFrom() {
                 .getAbsolutePath());
     }
 
+    public void testWithModuleWithSameNameAndDifferentOrg() {
+        Project p = new Project();
+
+        IvyBuildList buildlist = new IvyBuildList();
+        buildlist.setProject(p);
 
+        FileSet fs = new FileSet();
+        fs.setDir(new File("test/buildlist"));
+        fs.setIncludes("**/build.xml");
+        fs.setExcludes("F/build.xml,G/build.xml");
+        buildlist.addFileset(fs);
+
+        buildlist.setReference("ordered.build.files");
+
+        buildlist.execute();
+
+        Object o = p.getReference("ordered.build.files");
+        assertNotNull(o);
+        assertTrue(o instanceof Path);
+
+        Path path = (Path) o;
+        String[] files = path.list();
+        assertNotNull(files);
+        
+        assertEquals(6, files.length);
+
+        assertEquals(new File("test/buildlist/B/build.xml").getAbsolutePath(), new File(files[0])
+                .getAbsolutePath());
+        assertEquals(new File("test/buildlist/C/build.xml").getAbsolutePath(), new File(files[1])
+                .getAbsolutePath());
+        assertEquals(new File("test/buildlist/A/build.xml").getAbsolutePath(), new File(files[2])
+                .getAbsolutePath());
+        assertEquals(new File("test/buildlist/D/build.xml").getAbsolutePath(), new File(files[3])
+                .getAbsolutePath());
+        assertEquals(new File("test/buildlist/E2/build.xml").getAbsolutePath(), new File(files[4])
+                .getAbsolutePath());
+        assertEquals(new File("test/buildlist/E/build.xml").getAbsolutePath(), new File(files[5])
+                .getAbsolutePath());
+    }
     
 }
 //CheckStyle:MagicNumber| ON
\ No newline at end of file
