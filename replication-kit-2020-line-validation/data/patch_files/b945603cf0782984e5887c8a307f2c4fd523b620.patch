From b945603cf0782984e5887c8a307f2c4fd523b620 Mon Sep 17 00:00:00 2001
From: William Colen <colen@apache.org>
Date: Wed, 1 Aug 2012 14:12:19 +0000
Subject: [PATCH] OPENNLP-529: AD formatter was not working with Amazonia
 corpus. Now we add a fake root node if there is multiple roots.

git-svn-id: https://svn.apache.org/repos/asf/opennlp/trunk@1368010 13f79535-47bb-0310-9956-ffa450edef68
---
 .../tools/formats/ad/ADSentenceStream.java    | 97 +++++++++++--------
 .../formats/ad/ADChunkSampleStreamTest.java   |  4 +-
 .../formats/ad/ADNameSampleStreamTest.java    | 14 ++-
 .../formats/ad/ADParagraphStreamTest.java     |  6 +-
 .../ad/ADSentenceSampleStreamTest.java        |  2 +-
 .../formats/ad/ADTokenSampleStreamTest.java   |  2 +-
 .../resources/opennlp/tools/formats/ad.sample | 29 +++++-
 7 files changed, 108 insertions(+), 46 deletions(-)

diff --git a/opennlp-tools/src/main/java/opennlp/tools/formats/ad/ADSentenceStream.java b/opennlp-tools/src/main/java/opennlp/tools/formats/ad/ADSentenceStream.java
index 5f6913530..0e63f9100 100644
--- a/opennlp-tools/src/main/java/opennlp/tools/formats/ad/ADSentenceStream.java
+++ b/opennlp-tools/src/main/java/opennlp/tools/formats/ad/ADSentenceStream.java
@@ -146,59 +146,78 @@ public Sentence parse(String sentenceString, int para, boolean isTitle, boolean
         sentence.setText(text);
         sentence.setMetadata(meta);
         // now we look for the root node
-        line = reader.readLine();
 
+        // skip lines starting with ###
+        line = reader.readLine();
+        while(line != null && line.startsWith("###")) {
+        	line = reader.readLine();
+        }
+        
         // got the root. Add it to the stack
         Stack<Node> nodeStack = new Stack<Node>();
-        // we get the complete line
 
-        root.setSyntacticTag(line);
+        root.setSyntacticTag("ROOT");
         root.setLevel(0);
         nodeStack.add(root);
         
+        
         /* now we have to take care of the lastLevel. Every time it raises, we will add the
         leaf to the node at the top. If it decreases, we remove the top. */
-        line = reader.readLine();
+        
         while (line != null && line.length() != 0 && line.startsWith("</s>") == false && !line.equals("&&")) {
           TreeElement element = this.getElement(line);
           
           if(element != null) {
-            // remove elements at same level or higher
-            while (!nodeStack.isEmpty()
-                && element.getLevel() > 0 && element.getLevel() <= nodeStack.peek().getLevel()) {
-              nodeStack.pop();
+            // The idea here is to keep a stack of nodes that are candidates for
+            // parenting the following elements (nodes and leafs).
+
+            // 1) When we get a new element, we check its level and remove from
+            // the top of the stack nodes that are brothers or nephews.
+            while (!nodeStack.isEmpty() && element.getLevel() > 0
+                && element.getLevel() <= nodeStack.peek().getLevel()) {
+              Node nephew = nodeStack.pop();
             }
+            
             if( element.isLeaf() ) {
+              // 2a) If the element is a leaf and there is no parent candidate,
+              // add it as a daughter of the root.  
               if (nodeStack.isEmpty()) {
                 root.addElement(element);
-  						} else {
-  							// look for the node with the correct level
-  							Node peek = nodeStack.peek();
-  							if (element.level == 0) { // add to the root
-  								nodeStack.firstElement().addElement(element);
-  							} else {
-  								Node parent = null;
-  								int index = nodeStack.size() - 1;
-  								while(parent == null) {
-  									if(peek.getLevel() < element.getLevel()) {
-  										parent = peek;
-  									} else {
-  										index--;
-  										if(index > -1) {
-  											peek = nodeStack.get(index);
-  										} else {
-  											parent = nodeStack.firstElement();
-  										}
-  									}
-  								}
-  								parent.addElement(element);
-  							}
+              } else {
+                // 2b) There are parent candidates. 
+                // look for the node with the correct level
+                Node peek = nodeStack.peek();
+                if (element.level == 0) { // add to the root
+                  nodeStack.firstElement().addElement(element);
+                } else {
+                  Node parent = null;
+                  int index = nodeStack.size() - 1;
+                  while (parent == null) {
+                    if (peek.getLevel() < element.getLevel()) {
+                      parent = peek;
+                    } else {
+                      index--;
+                      if (index > -1) {
+                        peek = nodeStack.get(index);
+                      } else {
+                        parent = nodeStack.firstElement();
+                      }
+                    }
+                  }
+                  parent.addElement(element);
+                }
               }
             } else {
-              if (!nodeStack.isEmpty()) {
-                nodeStack.peek().addElement(element);
+              // 3) Check if the element that is at the top of the stack is this
+              // node parent, if yes add it as a son 
+              if (!nodeStack.isEmpty() && nodeStack.peek().getLevel() < element.getLevel()) {
+                  nodeStack.peek().addElement(element);
+              } else {
+                System.err.println("should not happen!");
               }
+              // 4) Add it to the stack so it is a parent candidate.
               nodeStack.push((Node) element);
+              
             }
           }
           line = reader.readLine();
@@ -228,10 +247,12 @@ private String fixPunctuation(String text) {
      * @return the tree element
      */
     public TreeElement getElement(String line) {
+      // Note: all levels are higher than 1, because 0 is reserved for the root.
+      
       // try node
       Matcher nodeMatcher = nodePattern.matcher(line);
       if (nodeMatcher.matches()) {
-        int level = nodeMatcher.group(1).length();
+        int level = nodeMatcher.group(1).length() + 1;
         String syntacticTag = nodeMatcher.group(2);
         Node node = new Node();
         node.setLevel(level);
@@ -241,7 +262,7 @@ public TreeElement getElement(String line) {
 
       Matcher leafMatcher = leafPattern.matcher(line);
       if (leafMatcher.matches()) {
-        int level = leafMatcher.group(1).length();
+        int level = leafMatcher.group(1).length() + 1;
         String syntacticTag = leafMatcher.group(2);
         String funcTag = leafMatcher.group(3);
         String lemma = leafMatcher.group(4);
@@ -262,7 +283,7 @@ public TreeElement getElement(String line) {
 
       Matcher punctuationMatcher = punctuationPattern.matcher(line);
       if (punctuationMatcher.matches()) {
-        int level = punctuationMatcher.group(1).length();
+        int level = punctuationMatcher.group(1).length() + 1;
         String lexeme = punctuationMatcher.group(2);
         Leaf leaf = new Leaf();
         leaf.setLevel(level);
@@ -278,7 +299,7 @@ public TreeElement getElement(String line) {
       if(line.startsWith("=")) {
       	Matcher bizarreLeafMatcher = bizarreLeafPattern.matcher(line);
         if (bizarreLeafMatcher.matches()) {
-          int level = bizarreLeafMatcher.group(1).length();
+          int level = bizarreLeafMatcher.group(1).length() + 1;
           String syntacticTag = bizarreLeafMatcher.group(2);
           String lemma = bizarreLeafMatcher.group(3);
           String morphologicalTag = bizarreLeafMatcher.group(4);
@@ -297,7 +318,7 @@ public TreeElement getElement(String line) {
 
           return leaf;
         } else {
-        	int level = line.lastIndexOf("=");
+        	int level = line.lastIndexOf("=") + 1;
         	String lexeme = line.substring(level + 1);
         	
         	if(lexeme.matches("\\w.*?[\\.<>].*")) {
@@ -316,7 +337,7 @@ public TreeElement getElement(String line) {
       
       System.err.println("Couldn't parse leaf: " + line);
       Leaf leaf = new Leaf();
-      leaf.setLevel(0);
+      leaf.setLevel(1);
       leaf.setSyntacticTag("");
       leaf.setMorphologicalTag("");
       leaf.setLexeme(line);
diff --git a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADChunkSampleStreamTest.java b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADChunkSampleStreamTest.java
index cd651572c..bac2e2e5b 100644
--- a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADChunkSampleStreamTest.java
+++ b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADChunkSampleStreamTest.java
@@ -37,7 +37,7 @@ public class ADChunkSampleStreamTest {
 
   @Test
   public void testSimpleCount() throws IOException {
-    assertEquals(6, samples.size());
+    assertEquals(ADParagraphStreamTest.NUM_SENTENCES, samples.size());
   }
 
   @Test
@@ -45,7 +45,7 @@ public void testChunks() throws IOException {
 
     assertEquals("Inicia", samples.get(0).getSentence()[0]);
     assertEquals("v-fin", samples.get(0).getTags()[0]);
-    assertEquals("B-NP", samples.get(0).getPreds()[2]);
+    assertEquals("B-VP", samples.get(0).getPreds()[0]);
 
     assertEquals("em", samples.get(0).getSentence()[1]);
     assertEquals("prp", samples.get(0).getTags()[1]);
diff --git a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADNameSampleStreamTest.java b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADNameSampleStreamTest.java
index b14a176cb..4fdc77ef2 100644
--- a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADNameSampleStreamTest.java
+++ b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADNameSampleStreamTest.java
@@ -38,7 +38,7 @@ public class ADNameSampleStreamTest {
 
   @Test
   public void testSimpleCount() throws IOException {
-    assertEquals(6, samples.size());
+    assertEquals(ADParagraphStreamTest.NUM_SENTENCES, samples.size());
   }
   
   @Test
@@ -98,6 +98,18 @@ public void testNames() throws IOException {
     
     assertEquals(new Span(0, 3, "person"), samples.get(5).getNames()[0]);//    0..1
   }
+  
+  @Test
+  public void testSmallSentence() throws IOException {
+    assertEquals(2, samples.get(6).getSentence().length);
+  }
+  
+  @Test
+  public void testMissingRightContraction() throws IOException {
+    assertEquals(new Span(0, 1, "person"), samples.get(7).getNames()[0]);
+    assertEquals(new Span(3, 4, "person"), samples.get(7).getNames()[1]);
+    assertEquals(new Span(5, 6, "person"), samples.get(7).getNames()[2]);
+  }
 
   @Before
   public void setup() throws IOException {
diff --git a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADParagraphStreamTest.java b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADParagraphStreamTest.java
index a9ee01827..df2b9f20c 100644
--- a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADParagraphStreamTest.java
+++ b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADParagraphStreamTest.java
@@ -29,6 +29,8 @@
 
 public class ADParagraphStreamTest {
 
+  public static final int NUM_SENTENCES = 8;
+
   @Test
   public void testSimpleReading() throws IOException {
     int count = 0;
@@ -43,7 +45,7 @@ public void testSimpleReading() throws IOException {
 //      paragraph.getRoot();
     }
     
-    assertEquals(6, count);
+    assertEquals(ADParagraphStreamTest.NUM_SENTENCES, count);
   }
   
   @Test
@@ -59,7 +61,7 @@ public void testLeadingWithContraction() throws IOException {
       paragraph = stream.read();
     }
     
-    assertEquals(6, count);
+    assertEquals(ADParagraphStreamTest.NUM_SENTENCES, count);
   }
   
   private static ADSentenceStream openData() throws IOException {
diff --git a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADSentenceSampleStreamTest.java b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADSentenceSampleStreamTest.java
index da99361bc..235f7bbea 100644
--- a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADSentenceSampleStreamTest.java
+++ b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADSentenceSampleStreamTest.java
@@ -38,7 +38,7 @@ public class ADSentenceSampleStreamTest {
 
   @Test
   public void testSimpleCount() throws IOException {
-    assertEquals(3, samples.size()); // means that there are 3 documents
+    assertEquals(5, samples.size());
   }
 
   @Test
diff --git a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADTokenSampleStreamTest.java b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADTokenSampleStreamTest.java
index 33dc6216c..15844357f 100644
--- a/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADTokenSampleStreamTest.java
+++ b/opennlp-tools/src/test/java/opennlp/tools/formats/ad/ADTokenSampleStreamTest.java
@@ -38,7 +38,7 @@ public class ADTokenSampleStreamTest {
 
   @Test
   public void testSimpleCount() throws IOException {
-    assertEquals(6, samples.size()); // means that there are 3 documents
+    assertEquals(ADParagraphStreamTest.NUM_SENTENCES, samples.size());
   }
 
   @Test
diff --git a/opennlp-tools/src/test/resources/opennlp/tools/formats/ad.sample b/opennlp-tools/src/test/resources/opennlp/tools/formats/ad.sample
index 5cdff43c0..0f1736f0d 100644
--- a/opennlp-tools/src/test/resources/opennlp/tools/formats/ad.sample
+++ b/opennlp-tools/src/test/resources/opennlp/tools/formats/ad.sample
@@ -235,4 +235,31 @@ STA:fcl
 ====>N:pron-det("um" <arti> DET M S)	um
 ====H:n("café" M S)	café
 .
-</s>
\ No newline at end of file
+</s>
+
+<s id="122426" ref="1002.pesquisa da usp mapeia cultura livre em são paulo-14" source="SELVA 1002.pesquisa da usp mapeia cultura livre em são paulo">
+SOURCE: ref="1002.pesquisa da usp mapeia cultura livre em são paulo-14" source="SELVA 1002.pesquisa da usp mapeia cultura livre em são paulo"
+1002 Contato:
+A1
+UTT:n("contato" <np-idf> <ac> M S)      Contato
+:
+
+</s>
+
+<s id="10099" ref="1783.sim o ms tambem tem-forro=removeme=-31" source="SELVA 1783.sim o ms tambem tem-forro=removeme=">
+SOURCE: ref="1783.sim o ms tambem tem-forro=removeme=-31" source="SELVA 1783.sim o ms tambem tem-forro=removeme="
+1783 Gonzagão e aquele outro Zé apelidado Jackson.
+A1
+STA:fcl
+=ACC:cu
+==CJT:prop("Gonzagão" <cjt-head> <hum> <right> M/F S)    Gonzagão
+==CO:conj-c("e" <co-acc>)        e
+==CJT:pron-det("aquele" <cjt-acc> <sam-> <right> DET M S)        aquele
+==CJT:np
+===H:prop("Zé" <cjt-acc> <hum> <right> M S)      Zé
+===N<:adj("apelidado" <np-close> M S)    apelidado
+==CJT:prop("Jackson" <cjt-acc> <hum> <right> M S)        Jackson
+.
+
+</s>
+</ext>
\ No newline at end of file
